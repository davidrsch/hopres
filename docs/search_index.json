[["index.html", "Programación práctica con R Bienvenido Sobre la traducción Sobre la versión original en inglés", " Programación práctica con R Garrett Grolemund Bienvenido Este es el sitio web para la versión en español de “Hands-On Programming with R” (en lo adelante “Programación Práctica con R”) de Garrett Grolemund. Este libro le enseñará cómo programar en R, con ejemplos prácticos. Fue escrito para personas que no son programadores con el objetivo de proporcionar una introducción amigable al lenguaje R. Aprenderá a cargar datos, ensamblar y desensamblar objetos de datos, navegar por el sistema de entorno de R, escribir sus propias funciones y utilizar todas las herramientas de programación de R. A lo largo del libro, utilizará sus nuevas habilidades para resolver problemas prácticos de ciencia de datos. Si ya se siente cómodo con R y le gustaría enfocarse en cómo analizar datos usando los paquetes Tidyverse de R, se recomienda R para la Ciencia de Datos, un libro de Garrett Grolemund y Hadley Wickham. Sobre la traducción Esta traducción de “Programación práctica con R” es un proyecto personal de David Díaz Rodríguez con el objetivo de facilitar el estudio del lenguje de programación R, tanto al propio traductor como a todas aquellas personas de habla hispana que deseen aprender a programar con R. Señalar que esta es una traducción textual del libro por lo que en lo adelante cuando el autor se refiere así mismo en primera persona, será Garrett Grolemund y no el traductor, a excepción del prefacio que fue escrito por Hadley Wickham. Sobre la versión original en inglés Puede consultar la versión original del libro en Hands-On Programming with R. Si desea una copia física del libro, puede solicitarla en amazon; fue publicado por O’Reilly en julio de 2014. Si desea retribuir, considere informar un error tipográfico o realizar un pull request en github.com/rstudio-education/hopr para la versión original y en github.com/davidrsch/hopres para esta traducción. Este sitio web es (y siempre será) de uso gratuito y está licenciado bajo la licencia Creative Commons Attribution-NonCommercial-NoDerivs 4.0. El libro está escrito en RMarkdown con bookdown. "],["prefacio.html", "Prefacio Convenciones Usadas en Este Libro Reconocimientos", " Prefacio Este libro le enseñará cómo programar en R. Pasará de cargar datos a escribir sus propias funciones (que superarán las funciones de otros usuarios de R). Pero esta no es una introducción típica a R. Quiero ayudarlo a convertirse en científico de datos, así como en informático, por lo que este libro se centrará en las habilidades de programación que están más relacionadas con la ciencia de datos. Los capítulos del libro están ordenados de acuerdo con tres proyectos prácticos; dado que son proyectos bastante sustanciales, abarcan varios capítulos. Elegí estos proyectos por dos razones. Primero, cubren la amplitud del lenguaje R. Aprenderá a cargar datos, ensamblar y desensamblar objetos de datos, navegar por el sistema de entorno de R, escribir sus propias funciones y utilizar todas las herramientas de programación de R, como declaraciones if else, bucles, clases S3, sistema de paquetes de R, y las herramientas de depuración de R. Los proyectos también le enseñarán cómo escribir código R vectorizado, un estilo de código ultrarrápido que aprovecha todas las cosas que R hace mejor. Pero, lo que es más importante, los proyectos le enseñarán cómo resolver los problemas logísticos de la ciencia de datos—y hay muchos problemas logísticos. Cuando trabaje con datos, deberá almacenar, recuperar y manipular grandes conjuntos de valores sin introducir errores. A medida que avance en el libro, le enseñaré no solo cómo programar con R, sino también cómo usar las habilidades de programación para respaldar su trabajo como científico de datos. No todos los programadores necesitan ser científicos de datos, por lo que no todos los programadores encontrarán útil este libro. Encontrará este libro útil si se encuentra en una de las siguientes categorías: Ya usas R como herramienta estadística, pero te gustaría aprender a escribir tus propias funciones y simulaciones con R. Te gustaría aprender a programar por tu cuenta y ves el sentido de aprender un lenguaje relacionado con la ciencia de datos. Una de las mayores sorpresas de este libro es que no cubro las aplicaciones tradicionales de R, como modelos y gráficos; en cambio, trato a R puramente como un lenguaje de programación. ¿Por qué este enfoque estrecho? R está diseñado para ser una herramienta que ayude a los científicos a analizar datos. Tiene muchas funciones excelentes que hacen gráficos y ajustan modelos a los datos. Como resultado, muchos estadísticos aprenden a usar R como si fuera una pieza de software: aprenden qué funciones hacen lo que quieren e ignoran el resto. Este es un enfoque comprensible para aprender R. La visualización y el modelado de datos son habilidades complicadas que requieren toda la atención de un científico. Se necesita experiencia, juicio y enfoque para extraer información confiable de un conjunto de datos. No recomendaría que ningún científico de datos se distraiga con la programación de computadoras hasta que se sienta cómodo con la teoría y la práctica básicas de su oficio. Si desea aprender el oficio de la ciencia de datos, le recomiendo el libro R para la Ciencia de Datos, mi volumen complementario a este libro, coescrito con Hadley Wickham. Sin embargo, aprender a programar debería estar en la lista de tareas de todos los científicos de datos. Saber programar lo convertirá en un analista más flexible y aumentará su dominio de la ciencia de datos en todos los sentidos. Mi metáfora favorita para describir esto fue presentada por Greg Snow en la lista de correo de ayuda de R en mayo de 2006. Usar funciones en R es como viajar en autobús. Escribir funciones en R es como conducir un coche. Los autobuses son muy fáciles de usar, solo necesita saber a qué autobús subir, dónde subir y dónde bajarse (y debe pagar su tarifa). Los autos, por otro lado, requieren mucho más trabajo: necesitas tener algún tipo de mapa o direcciones (incluso si el mapa está en tu cabeza), necesitas poner gasolina de vez en cuando, necesitas saber las reglas de la vía (tener algún tipo de licencia de conducir). La gran ventaja del automóvil es que puede llevarlo a muchos lugares a los que el autobús no llega y es más rápido para algunos viajes que requieren transbordo entre autobuses. Usando esta analogía, los programas como SPSS son buses, fáciles de usar para cosas estándar, pero muy frustrantes si quieres hacer algo que no está preprogramado. R es un todoterreno con tracción en las cuatro ruedas (aunque respetuoso con el medio ambiente) con una bicicleta en la parte trasera, un kayak en la parte superior, buenos zapatos para caminar y correr en el asiento del pasajero y equipo para escalar montañas y espeleología en la parte trasera. R puede llevarlo a donde quiera ir si se toma el tiempo para aprender a usar el equipo, pero eso llevará más tiempo que aprender dónde están las paradas de autobús en SPSS. - Greg Snow Greg compara R con SPSS, pero asume que usa todos los poderes de R; es decir, que aprendas a programar en R. Si solo usas funciones que ya existen en R, estás usando R como SPSS: es un bus que solo te puede llevar a ciertos lugares. Esta flexibilidad es importante para los científicos de datos. Los detalles exactos de un método o simulación cambiarán de un problema a otro. Si no puede crear un método adaptado a su situación, puede verse tentado a hacer suposiciones poco realistas solo para poder utilizar un método inadecuado que ya existe. Este libro te ayudará a dar el salto del autobús al automóvil. Lo he escrito para programadores principiantes. No hablo de la teoría de las ciencias de la computación—no hay discusiones sobre la gran O() y la pequeña o() en estas páginas. Tampoco entro en detalles avanzados como el funcionamiento de la evaluación concisa. Estas aspectos son interesantes si piensas en informática a nivel teórico, pero son una distracción cuando aprendes a programar por primera vez. En su lugar, te enseño a programar en R con tres ejemplos concretos. Estos ejemplos son cortos, fáciles de entender y cubren todo lo que necesita saber. He enseñado este material muchas veces en mi trabajo como Master Instructor en RStudio. Como docente, he descubierto que los estudiantes aprenden conceptos abstractos mucho más rápido cuando se ilustran con ejemplos concretos. Los ejemplos también tienen una segunda ventaja: proporcionan una práctica inmediata. Aprender a programar es como aprender a hablar otro idioma—yprogresas más rápido cuando practicas. De hecho, aprender a programar es aprender a hablar otro idioma. Obtendrá los mejores resultados si sigue los ejemplos del libro y experimenta cada vez que se le ocurre una idea. El libro es un complemento de R para la Ciencia de Datos. En ese libro, Hadley Wickham y yo explicamos cómo usar R para hacer diagramas, modelar datos y escribir informes. Ese libro enseña estas tareas como habilidades de ciencia de datos, que requieren juicio y experiencia—no como ejercicios de programación, que también lo son. Este libro le enseñará a programar en R. No se supone que haya dominado las habilidades de ciencia de datos que se enseñan en R para la Ciencia de Datos (ni que tenga la intención de hacerlo). Sin embargo, este conjunto de habilidades amplifica ese. Y si domina ambos, será un científico de datos con conocimientos de informática, apto para obtener un salario alto e influir en el diálogo científico. Convenciones Usadas en Este Libro En este libro se utilizan las siguientes convenciones tipográficas: Cursiva:: Indica nuevos términos, URL, direcciones de correo electrónico, nombres de archivo y extensiones de archivo. Ancho contante:: se utiliza para listas de programas, así como dentro de párrafos para referirse a elementos de programas como nombres de variables o funciones, bases de datos, tipos de datos, variables de entorno, declaraciones y palabras clave. `Negrita de ancho constante:: Smuestra comandos u otro texto que el usuario debe escribir literalmente. Cursiva de ancho constante:: muestra texto que debe reemplazarse con valores proporcionados por el usuario o por valores determinados por el contexto. Para comentar o hacer preguntas técnicas sobre este libro, presente un issue en github.com/rstudio-education/hopr. Reconocimientos Muchas personas excelentes me han ayudado a escribir este libro, desde mis dos editoras, Courtney Nash y Julie Steele, hasta el resto del equipo de O’Reilly, quienes diseñaron, corrigieron e indexaron el libro. Además, Greg Snow me permitió generosamente citarlo en este prefacio. Les ofrezco todo mi más sincero agradecimiento. También me gustaría agradecer a Hadley Wickham, quien ha moldeado la forma en que pienso y enseño R. Muchas de las ideas de este libro provienen de Estadística 405, un curso que ayudé a enseñar a Hadley cuando era estudiante de doctorado en la Universidad de Rice. Más ideas provinieron de los estudiantes y profesores de Introducción a la ciencia de datos con R, un taller que enseño en nombre de RStudio. Gracias a todos ustedes. Me gustaría agradecer especialmente a mis asistentes de enseñanza Josh Paulson, Winston Chang, Jaime Ramos, Jay Emerson y Vivian Zhang. Gracias también a JJ Allaire y al resto de mis colegas de RStudio que proporcionan el IDE de RStudio, una herramienta que hace que sea mucho más fácil usar, enseñar y escribir sobre R. Finalmente, quisiera agradecer a mi esposa, Kristin, por su apoyo y comprensión mientras escribía este libro. "],["dice.html", "1 Proyecto 1: Dados Ponderados", " 1 Proyecto 1: Dados Ponderados Las computadoras le permiten ensamblar, manipular y visualizar conjuntos de datos, todo a velocidades que habrían asombrado a los científicos de ayer. En resumen, ¡las computadoras te dan superpoderes científicos! Pero si desea usarlos, deberá adquirir algunas habilidades de programación. Como científico de datos que sabe programar, mejorará su capacidad para: Memorizar (almacenar) conjuntos de datos completos Recuperar valores de datos demandados Realizar cálculos complejos con grandes cantidades de datos Realizar tareas repetitivas sin descuidarse ni aburrirse Las computadoras pueden hacer todas estas cosas rápidamente y sin errores, lo que le permite a su mente hacer lo que mejor hace bien: tomar decisiones y asignar significado. ¿Suena emocionante? ¡Estupendo! Vamos a empezar. Cuando era estudiante universitario, a veces soñaba despierto con ir a Las Vegas. Pensé que saber estadísticas podría ayudarme a ganar a lo grande. Si eso es lo que te llevó a la ciencia de datos, será mejor que te sientes; tengo algunas malas noticias. Incluso un estadístico perderá dinero en un casino a largo plazo. Esto se debe a que las probabilidades de cada juego siempre están a favor del casino, sin embargo, hay una laguna en esta regla. Puede ganar dinero–y también de manera confiable. Todo lo que tienes que hacer es ser el casino. Lo creas o no, R puede ayudarte a hacerlo. A lo largo del libro, usará R para construir tres objetos virtuales: un par de dados que puede lanzar para generar números aleatorios, una baraja de cartas que puede barajar y repartir, y una máquina tragamonedas inspirada en máquinas reales. Después de eso, solo necesitará agregar algunos gráficos de video y una cuenta bancaria (y tal vez obtener algunas licencias gubernamentales), y estará en el negocio. Te dejo esos detalles a ti. Estos proyectos son ligeros, pero también profundos. A medida que los complete, se convertirá en un experto en las habilidades que necesita para trabajar con datos como científico de datos. Aprenderá cómo almacenar datos en la memoria de su computadora, cómo acceder a los datos que ya están allí y cómo transformar los valores de los datos en la memoria cuando sea necesario. También aprenderá a escribir sus propios programas en R que puede usar para analizar datos y ejecutar simulaciones. Si simular una máquina tragamonedas (o dados o cartas) parece frívolo, piénselo de esta manera: jugar en una máquina tragamonedas es un proceso. Una vez que pueda simularlo, podrá simular otros procesos, como el muestreo de arranque, la cadena de Markov Monte Carlo y otros procedimientos de análisis de datos. Además, estos proyectos brindan ejemplos concretos para aprender todos los componentes de la programación R: objetos, tipos de datos, clases, notación, funciones, entornos, árboles if, bucles y vectorización. Este primer proyecto facilitará el estudio de estas cosas al enseñarle los conceptos básicos de R. Su primera misión es simple: ensamblar código R que simulará lanzar un par de dados, como en una mesa de dados. Una vez que haya hecho eso, ponderaremos un poco los dados a su favor, solo para mantener las cosas interesantes. En este proyecto, aprenderá cómo: Utilizar las interfaces R y RStudio Ejecutar comandos R Crear objetos R Escribir sus propias funciones y scripts de R Cargar y usar paquetes R Generar muestras aleatorias Crear gráficos de manera rápida Obtener ayuda cuando la necesite No se preocupe si parece que cubrimos mucho terreno de manera rápido. Este proyecto está diseñado para brindarle una descripción general concisa del lenguaje R. Regresará a muchos de los conceptos que aprederá en los proyectos 2 y 3, donde examinará los conceptos en profundidad. Deberá tener R y RStudio instalados en su computadora antes de poder usarlos. Ambos son gratuitos y fáciles de descargar. Consulte el Apéndice A para obtener instrucciones completas. Si está listo para comenzar, abra RStudio en su computadora y siga leyendo. "],["Básico.html", "2 Lo Más Básico 2.1 La Interfaz de Usuario de R 2.2 Objetos 2.3 Funciones 2.4 Escribiendo Sus Propias Funciones 2.5 Argumentos 2.6 Scripts 2.7 Resumen", " 2 Lo Más Básico Este capítulo proporciona una descripción general amplia del lenguaje R que lo ayudará a programar de inmediato. En él, construirás un par de dados virtuales que puedes usar para generar números aleatorios. No se preocupe si nunca ha programado antes; el capítulo le enseñará todo lo que necesita saber. Para simular un par de dados, tendrás que destilar cada dado en sus características esenciales. No puede colocar un objeto físico, como un dado, en una computadora (bueno, no sin destornillar algunos tornillos), pero puede guardar información sobre el objeto en la memoria de su computadora. ¿Qué información debe guardar? En general, un dado tiene seis piezas importantes de información: cuando tiras un dado, solo puede dar como resultado uno de los seis números: 1, 2, 3, 4, 5 y 6. Puedes capturar las características esenciales de un dado guardando los números 1, 2, 3, 4, 5 y 6 como un grupo de valores en la memoria de su computadora. Trabajemos primero en guardar estos números y luego consideremos un método para “lanzar” nuestro dado. 2.1 La Interfaz de Usuario de R Antes de que pueda pedirle a su computadora que guarde algunos números, necesitará saber cómo hablarle. Ahí es donde entran R y RStudio. RStudio le brinda una manera de comunicarse con su computadora. R le brinda un idioma para hablar. Para comenzar, abra RStudio tal como abriría cualquier otra aplicación en su computadora. Cuando lo haga, debería aparecer una ventana en su pantalla como la que se muestra en la Figura 2.1. Figure 2.1: Su computadora cumple con sus órdenes cuando escribe comandos R en el indicador en la línea inferior del panel de la consola. No olvides presionar la tecla Enter. Cuando abre RStudio por primera vez, la consola aparece en el panel de su izquierda, pero puede cambiar esto con File &gt; Preferences en la barra de menú. Si aún no tiene R y RStudio instalados en su computadora–o no sabe de lo que estoy hablando– visite el Apéndice A. El apéndice le dará una descripción general de las dos herramientas gratuitas y le indicará cómo descargarlas. La interfaz de RStudio es simple. Escriba el código R en la línea inferior del panel de la consola de RStudio y luego haga clic en Entrar para ejecutarlo. El código que escribe se llama comando, porque ordenará a su computadora que haga algo por usted. La línea en la que lo escribe se llama línea de comando. Cuando escribe un comando en la consola y presiona Enter, su computadora ejecuta el comando y le muestra los resultados. Luego, RStudio muestra un mensaje nuevo para su próximo comando. Por ejemplo, si escribe 1 + 1 y pulsa Enter, RStudio mostrará: &gt; 1 + 1 [1] 2 &gt; Notarás que aparece un [1] al lado de tu resultado. R solo le informa que esta línea comienza con el primer valor en su resultado. Algunos comandos devuelven más de un valor y sus resultados pueden llenar varias líneas. Por ejemplo, el comando 100:130 devuelve 31 valores; crea una secuencia de números enteros del 100 al 130. Observe que aparecen nuevos números entre corchetes al comienzo de la segunda y tercera líneas de salida. Estos números solo significan que la segunda línea comienza con el valor 14 en el resultado y la tercera línea comienza con el valor 25. En su mayoría, puede ignorar los números que aparecen entre corchetes: &gt; 100:130 [1] 100 101 102 103 104 105 106 107 108 109 110 111 112 [14] 113 114 115 116 117 118 119 120 121 122 123 124 125 [25] 126 127 128 129 130 El operador de dos puntos (:) devuelve todos los números enteros entre los dos números enteros especificados antes y después de los dos puntos. Es una manera fácil de crear una secuencia de números. ¿R no es un idioma? Es posible que me escuche hablar de R en tercera persona. Por ejemplo, podría decir: “Dígale a R que haga esto” o “Dígale a R que haga aquello”, pero, por supuesto, R no puede hacer nada; es solo un idioma. Esta forma de hablar es una forma abreviada de decir: “Dígale a su computadora que haga esto escribiendo un comando en el lenguaje R en su consola RStudio”. Su computadora, y no R, hace el trabajo real. ¿Es esta abreviatura confusa y un poco perezosa de usar? Sí. ¿Lo usa mucha gente? Todos los que conozco, probablemente porque es muy conveniente. ¿Cuándo compilamos? En algunos lenguajes, como C, Java y FORTRAN, debe compilar su código legible por humanos en un código legible por máquina (a menudo 1 y 0) antes de poder ejecutarlo. Si ha programado en un lenguaje de este tipo antes, puede preguntarse si tiene que compilar su código R antes de poder usarlo. La respuesta es no. R es un lenguaje de programación dinámico, lo que significa que R interpreta automáticamente su código a medida que lo ejecuta. Si escribe un comando incompleto y presiona Enter, R mostrará un + en la consola, lo que significa que R está esperando que escriba el resto de su comando. Termina el comando o presiona Escape para comenzar de nuevo: &gt; 5 - + + 1 [1] 4 Si escribe un comando que R no reconoce, R devolverá un mensaje de error. Si alguna vez ve un mensaje de error, no entre en pánico. R solo le está diciendo que su computadora no pudo entender o hacer lo que le pidió que hiciera. Luego puede probar un comando diferente en la siguiente línea: &gt; 3 % 5 Error: unexpected input in &quot;3 % 5&quot; &gt; Una vez que domines la línea de comando, puedes hacer fácilmente cualquier cosa en R que harías con una calculadora. Por ejemplo, podrías hacer algo de aritmética básica: 2 * 3 ## 6 4 - 1 ## 3 6 / (4 - 1) ## 2 ¿Notaste algo diferente en este código? He dejado fuera los &gt; y [1]. Esto hará que el código sea más fácil de copiar y pegar si desea colocarlo en su propia consola. R trata el carácter del hashtag, #, de una manera especial; R no ejecutará nada que siga a un hashtag en una línea. Esto hace que los hashtags sean muy útiles para agregar comentarios y anotaciones a su código. Los humanos podrán leer los comentarios, pero su computadora los pasará por alto. El hashtag se conoce como símbolo de comentario en R. En el resto del libro, usaré hashtags para mostrar los resultados de las lineas de código R. Usaré un solo hashtag para agregar mis propios comentarios y un hashtag doble, ##, para mostrar los resultados del código. Evitaré mostrar &gt; y [1] a menos que quiera que los mires. Cancelar comandos Algunos comandos de R pueden tardar mucho tiempo en ejecutarse. Puede cancelar un comando una vez que ha comenzado presionando ctrl + c. Tenga en cuenta que R también puede tardar mucho tiempo en cancelar el comando. Ejercicio 2.1 (Magia con Numeros) Esa es la interfaz básica para ejecutar código R en RStudio. ¿Crees que lo tienes? Si es así, intente realizar estas sencillas tareas. Si ejecuta todo correctamente, debería terminar con el mismo número con el que comenzó: Elige cualquier número y súmale 2. Multiplica el resultado por 3. Resta 6 de la respuesta. Divide lo que obtienes por 3. A lo largo del libro, pondré ejercicios en partes, como el de arriba. Seguiré cada ejercicio con una respuesta modelo, como la siguiente. Solution. Puede comenzar con el número 10 y luego seguir los siguientes pasos: 10 + 2 ## 12 12 * 3 ## 36 36 - 6 ## 30 30 / 3 ## 10 2.2 Objetos Ahora que sabes cómo usar R, usémoslo para hacer un dado virtual. El operador : de hace un par de páginas le brinda una buena manera de crear un grupo de números del uno al seis. El operador : devuelve sus resultados como un vector, un conjunto unidimensional de números: 1:6 ## 1 2 3 4 5 6 ¡Eso es todo lo que hay sobre el aspecto de un dado virtual! Pero aún no has terminado. Ejecutar 1:6 generó un vector de números para que lo veas, pero no guardó ese vector en ninguna parte de la memoria de tu computadora. Lo que está viendo son básicamente las huellas de seis números que existieron brevemente y luego se fundieron de nuevo en la memoria RAM de tu computadora. Si desea volver a usar esos números, tendrá que pedirle a su computadora que los guarde en algún lugar. Puede hacerlo creando un objeto de R. R le permite guardar datos almacenándolos dentro de un objeto R. ¿Qué es un objeto? Solo un nombre que puede usar para recuperar datos almacenados. Por ejemplo, puede guardar datos en un objeto como a o b. Siempre que R encuentre el objeto, lo reemplazará con los datos guardados en su interior, así: a &lt;- 1 a ## 1 a + 2 ## 3 ¿Qué acaba de suceder? Para crear un objeto R, elija un nombre y luego use el símbolo menor que, &lt;, seguido de un signo menos, -, para guardar datos en él. Esta combinación parece una flecha, &lt;-. R creará un objeto, le dará su nombre y almacenará en él lo que siga a la flecha. Entonces a &lt;- 1 almacena 1 en un objeto llamado a. Cuando le preguntas a R qué hay en a, R te dice en la siguiente línea. También puede usar su objeto en nuevos comandos R. Dado que a almacenó previamente el valor de 1, ahora está agregando 1 a 2. Entonces, para otro ejemplo, el siguiente código crearía un objeto llamado dado que contiene los números del uno al seis. Para ver lo que está almacenado en un objeto, simplemente escriba el nombre del objeto por sí mismo: dado &lt;- 1:6 dado ## 1 2 3 4 5 6 Cuando crea un objeto, el objeto aparecerá en el panel de Environment de RStudio, como se muestra en la Figura 2.2. Este panel le mostrará todos los objetos que ha creado desde que abrió RStudio. Figure 2.2: El panel de Environment de RStudio realiza un seguimiento de los objetos R que crea. Puedes nombrar un objeto en R casi como quieras, pero hay algunas reglas. Primero, un nombre no puede comenzar con un número. Segundo, un nombre no puede usar algunos símbolos especiales, como ^, !, $, @, +, -, /, or *: Buenos nombres Nombres que causan error a 1trial b $ FOO ^mean my_var 2nd .day !bad Mayúsculas R distingue entre mayúsculas y minúsculas, por lo que nombre y Nombre se referirán a diferentes objetos: Nombre &lt;- 1 nombre &lt;- 0 Nombre + 1 ## 2 Finalmente, R sobrescribirá cualquier información anterior almacenada en un objeto sin pedirle permiso. Por lo tanto, es una buena idea no usar nombres que ya están en uso: my_number &lt;- 1 my_number ## 1 my_number &lt;- 999 my_number ## 999 Puedes ver qué nombres de objetos ya has usado con la función ls: ls() ## &quot;a&quot; &quot;dado&quot; &quot;my_number&quot; &quot;nombre&quot; &quot;Nombre&quot; También puede ver qué nombres ha utilizado examinando el panel de environment de RStudio. Ahora tiene un dado virtual que está almacenado en la memoria de su computadora. Puedes acceder a él cuando quieras escribiendo la palabra dado. Entonces, ¿qué puedes hacer con este dado? Bastante. R reemplazará un objeto con su contenido siempre que el nombre del objeto aparezca en un comando. Entonces, por ejemplo, puedes hacer todo tipo de operaciones matemáticas con el dado. Las matemáticas no son tan útiles para lanzar dados, pero la manipulación de conjuntos de números será su día a día como científico de datos. Así que echemos un vistazo a cómo hacer eso: dado - 1 ## 0 1 2 3 4 5 dado / 2 ## 0.5 1.0 1.5 2.0 2.5 3.0 dado * dado ## 1 4 9 16 25 36 Si eres un gran fanático del álgebra lineal (¿y quién no lo es?), puedes notar que R no siempre sigue las reglas de la multiplicación de matrices. En su lugar, R utiliza ejecución por elementos. Cuando manipulas un conjunto de números, R aplicará la misma operación a cada elemento del conjunto. Entonces, por ejemplo, cuando ejecuta dado - 1, R resta uno de cada elemento de dado. Cuando usa dos o más vectores en una operación, R alineará los vectores y realizará una secuencia de operaciones individuales. Por ejemplo, cuando ejecuta dado * dado, R alinea los dos vectores dado y luego multiplica el primer elemento del vector 1 por el primer elemento del vector 2. R luego multiplica el segundo elemento del vector 1 por el segundo elemento del vector 2, y así sucesivamente, hasta que se hayan multiplicado todos los elementos. El resultado será un nuevo vector de la misma longitud que los dos primeros, como se muestra en la Figura 2.3. Figure 2.3: Cuando R realiza una ejecución por elementos, hace coincidir los vectores y luego manipula cada par de elementos de forma independiente. Si le da a R dos vectores de longitudes desiguales, R repetirá el vector más corto hasta que sea tan largo como el vector más largo y luego hará los cálculos, como se muestra en la Figura 2.4. Este no es un cambio permanente: el vector más corto tendrá su tamaño original después de que R haga los cálculos. Si la longitud del vector largo no es divisible equitativamente por el vctor corto, R devolverá un mensaje de advertencia. Este comportamiento se conoce como reciclado de vectores y ayuda a R a realizar operaciones por elementos: 1:2 ## 1 2 1:4 ## 1 2 3 4 dado ## 1 2 3 4 5 6 dado + 1:2 ## 2 4 4 6 6 8 dado + 1:4 ## 2 4 6 8 6 8 Warning message: In dado + 1:4 : longer object length is not a multiple of shorter object length Figure 2.4: R repetirá un vector corto para realizar operaciones por elementos con dos vectores de longitud desigual. Las operaciones basadas en elementos son una característica muy útil en R porque manipulan grupos de valores de forma ordenada. Cuando comience a trabajar con conjuntos de datos, las operaciones por elementos garantizarán que los valores de una observación o caso solo se emparejen con valores de la misma observación o caso. Las operaciones basadas en elementos también facilitan la escritura de sus propios programas y funciones en R. Pero no creas que R ha renunciado a la multiplicación de matrices tradicional. Solo tienes que pedirlo cuando quieras. Puedes hacer multiplicaciones internas con el operador %*% y multiplicaciones externas con el operador %o%: dado %*% dado ## 91 dado %o% dado ## [,1] [,2] [,3] [,4] [,5] [,6] ## [1,] 1 2 3 4 5 6 ## [2,] 2 4 6 8 10 12 ## [3,] 3 6 9 12 15 18 ## [4,] 4 8 12 16 20 24 ## [5,] 5 10 15 20 25 30 ## [6,] 6 12 18 24 30 36 También puedes hacer cosas como transponer una matriz con t y tomar su determinante con det. No se preocupe si no está familiarizado con estas operaciones. Son fáciles de buscar y no los necesitará para este libro. Ahora que puede hacer operaciones matemáticas con su objeto dado, veamos cómo podría “tirarlo”. Lanzar el dado requerirá algo más sofisticado que la aritmética básica; deberá seleccionar aleatoriamente uno de los valores del dado. Y para eso, necesitarás una función. 2.3 Funciones R viene con muchas funciones que puede usar para realizar tareas sofisticadas como el muestreo aleatorio. Por ejemplo, puede redondear un número con la función round o calcular su factorial con la función factorial. Usar una función es bastante simple. Simplemente escriba el nombre de la función y luego los datos sobre los que desea que opere la función entre paréntesis:: round(3.1415) ## 3 factorial(3) ## 6 Los datos que pasa a la función se denominan argumento de la función. El argumento puede ser datos sin procesar, un objeto R o incluso los resultados de otra función R. En este último caso, R trabajará desde la función más interna hacia la más externa, como en la Figura 2.5. mean(1:6) ## 3.5 mean(dado) ## 3.5 round(mean(dado)) ## 4 Figure 2.5: Cuando vincula funciones, R las resolverá desde la operación más interna hasta la más externa. Aquí R primero busca el dado, luego calcula la media de uno a seis y luego redondea la media. Por suerte para nosotros, hay una función R que puede ayudar a “tirar” el dado. Puede simular una tirada del dado con la función sample de R. sample toma dos argumentos: un vector llamado x y un número llamado size. sample devolverá elementos de size del vector: sample(x = 1:4, size = 2) ## 3 2 Para tirar el dado y obtener un número de vuelta, establezca x en dado y muestree un elemento de él. Obtendrá un número nuevo (quizás diferente) cada vez que lo haga rodar: sample(x = dado, size = 1) ## 2 sample(x = dado, size = 1) ## 1 sample(x = dado, size = 1) ## 6 Muchas funciones de R toman múltiples argumentos que las ayudan a hacer su trabajo. Puede dar a una función tantos argumentos como desee siempre que separe cada argumento con una coma. Es posible que hayas notado que establecí dado y 1 iguales a los nombres de los argumentos en sample, x y size. Cada argumento en cada función de R tiene un nombre. Puede especificar qué datos deben asignarse a qué argumento estableciendo un nombre igual a data, como en el código anterior. Esto se vuelve importante a medida que comienza a pasar múltiples argumentos a la misma función; los nombres lo ayudan a evitar pasar los datos incorrectos al argumento incorrecto. Sin embargo, el uso de nombres es opcional. Notará que los usuarios de R no suelen usar el nombre del primer argumento en una función. Por lo tanto, es posible que vea el código anterior escrito como: sample(dado, size = 1) ## 2 A menudo, el nombre del primer argumento no es muy descriptivo y, de todos modos, suele ser obvio a qué se refiere el primer dato. Pero, ¿cómo saber qué nombres de argumento usar? Si intenta usar un nombre que una función no espera, es probable que obtenga un error: round(3.1415, corners = 2) ## Error in round(3.1415, corners = 2) : unused argument(s) (corners = 2) Si no está seguro de qué nombres usar con una función, puede buscar los argumentos de la función con args. Para hacer esto, coloque el nombre de la función entre paréntesis detrás de args. Por ejemplo, puede ver que la función round toma dos argumentos, uno llamado x y otro llamado digits: args(round) ## function (x, digits = 0) ## NULL ¿Notaste que args muestra que el argumento digits de round ya está establecido en 0? Con frecuencia, una función R tomará argumentos opcionales como digits. Estos argumentos se consideran opcionales porque vienen con un valor predeterminado. Puede pasar un nuevo valor a un argumento opcional si así lo desea, y R utilizará el valor predeterminado si no proporciona uno nuevo. Por ejemplo, “round” redondeará su número a 0 dígitos más allá del punto decimal de forma predeterminada. Para anular el valor predeterminado, proporcione su propio valor para digits: round(3.1415) ## 3 round(3.1415, digits = 2) ## 3.14 Debe escribir los nombres de cada argumento después del primero o dos cuando llame a una función con múltiples argumentos. ¿Por qué? Primero, esto lo ayudará a usted y a otros a comprender su código. Por lo general, es obvio a qué argumento se refiere su primera entrada (y, a veces, también la segunda entrada). Sin embargo, necesitaría una memoria grande para recordar los argumentos tercero y cuarto de cada función R. En segundo lugar, y más importante, escribir los nombres de los argumentos evita errores. Si no escribe los nombres de sus argumentos, R hará coincidir sus valores con los argumentos de su función por orden. Por ejemplo, en el siguiente código, el primer valor, dado, coincidirá con el primer argumento de sample, que se llama x. El siguiente valor, 1, coincidirá con el siguiente argumento, size: sample(dado, 1) ## 2 A medida que proporciona más argumentos, es más probable que su orden y el orden de R no coincidan. Como resultado, los valores pueden pasarse al argumento incorrecto. Los nombres de los argumentos evitan esto. R siempre hará coincidir un valor con el nombre de su argumento, sin importar dónde aparezca en el orden de los argumentos: sample(size = 1, x = dado) ## 2 2.3.1 Muestra con reemplazo Si configura size = 2, puede casi simular un par de dados. Antes de ejecutar ese código, piense por un minuto por qué ese podría ser el caso. sample devolverá dos números, uno para cada dado: sample(dado, size = 2) ## 3 4 Dije que esto “casi” funciona porque este método hace algo divertido. Si lo usa muchas veces, notará que el segundo dado nunca tiene el mismo valor que el primero, lo que significa que nunca obtendrá algo como un par de tres o un par de unos. ¿Qué esta pasando? Por defecto, sample construye una muestra sin reemplazo. Para ver lo que esto significa, imagina que sample coloca todos los valores de dado en un frasco o urna. Luego imagine que sample alcanza el frasco y extrae valores uno por uno para construir su muestra. Una vez que se ha extraído un valor del frasco, sample lo deja a un lado. El valor no vuelve al frasco, por lo que no se puede volver a extraer. Entonces, si sample selecciona un seis en su primer sorteo, no podrá seleccionar un seis en el segundo sorteo; seis ya no está en el frasco para ser seleccionado. Aunque sample crea su muestra electrónicamente, sigue este comportamiento aparentemente físico. Un efecto secundario de este comportamiento es que cada sorteo depende de los sorteos anteriores. Sin embargo, en el mundo real, cuando lanzas un par de dados, cada dado es independiente del otro. Si el primer dado sale seis, no impide que el segundo dado salga seis. De hecho, no influye en el segundo dado de ninguna manera. Puede recrear este comportamiento en sample agregando el argumento replace = TRUE: sample(dado, size = 2, replace = TRUE) ## 5 5 El argumento replace = TRUE hace que sample muestree con reemplazo. Nuestro ejemplo de frasco proporciona una buena manera de comprender la diferencia entre el muestreo con reemplazo y sin reemplazo. Cuando sample usa reemplazo, extrae un valor del frasco y registra el valor. Luego vuelve a poner el valor en el frasco. En otras palabras, sample reemplaza cada valor después de cada sorteo. Como resultado, sample puede seleccionar el mismo valor en el segundo sorteo. Cada valor tiene la posibilidad de ser seleccionado cada vez. Es como si cada sorteo fuera el primer sorteo. El muestreo con reemplazo es una manera fácil de crear muestras aleatorias independientes. Cada valor en su muestra será una muestra de tamaño uno que es independiente de los otros valores. Esta es la forma correcta de simular un par de dados. sample(dado, size = 2, replace = TRUE) ## 2 4 Felicítate a ti mismo; ¡Acabas de ejecutar tu primera simulación en R! Ahora tiene un método para simular el resultado de lanzar un par de dados. Si desea sumar los dados, puede ingresar su resultado directamente en la función sum: dados &lt;- sample(dado, size = 2, replace = TRUE) dados ## 2 4 sum(dados) ## 6 ¿Qué pasaría si llamas dados varias veces? ¿Generaría R un nuevo par de valores de dados cada vez? Probemos: dados ## 2 4 dados ## 2 4 dados ## 2 4 No. Cada vez que llame a dados, R le mostrará el resultado de esa vez que llamó a sample y guardó la salida en dados. R no volverá a ejecutar sample(dado, 2, replace = TRUE) para crear una nueva tirada de dados. Esto es un alivio en cierto modo. Una vez que guarda un conjunto de resultados en un objeto de R, esos resultados no cambian. La programación sería bastante difícil si los valores de sus objetos cambiaran cada vez que los llama. Sin embargo, sería conveniente tener un objeto que pueda volver a tirar los dados cada vez que lo llames. Puede hacer tal objeto escribiendo su propia función de R. 2.4 Escribiendo Sus Propias Funciones Para recapitular, ya tiene un código de R en funcionamiento que simula lanzar un par de dados: dado &lt;- 1:6 dados &lt;- sample(dado, size = 2, replace = TRUE) sum(dados) Puede volver a escribir este código en la consola en cualquier momento que desee volver a tirar los dados. Sin embargo, esta es una forma incómoda de trabajar con el código. Sería más fácil usar su código si lo envolviera en su propia función, que es exactamente lo que haremos ahora. Vamos a escribir una función llamada tirar que puedes usar para lanzar tus dados virtuales. Cuando hayas terminado, la función funcionará así: cada vez que llames a tirar(), R devolverá la suma de tirar dos dados: tirar() ## 8 tirar() ## 3 tirar() ## 7 Las funciones pueden parecer misteriosas o sofisticadas, pero son solo otro tipo de objeto de R. En lugar de contener datos, contienen código. Este código se almacena en un formato especial que facilita su reutilización en situaciones nuevas. Puede escribir sus propias funciones recreando este formato. 2.4.1 El Constructor de Funciones Cada función en R tiene tres partes básicas: un nombre, un cuerpo de código y un conjunto de argumentos. Para crear su propia función, debe replicar estas partes y almacenarlas en un objeto de R, esto lo puede hacer con la función function. Para hacer esto, llama a function() y sigue con un par de llaves, {}: mi_funcion &lt;- function() {} function construirá una función a partir de cualquier código R que coloque entre las llaves. Por ejemplo, puede convertir su código de dados en una función llamando: tirar &lt;- function() { dado &lt;- 1:6 dados &lt;- sample(dado, size = 2, replace = TRUE) sum(dados) } Observe que he aplicado sangría a cada línea de código entre las llaves. Esto hace que el código sea más fácil de leer para usted y para mí, pero no tiene impacto en cómo se ejecuta el código. R ignora los espacios y los saltos de línea y ejecuta una expresión completa a la vez. Simplemente presione la tecla Enter entre cada línea después de la primera llave, {. R esperará a que escribas la última llave, }, antes de responder. No olvide guardar la salida de function en un objeto de R. Este objeto se convertirá en su nueva función. Para usarlo, escriba el nombre del objeto seguido de un paréntesis de apertura y cierre: tirar() ## 9 Puede pensar en los paréntesis como el “disparador” que hace que R ejecute la función. Si escribe el nombre de una función sin los paréntesis, R le mostrará el código que está almacenado dentro de la función. Si escribe el nombre con los paréntesis, R ejecutará ese código: tirar ## function() { ## dado &lt;- 1:6 ## dados &lt;- sample(dado, size = 2, replace = TRUE) ## sum(dados) ## } tirar() ## 6 El código que coloca dentro de su función se conoce como el cuerpo de la función. Cuando ejecuta una función en R, R ejecutará todo el código en el cuerpo y luego devolverá el resultado de la última línea de código. Si la última línea de código no devuelve un valor, tampoco lo hará su función, por lo que debe asegurarse de que su última línea de código devuelva un valor. Una forma de verificar esto es pensar en lo que sucedería si ejecutara el cuerpo del código línea por línea en la consola. ¿Mostraría R un resultado después de la última línea, o no? Aquí hay un código que mostraría un resultado: dados 1 + 1 sqrt(2) Y aquí hay un código que no: dados &lt;- sample(dado, size = 2, replace = TRUE) dos &lt;- 1 + 1 a &lt;- sqrt(2) ¿Notas el patrón? Estas líneas de código no devuelven un valor a la línea de comando; guardan un valor a un objeto. 2.5 Argumentos ¿Qué pasa si eliminamos una línea de código de nuestra función y cambiamos el nombre dado a bones, así? tirar2 &lt;- function() { dados &lt;- sample(bones, size = 2, replace = TRUE) sum(dados) } Ahora obtendré un error cuando ejecute la función. La función necesita el objeto bones para hacer su trabajo, pero no se puede encontrar ningún objeto llamado bones: tirar2() ## Error in sample(bones, size = 2, replace = TRUE) : ## object &#39;bones&#39; not found Puedes proporcionar bones cuando llamas a tirar2 si conviertes a bones en un argumento de la función. Para hacer esto, pon el nombre bones entre los paréntesis que siguen a function cuando definas tirar2: tirar2 &lt;- function(bones) { dados &lt;- sample(bones, size = 2, replace = TRUE) sum(dados) } Ahora tirar2 funcionará siempre y cuando proporciones bones cuando llames a la función. Puede aprovechar esto para lanzar diferentes tipos de dados cada vez que llamas tirar2. ¡Calabozos y Dragones, aquí vamos! Recuerda, estamos lanzando pares de dados: tirar2(bones = 1:4) ## 3 tirar2(bones = 1:6) ## 10 tirar2(1:20) ## 31 Tenga en cuenta que tirar2 seguirá dando un error si no proporciona un valor para el argumento bones cuando llame a tirar2: tirar2() ## Error in sample(bones, size = 2, replace = TRUE) : ## argument &quot;bones&quot; is missing, with no default Puede evitar este error dando al argumento bones un valor predeterminado. Para hacer esto, establece bones igual a un valor cuando definas tirar2: tirar2 &lt;- function(bones = 1:6) { dados &lt;- sample(bones, size = 2, replace = TRUE) sum(dados) } Ahora puede proporcionar un nuevo valor para bones si lo desea, y tirar2 usará el valor predeterminado si no lo desea: tirar2() ## 9 Puede dar a sus funciones tantos argumentos como desee. Simplemente enumere sus nombres, separados por comas, entre los paréntesis que siguen a function.Cuando se ejecuta la función, R reemplazará cada nombre de argumento en el cuerpo de la función con el valor que el usuario proporciona para el argumento. Si el usuario no proporciona un valor, R reemplazará el nombre del argumento con el valor predeterminado del argumento (si definió uno). Para resumir, function te ayuda a construir tus propias funciones de R. Usted crea un cuerpo de código para que su función se ejecute escribiendo código entre las llaves que siguen a function. Usted crea argumentos para que su función los use proporcionando sus nombres entre los paréntesis que siguen a function. Finalmente, le da un nombre a su función guardando su salida en un objeto de R, como se muestra en la Figura 2.6. Una vez que haya creado su función, R la tratará como cualquier otra función en R. Piense en lo útil que es. ¿Alguna vez ha intentado crear una nueva opción de Excel y agregarla a la barra de menú de Microsoft? ¿O una nueva animación de diapositivas y agregarla a las opciones de Powerpoint? Cuando trabajas con un lenguaje de programación, puedes hacer este tipo de cosas. A medida que aprenda a programar en R, podrá crear herramientas nuevas, personalizadas y reproducibles para usted cuando lo desee. Proyecto 3: Máquina Tragamonedas te enseñará mucho más sobre escribir funciones en R. Figure 2.6: Cada función en R tiene las mismas partes y puede usar function para crear estas partes. Asigne el resultado a un nombre, para que pueda llamar a la función más tarde. 2.6 Scripts ¿Qué pasa si quieres editar tirar2 de nuevo? Podría regresar y volver a escribir cada línea de código en tirar2, pero sería mucho más fácil si tuviera un borrador del código para empezar. Puede crear un borrador de su código a medida que avanza utilizando un script de R. Un script de R es solo un archivo de texto sin formato en el que guarda el código R. Puede abrir un script de R en RStudio yendo a File&gt; New File&gt; R script en la barra de menú. RStudio luego abrirá un script nuevo sobre el panel de su consola, como se muestra en la Figura 2.7. Le recomiendo encarecidamente que escriba y edite todo su código de R en un script antes de ejecutarlo en la consola. ¿Por qué? Este hábito crea un registro reproducible de su trabajo. Cuando termine el día, puede guardar su secuencia de comandos y luego usarla para volver a ejecutar todo el análisis al día siguiente. Los scripts también son muy útiles para editar y corregir su código, y hacen una buena copia de su trabajo para compartir con otros. Para guardar un script, haga clic en el panel de scripts y luego vaya a File &gt; Save as en la barra de menú. Figure 2.7: Cuando abre un R Script (File &gt; New File &gt; R Script in the menu bar), RStudio crea un cuarto panel encima de la consola donde puede escribir y editar su código. RStudio viene con muchas funciones integradas que facilitan el trabajo con scripts. Primero, puede ejecutar automáticamente una línea de código en un script haciendo clic en el botón Run, como se muestra en la Figura 2.8. R ejecutará cualquier línea de código en la que esté el cursor. Si tiene una sección completa resaltada, R ejecutará el código resaltado. Como alternativa, puede ejecutar todo el script haciendo clic en el botón Source. ¿No te gusta hacer clic en los botones? Puede usar Control + Enter como acceso directo para el botón Ejecutar. En Mac, eso sería Comando + Enter. Figure 2.8: Puede ejecutar una parte resaltada del código en su secuencia de comandos si hace clic en el botón Run en la parte superior del panel de Scripts. Puede ejecutar todo el script haciendo clic en el botón Source. Si no está convencido acerca de los scripts, pronto lo estará. Se convierte en una molestia escribir código de varias líneas en la línea de comando de una sola línea de la consola. Evitemos ese dolor de cabeza y abramos su primer script ahora antes de pasar al siguiente capítulo. Extraer función RStudio viene con una herramienta que puede ayudarlo a crear funciones. Para usarlo, resalte las líneas de código en su secuencia de comandos R que desea convertir en una función. Luego haga clic en Code &gt; Extract Function en la barra de menú. RStudio le pedirá un nombre de función para usar y luego envolverá su código en una llamada de function. Escaneará el código en busca de variables indefinidas y las usará como argumentos. Es posible que desee volver a comprobar el trabajo de RStudio. Asume que su código es correcto, por lo que si hace algo sorprendente, es posible que tenga un problema en su código. 2.7 Resumen Ya has cubierto mucho terreno. Ahora tiene un dado virtual almacenado en la memoria de su computadora, así como su propia función de R que lanza un par de dados. También ha comenzado a hablar el lenguaje R. Como has visto, R es un lenguaje que puedes usar para hablar con tu computadora. Escribes comandos en R y los ejecutas en la línea de comandos para que tu computadora los lea. Su computadora a veces responderá–por ejemplo, cuando cometa un error–pero generalmente solo hace lo que le pide y luego muestra el resultado. Los dos componentes más importantes del lenguaje R son los objetos, que almacenan datos, y las funciones, que manipulan datos. R también usa una gran cantidad de operadores como +, -, *, / y &lt;- para realizar tareas básicas. Como científico de datos, usará objetos de R para almacenar datos en la memoria de su computadora y usará funciones para automatizar tareas y realizar cálculos complicados. Examinaremos los objetos con más profundidad más adelante en Proyecto 2: Baraja de Cartas y profundizaremos en las funciones en Proyecto 3: Máquina Tragamonedas. El vocabulario que ha desarrollado aquí hará que cada uno de esos proyectos sea más fácil de entender. Sin embargo, aún no hemos terminado con tus dados. En Paquetes y páginas de ayuda, , ejecutará algunas simulaciones con sus dados y construirá sus primeros gráficos en R. También verá dos de los componentes más útiles del lenguaje R: Paquetes de R, que son colecciones de funciones escritas por la talentosa comunidad de desarrolladores de R, y documentación de R, que es una colección de páginas de ayuda integradas en R que explica cada función y conjunto de datos en el lenguaje. "],["packages.html", "3 Paquetes y páginas de ayuda 3.1 Paquetes 3.2 Obteniendo Ayuda con las Páginas de Ayuda 3.3 Resumen 3.4 Resumen del Proyecto 1", " 3 Paquetes y páginas de ayuda Ahora tiene una función que simula lanzar un par de dados. Hagamos las cosas un poco más interesantes ponderando los dados a tu favor. La casa siempre gana, ¿verdad? Hagamos que los dados arrojen números altos un poco más a menudo que los números bajos. Antes de ponderar los dados, debemos asegurarnos de que sean justos para empezar. Dos herramientas te ayudarán a hacer esto: repetición y visualización. Por coincidencia, estas herramientas también son dos de los superpoderes más útiles en el mundo de la ciencia de datos. Repetiremos nuestras tiradas de dados con una función llamada replicate y visualizaremos nuestras tiradas con una función llamada qplot. qplot no viene con R cuando lo descargas; qplot viene en un paquete de R independiente. Muchas de las herramientas de R más útiles vienen en paquetes de R, así que tomemos un momento para ver qué son los paquetes de R y cómo puede usarlos. 3.1 Paquetes No es la única persona que escribe sus propias funciones con R. Muchos profesores, programadores y estadísticos usan R para diseñar herramientas que pueden ayudar a las personas a analizar datos. Luego hacen que estas herramientas sean gratuitas para que cualquiera las use. Para usar estas herramientas, solo tienes que descargarlas. Vienen como colecciones preensambladas de funciones y objetos llamados paquetes. Apéndice 2: Paquetes de R contiene instrucciones detalladas para descargar y actualizar paquetes R, pero aquí veremos los conceptos básicos. Vamos a usar la función qplot para hacer algunos gráficos rápidos. qplot viene en el paquete ggplot2, un paquete popular para hacer gráficos. Antes de que pueda usar qplot, o cualquier otra cosa en el paquete ggplot2, debe descargarlo e instalarlo. 3.1.1 install.packages Cada paquete R está alojado en http://cran.r-project.org, el mismo sitio web que aloja R. Sin embargo, no necesita visitar el sitio web para descargar un paquete R; puede descargar paquetes directamente desde la línea de comandos de R. Así es cómo: Abre RStudio. Asegúrate de estar conectado a Internet. Ejecute install.packages(\"ggplot2\") en la línea de comando. Eso es. R hará que su computadora visite el sitio web, descargue ggplot2 e instale el paquete en su disco duro justo donde R quiere encontrarlo. Ahora tiene el paquete ggplot2. Si desea instalar otro paquete, reemplace ggplot2 con el nombre de su paquete en el código. 3.1.2 library La instalación de un paquete no pone sus funciones al alcance de su mano todavía: simplemente las coloca en su disco duro. Para usar un paquete de R, luego debe cargarlo en su sesión de R con el comando library(\"ggplot2\"). Si desea cargar un paquete diferente, reemplace ggplot2 con el nombre de su paquete en el código. Para ver lo que esto hace, intente un experimento. Primero, pide a R que te muestre la función qplot. R no podrá encontrar qplot porque qplot vive en el paquete ggplot2, que no ha cargado: qplot ## Error: object &#39;qplot&#39; not found Ahora cargue el paquete ggplot2: library(&quot;ggplot2&quot;) Si instaló el paquete con install.packages según las instrucciones, todo debería ir bien. No se preocupe si no ve ningún resultado o mensaje. No tener noticias es una buena noticia a la hora de cargar un paquete. No se preocupe si ve un mensaje tampoco; ggplot2 a veces muestra mensajes de inicio útiles. Mientras no vea nada que diga “Error”, lo está haciendo bien. Ahora, si pide ver qplot, R le mostrará bastante código (qplot es una función larga): qplot ## (quite a bit of code) Apéndice 2: Paquetes de R contiene muchos más detalles sobre la adquisición y el uso de paquetes. Le recomiendo que lo lea si no está familiarizado con el sistema de paquetes de R. Lo más importante que debe recordar es que solo necesita instalar un paquete una vez, pero debe cargarlo con library cada vez que desee usarlo en una nueva sesión de R. R descargará todos sus paquetes cada vez que cierre RStudio. Ahora que ha cargado qplot, vamos a probarlo. qplot hace “gráficos rápidos”. Si le das a qplot dos vectores de igual longitud, qplot dibujará un diagrama de dispersión por ti. qplot usará el primer vector como un conjunto de valores x y el segundo vector como un conjunto de valores y. Busque el gráfico que aparecerá en la pestaña Gráficos del panel inferior derecho de la ventana de RStudio. El siguiente código creará el gráfico que aparece en la Figura 3.1. Hasta ahora, hemos estado creando secuencias de números con el operador :; pero también puedes crear vectores de números con la función c. Proporcione a c todos los números que desea que aparezcan en el vector, separados por una coma. c significa concatenar, pero puedes pensar en ello como “recolectar” o “combinar”: x &lt;- c(-1, -0.8, -0.6, -0.4, -0.2, 0, 0.2, 0.4, 0.6, 0.8, 1) x ## -1.0 -0.8 -0.6 -0.4 -0.2 0.0 0.2 0.4 0.6 0.8 1.0 y &lt;- x^3 y ## -1.000 -0.512 -0.216 -0.064 -0.008 0.000 0.008 ## 0.064 0.216 0.512 1.000 qplot(x, y) Figure 3.1: qplot hace un diagrama de dispersión cuando le das dos vectores. No necesitas nombrar tus vectores x e y. Solo hice eso para aclarar el ejemplo. Como puede ver en la figura 3.1, un diagrama de dispersión es un conjunto de puntos, cada uno representado de acuerdo con sus valores x e y. Juntos, los vectores x e y describen un conjunto de 10 puntos. ¿Cómo hizo coincidir R los valores en x e y para hacer estos puntos? Con ejecución por elementos, como vimos en la Figura 2.3. Los diagramas de dispersión son útiles para visualizar la relación entre dos variables. Sin embargo, vamos a utilizar un tipo diferente de gráfico, un histograma. Un histograma visualiza la distribución de una sola variable; muestra cuántos puntos de datos aparecen en cada valor de x. Echemos un vistazo a un histograma para ver si esto tiene sentido. qplot hará un histograma cada vez que le des solo un vector para graficar. El siguiente código crea el gráfico de la izquierda en la Figura 3.2 (nos preocuparemos del gráfico de la derecha en un segundo). Para asegurarse de que nuestros gráficos tengan el mismo aspecto, utilice el argumento extra binwidth = 1: x &lt;- c(1, 2, 2, 2, 3, 3) qplot(x, binwidth = 1) Figure 3.2: qplot hace un histograma cuando le das un solo vector. Este gráfico muestra que nuestro vector contiene un valor en el intervalo [1, 2) colocando una barra de altura 1 sobre ese intervalo. De manera similar, la gráfica muestra que el vector contiene tres valores en el intervalo [2, 3) colocando una barra de altura 3 en ese intervalo. Muestra que el vector contiene dos valores en el intervalo [3, 4) colocando una barra de altura 2 en ese intervalo. En estos intervalos, el corchete, [, significa que el primer número está incluido en el intervalo. El paréntesis, ), significa que el último número no está incluido. Probemos con otro histograma. Este código crea el gráfico de la derecha en la Figura 3.2. Observe que hay cinco puntos con un valor de 1 en x2. El histograma muestra esto trazando una barra de altura 5 sobre el intervalo x2 = [1, 2): x2 &lt;- c(1, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 4) qplot(x2, binwidth = 1) Ejercicio 3.1 (Visualizar un Histograma) Sea x3 el siguiente vector: x3 &lt;- c(0, 1, 1, 2, 2, 2, 3, 3, 4) Imagina cómo se vería un histograma de x3. Suponga que el histograma tiene un ancho de intervalo de 1. ¿Cuántas barras tendrá el histograma? ¿Dónde aparecerán? ¿Qué altura tendrá cada uno? Cuando haya terminado, trace un histograma de x3 con binwidth = 1, y vea si tiene razón. Solution. Puedes hacer un histograma de x3 con qplot(x3, binwidth = 1). El histograma se verá como una pirámide simétrica. La barra del medio tendrá una altura de 3 y aparecerá encima de [2, 3), pero asegúrese de probarlo y verlo por sí mismo. Puede usar un histograma para mostrar visualmente qué tan comunes son los diferentes valores de x. Los números cubiertos por una barra alta son más comunes que los números cubiertos por una barra corta. ¿Cómo puedes usar un histograma para verificar la precisión de tus dados? Bueno, si tiras los dados muchas veces y haces un seguimiento de los resultados, esperarás que algunos números ocurran más que otros. Esto se debe a que hay más formas de obtener algunos números sumando dos dados que de obtener otros números, como se muestra en la Figura 3.3. Si tira los dados muchas veces y grafica los resultados con qplot, el histograma le mostrará con qué frecuencia apareció cada suma. Las sumas que ocurrieron con mayor frecuencia tendrán las barras más altas. El histograma debería parecerse al patrón de la Figura 3.3 si los dados tienen un peso justo. Aquí es donde entra replicate. replicate proporciona una manera fácil de repetir un comando de R muchas veces. Para usarlo, primero dale a replicate el número de veces que deseas repetir un comando de R, y luego dale el comando que deseas repetir. replicate ejecutará el comando varias veces y almacenará los resultados como un vector: replicate(3, 1 + 1) ## 2 2 2 replicate(10, tirar()) ## 3 7 5 3 6 2 3 8 11 7 Figure 3.3: Cada combinación individual de dados debe ocurrir con la misma frecuencia. Como resultado, algunas sumas ocurrirán con más frecuencia que otras. Con dados justos, cada suma debe aparecer en proporción al número de combinaciones que la forman. Un histograma de sus las primeras 10 tiradas de los dados probablemente no se verá como el patrón que se muestra en la Figura 3.3. ¿Por qué no? Hay demasiada aleatoriedad involucrada. Recuerda que usamos dados en la vida real porque son generadores efectivos de números aleatorios. Los patrones de frecuencias de largo plazo solo aparecerán en el largo plazo. Así que simulemos 10.000 lanzamientos de dados y representemos los resultados. No te preocupes; qplot y replicate pueden manejarlo. Los resultados aparecen en la Figura 3.4: lanzamientos &lt;- replicate(10000, tirar()) qplot(lanzamientos, binwidth = 1) Los resultados sugieren que los dados son justos. A la larga, cada número aparece en proporción al número de combinaciones que lo generan. Ahora, ¿cómo puedes sesgar estos resultados? El patrón anterior ocurre porque cada combinación subyacente de dados (por ejemplo, (3,4)) ocurre con la misma frecuencia. Si pudieras aumentar la probabilidad de que salga un 6 en cualquiera de los dados, entonces cualquier combinación con un seis ocurrirá con más frecuencia que cualquier combinación sin un seis. La combinación (6, 6) ocurriría más frequente que todas las demás. Esto no hará que los dados sumen 12 con más frecuencia que siete, pero sesgará los resultados hacia los números más altos Figure 3.4: El comportamiento de nuestros dados sugiere que son justos. Siete ocurre con más frecuencia que cualquier otro número, y las frecuencias disminuyen en proporción al número de combinaciones de dados que crean cada número. Para decirlo de otra manera, la probabilidad de sacar cualquier número en un dado justo es 1/6. Me gustaría que cambiara la probabilidad a 1/8 para cada número por debajo de seis y luego aumentara la probabilidad de sacar un seis a 3/8: Número Probabilidad justa Probabilidad sesgada 1 1/6 1/8 2 1/6 1/8 3 1/6 1/8 4 1/6 1/8 5 1/6 1/8 6 1/6 3/8 Puede cambiar las probabilidades agregando un nuevo argumento a la función sample. No te voy a decir cuál es el argumento; en su lugar, le indicaré la página de ayuda para la función sample. ¿Que es eso? ¿Las funciones de R vienen con páginas de ayuda? Sí, así que aprendamos a leer una. 3.2 Obteniendo Ayuda con las Páginas de Ayuda Hay más de 1000 funciones en el núcleo de R, y se crean nuevas funciones todo el tiempo. ¡Esto puede ser mucho material para memorizar y aprender! Afortunadamente, cada función de R viene con su propia página de ayuda, a la que puede acceder escribiendo el nombre de la función después de un signo de interrogación. Por ejemplo, cada uno de estos comandos abrirá una página de ayuda. Busque las páginas que aparecerán en la pestaña Ayuda del panel inferior derecho de RStudio: ?sqrt ?log10 ?sample Las páginas de ayuda contienen información útil sobre lo que hace cada función. Estas páginas de ayuda también sirven como documentación del código, por lo que leerlas puede resultar agridulce. A menudo parecen estar escritas para personas que ya entienden la función y no necesitan ayuda. No deje que esto le moleste: puede obtener mucho de una página de ayuda si la escanea buscando información que tenga sentido y pasa por alto el resto. Esta técnica inevitablemente lo llevará a la parte más útil de cada página de ayuda: la parte inferior. Aquí, casi todas las páginas de ayuda incluyen algún código de ejemplo que pone la función en acción. Ejecutar este código es una excelente manera de aprender con el ejemplo. Si una función viene en un paquete R, R no podrá encontrar su página de ayuda a menos que se cargue el paquete. 3.2.1 Partes de una Página de Ayuda Cada página de ayuda está dividida en secciones. Las secciones que aparecen pueden variar de una página de ayuda a otra, pero normalmente puede esperar encontrar estos temas útiles Descripción - Un breve resumen de lo que hace la función. Uso - Un ejemplo de cómo escribiría la función. Cada argumento de la función aparecerá en el orden en que R espera que lo proporciones (si no usas nombres de argumentos). Argumentos - Una lista de cada argumento que toma la función, qué tipo de información R espera que proporcione para el argumento y qué hará la función con la información. Detalles - Una descripción más detallada de la función y cómo opera. La sección de detalles también le da al autor de la función la oportunidad de alertarlo sobre cualquier cosa que desee saber al usar la función. Valor - Una descripción de lo que devuelve la función cuando la ejecuta. Vea También - Una breve lista de funciones de R relacionadas. Ejemplos - Código de ejemplo que usa la función y se garantiza que funcionará. La sección de ejemplos de una página de ayuda generalmente demuestra un par de formas diferentes de usar una función. Esto ayuda a darle una idea de lo que la función es capaz de hacer. Si desea buscar una función en la página de ayuda pero ha olvidado el nombre de la función, puede buscar por palabra clave. Para ello, escriba dos signos de interrogación seguidos de una palabra clave en la línea de comandos de R. R mostrará una lista de enlaces a páginas de ayuda relacionadas con la palabra clave. Puede pensar en esto como la página de ayuda para la página de ayuda: ??log Demos un paseo por la página de ayuda de sample. Recuerde: estamos buscando cualquier cosa que pueda ayudarlo a cambiar las probabilidades involucradas en el proceso de muestreo. No voy a reproducir toda la página de ayuda aquí (solo las partes más jugosas), por lo que debe seguirla en su computadora. Primero, abra la página de ayuda. Aparecerá en el mismo panel en RStudio que sus gráficos (pero en la pestaña Help, no en la pestaña Plots): ?sample Como verá a continuación y en su panel Help de la ventana inferior derecha de RStudio las páginas de ayuda de R solo se encuntran en idioma inglés. Por lo que las secciones, de la página de ayuda de la función sample, que se exponen a continuación se mostrarán en inglés. Si no posee un nivel de inglés que le permita leer y entender las páginas de ayuda de R, el traductor le recomienda traducir las mismas usando algún traductor de documentos online, aunque estos pueden ser muy textuales en ocasiones. ¿Que ves? Comenzando desde arriba: Random Samples and Permutations Description sample takes a sample of the specified size from the elements of x using either with or without replacement. Hasta ahora todo bien. Ya sabías todo eso. La siguiente sección, Uso, tiene una posible pista. Menciona un argumento llamado prob: Usage sample(x, size, replace = FALSE, prob = NULL) Si se desplaza hacia abajo hasta la sección de argumentos, la descripción de +prob+ suena muy prometedora: A vector of probability weights for obtaining the elements of the vector being sampled. La sección Detalles confirma nuestras sospechas. En este caso, también te indica cómo proceder: The optional prob argument can be used to give a vector of weights for obtaining the elements of the vector being sampled. They need not sum to one, but they should be nonnegative and not all zero. Aunque la página de ayuda no lo dice aquí, estos pesos se emparejaran de manera individual con los elementos que se muestrean.El primer peso describirá el primer elemento, el segundo peso el segundo elemento, y así sucesivamente. Esta es una práctica común en R. Leer: If replace is true, Walker&#39;s alias method (Ripley, 1987) is used... Vale, parece que es hora de empezar a hojear. Deberíamos tener suficiente información ahora para descubrir cómo manipular nuestros dados. Ejercicio 3.2 (Lanzar un par de Dados) Vuelva a escribir la función tirar a continuación para lanzar un par de dados ponderados: tirar &lt;- function() { dado &lt;- 1:6 dados &lt;- sample(dado, size = 2, replace = TRUE) sum(dados) } Deberá agregar un argumento prob a la función sample dentro de tirar. Este argumento debería decirle a sample que muestree los números del uno al cinco con una probabilidad de 1/8 y el número 6 con una probabilidad de 3/8. Cuando haya terminado, siga leyendo para ver un ejemplo de respuesta. Solution. Para ponderar sus dados, debe agregar un argumento prob con un vector de pesos a sample, como este: tirar &lt;- function() { dado &lt;- 1:6 dados &lt;- sample(dado, size = 2, replace = TRUE, prob = c(1/8, 1/8, 1/8, 1/8, 1/8, 3/8)) sum(dados) } Esto hará que tirar elija del 1 al 5 con una probabilidad de 1/8 y 6 con una probabilidad de 3/8. Sobrescriba su versión anterior de tirar con la nueva función (ejecutando el fragmento de código anterior en su línea de comando). Luego visualiza el nuevo comportamiento a largo plazo de tus dados. He puesto los resultados en la Figura 3.5 junto a nuestros resultados originales: lanzamientos &lt;- replicate(10000, tirar()) qplot(lanzamientos, binwidth = 1) Esto confirma que efectivamente hemos ponderado los dados. Los números altos ocurren con mucha más frecuencia que los números bajos. Lo notable es que este comportamiento solo será evidente cuando examine las frecuencias a largo plazo. En cualquier tirada individual, los dados parecerán comportarse aleatoriamente. Esta es una gran noticia si juegas a Settlers of Catan (solo dile a tus amigos que perdiste los dados), pero debería ser perturbador si analizas los datos, porque significa que el sesgo puede ocurrir fácilmente sin que nadie lo note a corto plazo. Figure 3.5: Los dados ahora están claramente sesgados hacia números altos, ya que las sumas altas ocurren con mucha más frecuencia que las sumas bajas. 3.2.2 Obteniendo Más Ayuda R también viene con una comunidad súper activa de usuarios a la que puede acudir para obtener ayuda en la lista de correo de R-help. Puede enviar un correo electrónico a la lista con preguntas, pero existe una gran posibilidad de que su pregunta ya haya sido respondida. Descúbrelo buscando en los archivos. Incluso mejor que la lista R-help es Stack Overflow, un sitio web que permite a los programadores responder preguntas y a los usuarios clasificar las respuestas según su utilidad. Personalmente, creo que el formato Stack Overflow es más fácil de usar que la lista de correo electrónico R-help (y los encuestados son más amigables con los humanos). Puede enviar su propia pregunta o buscar a través de las preguntas respondidas anteriormente de Stack Overflow relacionadas con R. Hay más de 30,000. Lo mejor de todo es Posit Community, un lugar amigable e inclusivo para compartir preguntas relacionadas con R. Posit Community es un foro muy activo centrado en R. No se sorprenda si hace una pregunta sobre un paquete de R y el autor del paquete aparece para dar respuesta. Para toda la lista de ayuda de R, Stack Overflow y Posit Community, es más probable que obtenga una respuesta útil si proporciona un ejemplo reproducible con su pregunta. Esto significa pegar un pequeño fragmento de código que los usuarios pueden ejecutar para llegar al error o pregunta que tiene en mente. 3.3 Resumen Los paquetes y las páginas de ayuda de R pueden convertirlo en un programador más productivo. Viste en Lo Más Básico que R te da el poder de escribir tus propias funciones que hacen cosas específicas, pero a menudo la función que deseas escribir ya existirá en un paquete de R. Profesores, programadores y científicos han desarrollado más de 13.000 paquetes para su uso, lo que puede ahorrarle un valioso tiempo de programación. Para usar un paquete, debe instalarlo en su computadora una vez con install.packages y luego cargarlo en cada nueva sesión de R con library. Las páginas de ayuda de R lo ayudarán a dominar las funciones que aparecen en R y sus paquetes. Cada función y conjunto de datos en R tiene su propia página de ayuda. Aunque las páginas de ayuda a menudo contienen contenido avanzado, también contienen pistas y ejemplos valiosos que pueden ayudarlo a aprender a usar una función. Ya ha visto suficiente de R para aprender haciendo, que es la mejor manera de aprender R. Puede crear sus propios comandos de R, ejecutarlos y obtener ayuda cuando necesite comprender algo que no he explicado. Lo animo a que experimente con sus propias ideas en R mientras lee los próximos dos proyectos. 3.4 Resumen del Proyecto 1 Has hecho más en este proyecto que permitir el fraude y las apuestas; también aprendió a hablarle a su computadora en el idioma de R. R es un idioma como inglés, español o alemán, excepto que R lo ayuda a hablar con computadoras, no con humanos. Has conocido los sustantivos del lenguaje R, objetos. Y espero que hayas adivinado que las funciones son los verbos (supongo que los argumentos de función serían los adverbios). Cuando combinas funciones y objetos, expresas un pensamiento completo. Al unir pensamientos en una secuencia lógica, puede construir declaraciones elocuentes e incluso artísticas. En ese sentido, R no es tan diferente de cualquier otro idioma. R comparte otra característica de los lenguajes humanos: no te sentirás muy cómodo hablando R hasta que construyas un vocabulario de comandos de R para usar. Afortunadamente, no tienes que ser tímido. Tu computadora será la única que “escuchará” “hablando” R. Tu computadora no es muy indulgente, pero tampoco juzga. No es que tengas que preocuparte; ampliará enormemente su vocabulario de R entre aquí y el final del libro. Ahora que puede usar R, es hora de convertirse en un experto en el uso de R para hacer ciencia de datos. La base de la ciencia de datos es la capacidad de almacenar grandes cantidades de datos y recuperar valores a pedido. A partir de esto, sigue todo lo demás: manipulación de datos, visualización de datos, modelado de datos y más. Sin embargo, no puede almacenar fácilmente un conjunto de datos en su mente al memorizarlo. Tampoco puede almacenar fácilmente un conjunto de datos en papel escribiéndolo. La única forma eficiente de almacenar grandes cantidades de datos es con una computadora. De hecho, las computadoras son tan eficientes que su desarrollo en las últimas tres décadas ha cambiado por completo el tipo de datos que podemos acumular y los métodos que podemos usar para analizarlos. En resumen, el almacenamiento de datos informáticos ha impulsado la revolución en la ciencia que llamamos ciencia de datos. Proyecto 2: Baraja de Cartas lo hará parte de esta revolución enseñándole cómo usar R para almacenar conjuntos de datos en la memoria de su computadora y cómo recuperar y manipular datos una vez que están allí. "],["cards.html", "4 Proyecto 2: Baraja de Cartas", " 4 Proyecto 2: Baraja de Cartas Este proyecto, que abarca los siguientes cuatro capítulos, le enseñará cómo almacenar, recuperar y cambiar valores de datos en la memoria de su computadora. Estas habilidades lo ayudarán a guardar y administrar datos sin acumular errores. En el proyecto, diseñará una baraja de cartas que pueda barajar y repartir. Lo mejor de todo es que la baraja recordará qué cartas se han repartido, como una baraja real. Puede usar el mazo para jugar juegos de cartas, adivinar fortunas y probar estrategias de conteo de cartas. En el camino, aprenderá cómo: Guardar nuevos tipos de datos, como cadenas de caracteres y valores lógicos Guardar un conjunto de datos como vector, matriz, arreglo, lista o data frame Cargar y guardar sus propios conjuntos de datos con R Extraer valores individuales de un conjunto de datos Cambiar valores individuales dentro de un conjunto de datos Escribir pruebas lógicas Usar el símbolo de valor faltante de R, NA Para simplificar el proyecto, lo he dividido en cuatro tareas. Cada tarea le enseñará una nueva habilidad para administrar datos con R: Task 1: Construir la baraja En Objetos de R, diseñarás y construirás una baraja virtual de naipes. Este será un conjunto de datos completo, como los que usará como científico de datos. Necesitará saber cómo usar los tipos de datos y las estructuras de datos de R para que esto funcione. Task 2: Construir funciones para repartir y barajar A continuación, en Notación de R, escribirá dos funciones para usar con la baraja. Una función repartirá cartas de la baraja y la otra volverá a barajar la baraja. Para escribir estas funciones, necesitará saber cómo extraer valores de un conjunto de datos con R. Tarea 3: Cambiar el sistema de puntos para adaptarlo a tu juego En Modificación de valores, utilizará el sistema de notación de R para cambiar los valores de puntos de sus cartas para que coincidan con los juegos de cartas que desee jugar, como guerra, corazones o blackjack. Esto le ayudará a cambiar los valores existentes en los conjuntos de datos existentes. Tarea 4: Gestionar el estado de la baraja Finalmente, en Entornos, te asegurarás de que tu mazo recuerde qué cartas ha repartido. Esta es una tarea avanzada y presentará el sistema de entorno de R y las reglas de alcance. Para hacerlo con éxito, deberá aprender los detalles minuciosos de cómo R busca y usa los datos que ha almacenado en su computadora. "],["objects.html", "5 Objectos de R 5.1 Vectores Atómicos 5.2 Atributos 5.3 Matrices 5.4 Arreglos 5.5 Clases 5.6 Coerción 5.7 Listas 5.8 Data Frames 5.9 Cargar Datos 5.10 Guardar Datos 5.11 Resumen", " 5 Objectos de R En este capítulo, usará R para armar una baraja de 52 cartas. Comenzará construyendo objetos R simples que representan naipes y luego avanzará hasta una tabla de datos completa. En resumen, creará el equivalente a una hoja de cálculo de Excel desde cero. Cuando hayas terminado, tu mazo de cartas se verá así: cara palo valor rey picas 13 reina picas 12 jota picas 11 diez picas 10 nueve picas 9 ocho picas 8 ... ¿Necesita crear un conjunto de datos desde cero para usarlo en R? Para nada. Puede cargar la mayoría de los conjuntos de datos en R con un simple paso, consulte Cargar datos. Pero este ejercicio le enseñará cómo R almacena datos y cómo puede ensamblar, o desensamblar, sus propios conjuntos de datos. También aprenderá sobre los diversos tipos de objetos disponibles para usar en R (¡no todos los objetos de R son iguales!). Considere este ejercicio como un rito de iniciación; al hacerlo, se convertirá en un experto en el almacenamiento de datos en R. Comenzaremos con lo más básico. El tipo de objeto más simple en R es un vector atómico. Los vectores atómicos no tienen energía nuclear, pero son muy simples y aparecen en todas partes. Si observa lo suficientemente de cerca, verá que la mayoría de las estructuras en R se construyen a partir de vectores atómicos. 5.1 Vectores Atómicos Un vector atómico es solo un simple vector de datos. De hecho, ya ha creado un vector atómico, su objeto dado del Proyecto 1: Dados Ponderados. Puede hacer un vector atómico agrupando algunos valores de datos con c: dado &lt;- c(1, 2, 3, 4, 5, 6) dado ## 1 2 3 4 5 6 is.vector(dado) ## TRUE is.vector is.vector comprueba si un objeto es un vector atómico. Devuelve TRUE si el objeto es un vector atómico y FALSE en caso contrario. También puedes hacer un vector atómico con un solo valor. R guarda valores individuales como un vector atómico de longitud 1: cinco &lt;- 5 cinco ## 5 is.vector(cinco) ## TRUE length(cinco) ## 1 length(dado) ## 6 length length devuelve la longitud de un vector atómico. Cada vector atómico almacena sus valores como un vector unidimensional y cada vector atómico solo puede almacenar un tipo de datos. Puede guardar diferentes tipos de datos en R utilizando diferentes tipos de vectores atómicos. En total, R reconoce seis tipos básicos de vectores atómicos: dobles, enteros, caracteres, lógicos, complejos y sin procesar. Para crear su mazo de cartas, necesitará usar diferentes tipos de vectores atómicos para guardar diferentes tipos de información (texto y números). Puede hacer esto usando algunas convenciones simples cuando ingresa sus datos. Por ejemplo, puede crear un vector de números enteros al incluir una L mayúscula con su entrada. Puede crear un vector de caracteres encerrando su entrada entre comillas: ent &lt;- 1L text &lt;- &quot;as&quot; Cada tipo de vector atómico tiene su propia convención (descrita a continuación). R reconocerá la convención y la usará para crear un vector atómico del tipo apropiado. Si desea crear vectores atómicos que tengan más de un elemento, puede combinar un elemento con la función c de Paquetes y Páginas de ayuda. Use la misma convención con cada elemento: ent &lt;- c(1L, 5L) text &lt;- c(&quot;as&quot;, &quot;corazon&quot;) Quizás se pregunte por qué R usa múltiples tipos de vectores. Los tipos de vectores ayudan a que R se comporte como cabría esperar. Por ejemplo, R hará operaciones matemáticas con vectores atómicos que contienen números, pero no con vectores atómicos que contienen cadenas de caracteres: sum(ent) ## 6 sum(text) ## Error in sum(text) : invalid &#39;type&#39; (character) of argument ¡Pero nos estamos adelantando! Prepárese para saludar a los seis tipos de vectores atómicos en R. 5.1.1 Dobles Un vector doble almacena números regulares. Los números pueden ser positivos o negativos, grandes o pequeños, y tener dígitos a la derecha del lugar decimal o no. En general, R guardará cualquier número que escriba en R como un doble. Entonces, por ejemplo, el dado que hiciste en Proyecto 1: Dados Ponderados era un objeto doble: dado &lt;- c(1, 2, 3, 4, 5, 6) dado ## 1 2 3 4 5 6 Por lo general, sabrá con qué tipo de objeto está trabajando en R (será obvio), pero también puede preguntarle a R qué tipo de objeto es un objeto con typeof. Por ejemplo: typeof(dado) ## &quot;double&quot; Algunas funciones de R se refieren a los dobles como “numéricos”, y yo haré lo mismo con frecuencia. Doble es un término informático. Se refiere a la cantidad específica de bytes que usa su computadora para almacenar un número, pero encuentro que “numérico” es mucho más intuitivo cuando se hace ciencia de datos. 5.1.2 Enteros Los vectores enteros almacenan números enteros, números que se pueden escribir sin un componente decimal. Como científico de datos, no usará el tipo de número entero con mucha frecuencia porque puede guardar los números enteros como un objeto doble. Puede crear específicamente un número entero en R escribiendo un número seguido de una L mayúscula. Por ejemplo: ent &lt;- c(-1L, 2L, 4L) ent ## -1 2 4 typeof(ent) ## &quot;integer&quot; Tenga en cuenta que R no guardará un número como un entero a menos que incluya L. Los números enteros sin la L se guardarán como dobles. La única diferencia entre 4 y 4L es cómo R guarda el número en la memoria de tu computadora. Los números enteros se definen con mayor precisión en la memoria de su computadora que los dobles (a menos que el número entero sea muy grande o pequeño). ¿Por qué guardaría sus datos como un número entero en lugar de un doble? A veces, una diferencia en la precisión puede tener efectos sorprendentes. Su computadora asigna 64 bits de memoria para almacenar cada doble en un programa de R. Esto permite mucha precisión, pero algunos números no se pueden expresar exactamente en 64 bits, el equivalente a una secuencia de 64 unos y ceros. Por ejemplo, el número \\(\\pi\\) contiene una secuencia interminable de dígitos a la derecha del lugar decimal. Su computadora debe redondear \\(\\pi\\) a algo cercano, pero no exactamente igual a \\(\\pi\\) para almacenar \\(\\pi\\) en su memoria. Muchos números decimales comparten esta característica. Como resultado, cada doble tiene una precisión de unos 16 dígitos significativos. Esto introduce un pequeño error. En la mayoría de los casos, este error de redondeo pasará desapercibido. Sin embargo, en algunas situaciones, el error de redondeo puede causar resultados sorprendentes. Por ejemplo, puede esperar que el resultado de la siguiente expresión sea cero, pero no lo es: sqrt(2)^2 - 2 ## 4.440892e-16 La raíz cuadrada de dos no se puede expresar exactamente en 16 dígitos significativos. Como resultado, R tiene que redondear la cantidad y la expresión se resuelve en algo muy cercano a cero, pero no del todo. Estos errores se conocen como errores de punto flotante, y hacer aritmética en estas condiciones se conoce como aritmética de punto flotante. La aritmética de punto flotante no es una característica de R; es una característica de la programación de computadoras. Por lo general, los errores de punto flotante no serán suficientes para arruinar su día. Solo tenga en cuenta que pueden ser la causa de resultados sorprendentes. Puede evitar errores de punto flotante si evita los decimales y solo usa números enteros. Sin embargo, esta no es una opción en la mayoría de las situaciones de ciencia de datos. No puedes hacer muchas matemáticas con números enteros antes de que necesites un número no entero para expresar el resultado. Afortunadamente, los errores causados por la aritmética de punto flotante suelen ser insignificantes (y cuando no lo son, son fáciles de detectar). Como resultado, generalmente usará dobles en lugar de números enteros como científico de datos. 5.1.3 Caracteres Un vector de caracteres almacena pequeños fragmentos de texto. Puede crear un vector de caracteres en R escribiendo un carácter o una cadena de caracteres entre comillas: text &lt;- c(&quot;Hola&quot;, &quot;Mundo&quot;) text ## &quot;Hola&quot; &quot;Mundo&quot; typeof(text) ## &quot;character&quot; typeof(&quot;Hola&quot;) ## &quot;character&quot; Los elementos individuales de un vector de caracteres se conocen como cadenas. Tenga en cuenta que una cadena puede contener más que solo letras. También puede ensamblar una cadena de caracteres a partir de números o símbolos. Ejercicio 5.1 (Carácter or Número) ¿Puedes encontrar la diferencia entre una cadena de caracteres y un número? Aquí hay una prueba: ¿Cuáles de estos son cadenas de caracteres y cuáles son números? 1, \"1\", \"uno\". Solution. \"1\" y \"uno\" son ambos cadenas de caracteres. Las cadenas de caracteres pueden contener caracteres numéricos, pero eso no los convierte en numéricos. Son solo cadenas que tienen números en ellas. Puede distinguir cadenas de números reales porque las cadenas vienen entre comillas. De hecho, todo lo que esté entre comillas en R se tratará como una cadena de caracteres, independientemente de lo que aparezca entre las comillas. Es fácil confundir objetos de R con cadenas de caracteres. ¿Por qué? Porque ambos aparecen como fragmentos de texto en código de R. Por ejemplo, x es el nombre de un objeto R llamado “x”, \"x\" es una cadena de caracteres que contiene el carácter “x”. Uno es un objeto que contiene datos sin procesar, el otro es un fragmento de datos sin procesar en sí mismo. Espere un error cada vez que olvide sus comillas; R comenzará a buscar un objeto que probablemente no exista. 5.1.4 Lógicos Los vectores lógicos almacenan TRUE y FALSE, la forma de R de datos booleanos. Los lógicos son muy útiles para hacer cosas como comparaciones: 3 &gt; 4 ## FALSE Cada vez que escriba TRUE o FALSE en letras mayúsculas (sin comillas), R tratará su entrada como datos lógicos. R también asume que T y F son abreviaturas de TRUE y FALSE, a menos que se definan en otra parte (por ejemplo, ‘T &lt;- 500’). Dado que el significado de T y F puede cambiar, es mejor quedarse con TRUE y FALSE: logico &lt;- c(TRUE, FALSE, TRUE) logico ## TRUE FALSE TRUE typeof(logico) ## &quot;logical&quot; typeof(F) ## &quot;logical&quot; 5.1.5 Complejo y Sin Procesar Dobles, enteros, caracteres y lógicos son los tipos más comunes de vectores atómicos en R, pero R también reconoce dos tipos más: complejos y sin procesar. Es dudoso que alguna vez los use para analizar datos, pero aquí están por el bien de la minuciosidad. Los vectores complejos almacenan números complejos. Para crear un vector complejo, agregue un término imaginario a un número con i: comp &lt;- c(1 + 1i, 1 + 2i, 1 + 3i) comp ## 1+1i 1+2i 1+3i typeof(comp) ## &quot;complex&quot; Los vectores sin procesar almacenan bytes de datos sin procesar. Hacer vectores sin procesar se vuelve complicado, pero puedes hacer un vector sin procesar vacío de longitud n con raw(n). Consulte la página de ayuda de raw para obtener más opciones al trabajar con este tipo de datos: raw(3) ## 00 00 00 typeof(raw(3)) ## &quot;raw&quot; Ejercicio 5.2 (Vector de Cartas) Cree un vector atómico que almacene solo los nombres de las caras de las cartas en una escalera real, por ejemplo, el as de picas, el rey de picas, la reina de picas, la jota de picas y el diez de picas. El nombre de la cara del as de picas sería “as” y “picas” es el palo. ¿Qué tipo de vector usarás para guardar los nombres? Solution. Un vector de caracteres es el tipo de vector atómico más apropiado para guardar los nombres de las cartas. Puedes crear uno con la función c si pones cada nombre entre comillas: mano &lt;- c(&quot;as&quot;, &quot;rey&quot;, &quot;reina&quot;, &quot;jota&quot;, &quot;diez&quot;) mano ## &quot;as&quot; &quot;rey&quot; &quot;reina&quot; &quot;jota&quot; &quot;diez&quot; typeof(mano) ## &quot;character&quot; Esto crea un grupo unidimensional de nombres de cartas. ¡Excelente trabajo! Ahora hagamos una estructura de datos más sofisticada, una tabla bidimensional de nombres de cartas y palos. Puede construir un objeto más sofisticado a partir de un vector atómico dándole algunos atributos y asignándole una clase. 5.2 Atributos Un atributo es una pieza de información que puede adjuntar a un vector atómico (o cualquier objeto de R). El atributo no afectará ninguno de los valores del objeto y no aparecerá cuando muestre su objeto. Puede pensar en un atributo como “metadatos”; es solo un lugar conveniente para colocar información asociada con un objeto. R normalmente ignorará estos metadatos, pero algunas funciones de R verificarán atributos específicos. Estas funciones pueden usar los atributos para hacer cosas especiales con los datos. Puedes ver qué atributos tiene un objeto con attributes. attributes devolverá NULL si un objeto no tiene atributos. Un vector atómico, como dado, no tendrá ningún atributo a menos que le des alguno: attributes(dado) ## NULL NULL R usa NULL para representar el conjunto nulo, un objeto vacío. NULL a menudo es devuelto por funciones cuyos valores no están definidos. Puede crear un objeto NULL escribiendo NULL en letras mayúsculas. 5.2.1 Nombres Los atributos más comunes para dar un vector atómico son nombres, dimensiones (dim) y clases. Cada uno de estos atributos tiene su propia función auxiliar que puede usar para otorgar atributos a un objeto. También puede usar las funciones auxiliares para buscar el valor de estos atributos para los objetos que ya los tienen. Por ejemplo, puedes buscar el valor del atributo de nombres de dado con names: names(dado) ## NULL NULL significa que dado no tiene un atributo de nombres. Puedes darle uno a dado asignando un vector de caracteres a la salida de names. El vector debe incluir un nombre para cada elemento en dado: names(dado) &lt;- c(&quot;uno&quot;, &quot;dos&quot;, &quot;tres&quot;, &quot;cuatro&quot;, &quot;cinco&quot;, &quot;seis&quot;) Ahora dado tiene el atributo nombres: names(dado) ## &quot;uno&quot; &quot;dos&quot; &quot;tres&quot; &quot;cuatro&quot; &quot;cinco&quot; &quot;seis&quot; attributes(dado) ## $names ## [1] &quot;uno&quot; &quot;dos&quot; &quot;tres&quot; &quot;cuatro&quot; &quot;cinco&quot; &quot;seis&quot; R mostrará los nombres sobre los elementos de dado cada vez que mires el vector: dado ## uno dos tres cuatro cinco seis ## 1 2 3 4 5 6 Sin embargo, los nombres no afectarán los valores reales del vector, ni los nombres se verán afectados cuando manipule los valores del vector: dado + 1 ## uno dos tres cuatro cinco seis ## 2 3 4 5 6 7 También puede usar names para cambiar el atributo de nombres o eliminarlo todo junto. Para cambiar los nombres, asigna un nuevo conjunto de etiquetas a names: names(dado) &lt;- c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;, &quot;six&quot;) dado ## one two three four five six ## 1 2 3 4 5 6 Para eliminar el atributo de nombres, configúrelo en NULL: names(dado) &lt;- NULL dado ## 1 2 3 4 5 6 5.2.2 Dimensiones Puede transformar un vector atómico en una matriz n-dimensional dándole un atributo de dimensiones con dim. Para hacer esto, establezca el atributo dim en un vector numérico de longitud n. R reorganizará los elementos del vector en n dimensiones. Cada dimensión tendrá tantas filas (o columnas, etc.) como el valor n del vector dim. Por ejemplo, puede reorganizar dado en una matriz de 2 × 3 (que tiene 2 filas y 3 columnas): dim(dado) &lt;- c(2, 3) dado ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 o en una mariz de 3 × 2 (que tiene 3 filas y 2 columnas): dim(dado) &lt;- c(3, 2) dado ## [,1] [,2] ## [1,] 1 4 ## [2,] 2 5 ## [3,] 3 6 o en hipercubo de 1 × 2 × 3 (que tiene 1 fila, 2 columnas, y 3 “rebanadas”). Esta es una estructura tridimensional, pero R necesitará mostrarla rebanada por rebanada en la pantalla bidimensional de su computadora: dim(dado) &lt;- c(1, 2, 3) dado ## , , 1 ## ## [,1] [,2] ## [1,] 1 2 ## ## , , 2 ## ## [,1] [,2] ## [1,] 3 4 ## ## , , 3 ## ## [,1] [,2] ## [1,] 5 6 R siempre usará el primer valor en dim para el número de filas y el segundo valor para el número de columnas. En general, las filas siempre van primero en las operaciones de R que se ocupan tanto de filas como de columnas. Puede notar que no tiene mucho control sobre cómo R reorganiza los valores en filas y columnas. Por ejemplo, R siempre llena cada matriz por columnas, en lugar de por filas. Si desea tener más control sobre este proceso, puede usar una de las funciones auxiliares de R, matrix o array. Hacen lo mismo que cambiar el atributo dim, pero proporcionan argumentos adicionales para personalizar el proceso. 5.3 Matrices Las matrices almacenan valores en una matriz bidimensional, como una matriz de álgebra lineal. Para crear uno, primero dale a matrix un vector atómico para reorganizar en una matriz. Luego, defina cuántas filas debe haber en la matriz configurando el argumento nrow en un número. matrix organizará su vector de valores en una matriz con el número especificado de filas. Alternativamente, puede establecer el argumento ncol, que le dice a R cuántas columnas incluir en la matriz: m &lt;- matrix(dado, nrow = 2) m ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 matrix llenará la matriz columna por columna por defecto, pero puedes llenar la matriz fila por fila si incluyes el argumento byrow = TRUE: m &lt;- matrix(dado, nrow = 2, byrow = TRUE) m ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 matrix también tiene otros argumentos predeterminados que puede usar para personalizar su matriz. Puede leer sobre ellos en la página de ayuda de matrix (accesible por ?matrix). 5.4 Arreglos La función array crea una matriz de n dimensiones. Por ejemplo, podría usar array para clasificar los valores en un cubo de tres dimensiones o un hipercubo en 4, 5 o n dimensiones. array no es tan personalizable como matrix y básicamente hace lo mismo que configurar el atributo dim. Para usar array, proporcione un vector atómico como primer argumento y un vector de dimensiones como segundo argumento, ahora llamado dim: ar &lt;- array(c(11:14, 21:24, 31:34), dim = c(2, 2, 3)) ar ## , , 1 ## ## [,1] [,2] ## [1,] 11 13 ## [2,] 12 14 ## ## , , 2 ## ## [,1] [,2] ## [1,] 21 23 ## [2,] 22 24 ## ## , , 3 ## ## [,1] [,2] ## [1,] 31 33 ## [2,] 32 34 Ejercicio 5.3 (Hacer una Matriz) Cree la siguiente matriz, que almacena el nombre y el palo de cada carta en una escalera real. ## [,1] [,2] ## [1,] &quot;as&quot; &quot;picas&quot; ## [2,] &quot;rey&quot; &quot;picas&quot; ## [3,] &quot;reina&quot; &quot;picas&quot; ## [4,] &quot;jota&quot; &quot;picas&quot; ## [5,] &quot;diez&quot; &quot;picas&quot; Solution. Hay más de una forma de construir esta matriz, pero en todos los casos, deberá comenzar creando un vector de caracteres con 10 valores. Si comienza con el siguiente vector de caracteres, puede convertirlo en una matriz con cualquiera de los siguientes tres comandos: mano1 &lt;- c(&quot;as&quot;, &quot;rey&quot;, &quot;reina&quot;, &quot;jota&quot;, &quot;diez&quot;, &quot;picas&quot;, &quot;picas&quot;, &quot;picas&quot;, &quot;picas&quot;, &quot;picas&quot;) matrix(mano1, nrow = 5) matrix(mano1, ncol = 2) dim(mano1) &lt;- c(5, 2) También puede comenzar con un vector de caracteres que enumere las cartas en un orden ligeramente diferente. En este caso, deberá pedirle a R que llene la matriz fila por fila en lugar de columna por columna: mano2 &lt;- c(&quot;as&quot;, &quot;picas&quot;, &quot;rey&quot;, &quot;picas&quot;, &quot;reina&quot;, &quot;picas&quot;, &quot;jota&quot;, &quot;picas&quot;, &quot;diez&quot;, &quot;picas&quot;) matrix(mano2, nrow = 5, byrow = TRUE) matrix(mano2, ncol = 2, byrow = TRUE) 5.5 Clases Tenga en cuenta que cambiar las dimensiones de su objeto no cambiará el tipo del objeto, pero cambiará el atributo clase del objeto: dim(dado) &lt;- c(2, 3) typeof(dado) ## &quot;double&quot; class(dado) ## &quot;matrix&quot; Una matriz es un caso especial de un vector atómico. Por ejemplo, la matriz dado es un caso especial de vector doble. Cada elemento de la matriz sigue siendo un doble, pero los elementos se han organizado en una nueva estructura. R agregó un atributo de clase a dado cuando cambiaste sus dimensiones. Esta clase describe el nuevo formato de dado. Muchas funciones de R buscarán específicamente el atributo clase de un objeto y luego manejarán el objeto de una manera predeterminada en función del atributo. Tenga en cuenta que el atributo clase de un objeto no siempre aparecerá cuando ejecute attributes; es posible que deba buscarlo específicamente con class: attributes(dado) ## $dim ## [1] 2 3 Puede aplicar class a objetos que no tienen un atributo de clase. class devolverá un valor basado en el tipo atómico del objeto. Tenga en cuenta que la “clase” de un doble es “numérica”, una desviación extraña, pero por la que estoy agradecido. Creo que la propiedad más importante de un vector doble es que contiene números, una propiedad que “numeric” hace evidente: class(&quot;Hola&quot;) ## &quot;character&quot; class(5) ## &quot;numeric&quot; También puede usar class para establecer el atributo clase de un objeto, pero esto suele ser una mala idea. R esperará que los objetos de una clase compartan ciertas características, como atributos, que su objeto puede no poseer. Aprenderá a crear y utilizar sus propias clases en Proyecto 3: Máquina Tragamonedas. 5.5.1 Fechas y Horarios El sistema de atributos permite que R represente más tipos de datos que solo dobles, enteros, caracteres, lógicos, complejos y sin procesar. La hora parece una cadena de caracteres cuando la visualizas, pero su tipo de datos es en realidad \"doble\", y su clase es \"POSIXct\" \"POSIXt\" (tiene dos clases): ahora &lt;- Sys.time() ahora ## &quot;2014-03-17 12:00:00 UTC&quot; typeof(ahora) ## &quot;double&quot; class(ahora) ## &quot;POSIXct&quot; &quot;POSIXt&quot; POSIXct es un marco ampliamente utilizado para representar fechas y horas. En el marco de POSIXct, cada hora se representa por la cantidad de segundos que han pasado entre la hora y las 12:00 a. m. del 1 de enero de 1970 (en la zona Universal Time Coordinated (UTC)). Por ejemplo, el tiempo anterior ocurre 1 395 057 600 segundos después. Entonces, en el sistema POSIXct, el tiempo se guardaría como 1395057600. R crea el objeto de tiempo construyendo un vector doble con un elemento, 1395057600. Puede ver este vector eliminando el atributo clase de ahora, o usando la función unclass, que hace lo mismo: unclass(ahora) ## 1395057600 R luego le da al vector doble un atributo clase que contiene dos clases, \"POSIXct\" y \"POSIXt\". Este atributo alerta a las funciones de R de que están tratando con un tiempo POSIXct, para que puedan tratarlo de una manera especial. Por ejemplo, las funciones R usarán el estándar POSIXct para convertir la hora en una cadena de caracteres fácil de usar antes de mostrarla. Puede aprovechar este sistema dando la clase POSIXct a objetos R aleatorios. Por ejemplo, ¿alguna vez se ha preguntado qué día era un millón de segundos después de las 12:00 a. m. del 1 de enero de 1970? millon &lt;- 1000000 millon ## 1e+06 class(millon) &lt;- c(&quot;POSIXct&quot;, &quot;POSIXt&quot;) millon ## &quot;1970-01-12 13:46:40 UTC&quot; 12 de enero de 1970. Vaya. Un millón de segundos pasan más rápido de lo que piensas. Esta conversión funcionó bien porque la clase POSIXct no depende de ningún atributo adicional, pero en general, forzar la clase de un objeto es una mala idea. Hay muchas clases diferentes de datos en R y sus paquetes, y cada día se inventan nuevas clases. Sería difícil aprender sobre cada clase, pero no es necesario. La mayoría de las clases solo son útiles en situaciones específicas. Dado que cada clase viene con su propia página de ayuda, puede esperar para aprender sobre una clase hasta que la encuentre. Sin embargo, hay una clase de datos que es tan omnipresente en R que debería conocerla junto con los tipos de datos atómicos. Esa clase es factores. 5.5.2 Factores Los factores son la forma en que R almacena información categórica, como el origen étnico o el color de ojos. Piense en un factor como algo así como un género; solo puede tener ciertos valores (masculino o femenino), y estos valores pueden tener su propio orden idiosincrático (damas primero). Este arreglo hace que los factores sean muy útiles para registrar los niveles de tratamiento de un estudio y otras variables categóricas. Para hacer un factor, pase un vector atómico a la función factor. R recodificará los datos en el vector como enteros y almacenará los resultados en un vector entero. R también agregará un atributo niveles (levels en inglés) al entero, que contiene un conjunto de etiquetas para mostrar los valores de los factores, y un atributo class, que contiene la clase factor: genero &lt;- factor(c(&quot;masculino&quot;, &quot;femenino&quot;, &quot;femenino&quot;, &quot;masculino&quot;)) typeof(genero) ## &quot;integer&quot; attributes(genero) ## $levels ## [1] &quot;femenino&quot; &quot;masculino&quot; ## ## $class ## [1] &quot;factor&quot; Puedes ver exactamente cómo R almacena tu factor con unclass: unclass(genero) ## [1] 2 1 1 2 ## attr(,&quot;levels&quot;) ## [1] &quot;femenino&quot; &quot;masculino&quot; R usa el atributo de niveles cuando muestra el factor, como verá. R mostrará cada 1 como femenino, la primera etiqueta en el vector de niveles, y cada 2 como masculino, la segunda etiqueta. Si el factor incluyera 3, se mostrarían como la tercera etiqueta, y así sucesivamente: genero ## masculino femenino femenino masculino ## Levels: femenino masculino Los factores facilitan la colocación de variables categóricas en un modelo estadístico porque las variables ya están codificadas como números. Sin embargo, los factores pueden resultar confusos, ya que parecen cadenas de caracteres pero se comportan como números enteros. R a menudo intentará convertir cadenas de caracteres en factores cuando cargue y cree datos. En general, tendrá una experiencia más fluida si no permite que R haga factores hasta que los solicite. Te mostraré cómo hacer esto cuando comencemos a leer datos. Puede convertir un factor en una cadena de caracteres con la función as.character. R conservará la versión de visualización del factor, no los números enteros almacenados en la memoria: as.character(genero) ## &quot;masculino&quot; &quot;femenino&quot; &quot;femenino&quot; &quot;masculino&quot; Ahora que comprende las posibilidades que brindan los vectores atómicos de R, hagamos un tipo de naipe más complicado. Ejercicio 5.4 (Escriba una Carta) Muchos juegos de cartas asignan un valor numérico a cada carta. Por ejemplo, en el blackjack, cada carta con figuras vale 10 puntos, cada carta con números vale entre 2 y 10 puntos, y cada as vale 1 u 11 puntos, dependiendo de la puntuación final. Haz un naipe virtual combinando “as”, “corazón” y 1 en un vector. ¿Qué tipo de vector atómico resultará? Comprueba si tienes razón. Solution. Es posible que hayas adivinado que este ejercicio no saldría bien. Cada vector atómico solo puede almacenar un tipo de datos. Como resultado, R convierte todos sus valores en cadenas de caracteres: carta &lt;- c(&quot;as&quot;, &quot;corazones&quot;, 1) carta ## &quot;as&quot; &quot;corazones&quot; &quot;1&quot; Esto causará problemas si desea hacer operaciones matemáticas con ese valor en puntos, por ejemplo, para ver quién ganó su juego de blackjack. Tipos de datos en vectores Si intenta poner varios tipos de datos en un vector, R convertirá los elementos en un solo tipo de datos. Dado que las matrices y los arreglos son casos especiales de vectores atómicos, sufren el mismo comportamiento. Cada uno solo puede almacenar un tipo de datos. Esto crea un par de problemas. Primero, muchos conjuntos de datos contienen múltiples tipos de datos. Los programas simples como Excel y Numbers pueden guardar múltiples tipos de datos en el mismo conjunto de datos, y debería esperar que R también pueda hacerlo. No te preocupes, puede. En segundo lugar, la coerción es un comportamiento común en R, por lo que querrá saber cómo funciona. 5.6 Coerción El comportamiento de coerción de R puede parecer inconveniente, pero no es arbitrario. R siempre sigue las mismas reglas cuando obliga a los tipos de datos. Una vez que esté familiarizado con estas reglas, puede usar el comportamiento de coerción de R para hacer cosas sorprendentemente útiles. Entonces, ¿cómo coacciona R los tipos de datos? Si una cadena de caracteres está presente en un vector atómico, R convertirá todo lo demás en el vector en cadenas de caracteres. Si un vector solo contiene lógicos y números, R convertirá los lógicos en números; cada TRUE se convierte en 1, y cada FALSE se convierte en 0, como se muestra en la Figura 5.1. Figure 5.1: R siempre usa las mismas reglas para obligar a los datos a un solo tipo. Si hay cadenas de caracteres presentes, todo se convertirá en una cadena de caracteres. De lo contrario, los lógicos se convierten en numéricos. Este arreglo preserva la información. Es fácil mirar una cadena de caracteres y decir qué información solía contener. Por ejemplo, puede detectar fácilmente los orígenes de \"TRUE\" y \"5\". También puede volver a transformar fácilmente un vector de 1 y 0 en TRUE y FALSE. R usa las mismas reglas de coerción cuando intenta hacer operaciones matemáticas con valores lógicos. Entonces el siguiente código: sum(c(TRUE, TRUE, FALSE, FALSE)) se convertirá: sum(c(1, 1, 0, 0)) ## 2 Esto significa que sum contará el número de TRUE en un vector lógico (y mean calculará la proporción de TRUE). Listo, ¿eh? Puede pedirle explícitamente a R que convierta datos de un tipo a otro con las funciones as. R convertirá los datos siempre que haya una forma sensata de hacerlo: as.character(1) ## &quot;1&quot; as.logical(1) ## TRUE as.numeric(FALSE) ## 0 Ahora sabe cómo R coacciona los tipos de datos, pero esto no lo ayudará a salvar una carta. Para hacer eso, deberá evitar la coerción por completo. Puedes hacer esto usando un nuevo tipo de objeto, una lista. Antes de ver las listas, abordemos una pregunta que podría tener en mente. Muchos conjuntos de datos contienen múltiples tipos de información. La incapacidad de vectores, matrices y arreglos para almacenar múltiples tipos de datos parece ser una limitación importante. Entonces, ¿por qué molestarse con ellos? En algunos casos, usar un solo tipo de datos es una gran ventaja. Los vectores, las matrices y los arreglos hacen que sea muy fácil hacer operaciones matemáticas con grandes conjuntos de números porque R sabe que puede manipular cada valor de la misma manera. Las operaciones con vectores, matrices y arreglos también tienden a ser rápidas porque los objetos son muy fáciles de almacenar en la memoria. En otros casos, permitir un solo tipo de datos no es una desventaja. Los vectores son la estructura de datos más común en R porque almacenan muy bien las variables. Cada valor de una variable mide la misma propiedad, por lo que no es necesario utilizar diferentes tipos de datos. 5.7 Listas Las listas son como vectores atómicos porque agrupan datos en un conjunto unidimensional. Sin embargo, las listas no agrupan valores individuales; las listas agrupan objetos de R, como vectores atómicos y otras listas. Por ejemplo, puede crear una lista que contenga un vector numérico de longitud 31 en su primer elemento, un vector de caracteres de longitud 1 en su segundo elemento y una nueva lista de longitud 2 en su tercer elemento. Para hacer esto, use la función list. list crea una lista de la misma manera que c crea un vector. Separe cada elemento de la lista con una coma: lista1 &lt;- list(100:130, &quot;R&quot;, list(TRUE, FALSE)) lista1 ## [[1]] ## [1] 100 101 102 103 104 105 106 107 108 109 110 111 112 ## [14] 113 114 115 116 117 118 119 120 121 122 123 124 125 ## [27] 126 127 128 129 130 ## ## [[2]] ## [1] &quot;R&quot; ## ## [[3]] ## [[3]][[1]] ## [1] TRUE ## ## [[3]][[2]] ## [1] FALSE Dejé la notación [1] en la salida para que puedas ver cómo cambia para las listas. Los índices entre corchetes le indican qué elemento de la lista se está mostrando. Los índices de un solo paréntesis le indican qué subelemento de un elemento se muestra. Por ejemplo, 100 es el primer subelemento del primer elemento de la lista. \"R\" es el primer subelemento del segundo elemento. Esta notación de dos sistemas surge porque cada elemento de una lista puede ser cualquier objeto R, incluido un nuevo vector (o lista) con sus propios índices. Las listas son un tipo básico de objeto en R, a la par de los vectores atómicos. Al igual que los vectores atómicos, se utilizan como bloques de construcción para crear muchos tipos más sofisticados de objetos de R. Como puede imaginar, la estructura de las listas puede volverse bastante complicada, pero esta flexibilidad hace que las listas sean una herramienta de almacenamiento útil para todo uso en R: puede agrupar cualquier cosa con una lista. Sin embargo, no todas las listas tienen que ser complicadas. Puede almacenar una carta de juego en una lista muy simple. Ejercicio 5.5 (Usar una Lista para Crear una Carta) Use una lista para almacenar una sola carta, como el as de corazones, que tiene un valor de punto de uno. La lista debe guardar la cara de la carta, el palo y el valor del punto en elementos separados. Solution. Puedes crear tu carta así. En el siguiente ejemplo, el primer elemento de la lista es un vector de caracteres (de longitud 1). El segundo elemento también es un vector de caracteres y el tercer elemento es un vector numérico: carta &lt;- list(&quot;as&quot;, &quot;corazones&quot;, 1) carta ## [[1]] ## [1] &quot;as&quot; ## ## [[2]] ## [1] &quot;corazones&quot; ## ## [[3]] ## [1] 1 También puede usar una lista para almacenar una baraja completa de cartas. Dado que puede guardar una sola carta de juego como una lista, puede guardar una baraja de cartas de juego como una lista de 52 sublistas (una para cada carta). Pero no nos molestemos, hay una forma mucho más limpia de hacer lo mismo. Puede usar una clase especial de lista, conocida como data frames. 5.8 Data Frames Data frames son la versión bidimensional de una lista. Son, por mucho, la estructura de almacenamiento más útil para el análisis de datos y proporcionan una forma ideal de almacenar una baraja completa de cartas. Puede pensar en un data frame como el equivalente de R a la hoja de cálculo de Excel porque almacena datos en un formato similar. Data frames agrupan vectores en una tabla bidimensional. Cada vector se convierte en una columna en la tabla. Como resultado, cada columna de un data frame puede contener un tipo diferente de datos; pero dentro de una columna, cada celda debe tener el mismo tipo de datos, como en la Figura 5.2. Figure 5.2: Data frames almacenan datos como una secuencia de columnas. Cada columna puede ser un tipo de datos diferente. Cada columna en un data frame debe tener la misma longitud. Crear un data frame a mano requiere escribir mucho, pero puede hacerlo (si lo desea) con la función data.frame. Proporcione a data.frame cualquier número de vectores, cada uno separado por una coma. Cada vector debe establecerse igual a un nombre que describa el vector. data.frame convertirá cada vector en una columna del nuevo data frame: df &lt;- data.frame(cara = c(&quot;as&quot;, &quot;dos&quot;, &quot;seis&quot;), palo = c(&quot;treboles&quot;, &quot;treboles&quot;, &quot;treboles&quot;), valor = c(1, 2, 3)) df ## cara palo valor ## as treboles 1 ## dos treboles 2 ## seis treboles 3 Deberá asegurarse de que cada vector tenga la misma longitud (o se puede hacer así con las reglas de reciclaje de R; consulte la figura 2.4, ya que los data frames no pueden combinar columnas de diferentes longitudes. En el código anterior, nombré los argumentos en data.frame cara, palo y valor, pero puedes nombrar los argumentos como quieras. data.frame utilizará los nombres de sus argumentos para etiquetar las columnas del data frame. Nombres También puede dar nombres a una lista o vector cuando crea uno de estos objetos. Use la misma sintaxis que con data.frame: list(cara = \"as\", palo = \"corazones\", value = 1) c(cara = \"as\", palo = \"corazones\", value = \"one\") Los nombres se almacenarán en el atributo names del objeto. Si observa el tipo de data frame, verá que es una lista. De hecho, cada data frame es una lista con la clase data.frame. Puede ver qué tipos de objetos se agrupan en una lista (o data frame) con la función str: typeof(df) ## &quot;list&quot; class(df) ## &quot;data.frame&quot; str(df) ## &#39;data.frame&#39;: 3 obs. of 3 variables: ## $ cara : Factor w/ 3 levels &quot;as&quot;,&quot;seis&quot;,&quot;dos&quot;: 1 3 2 ## $ palo : Factor w/ 1 level &quot;treboles&quot;: 1 1 1 ## $ valor: num 1 2 3 Observe que R guardó sus cadenas de caracteres como factores. ¡Te dije que a R le gustan los factores! No es un gran problema aquí, pero puede evitar este comportamiento agregando el argumento stringsAsFactors = FALSE a data.frame: df &lt;- data.frame(cara = c(&quot;as&quot;, &quot;dos&quot;, &quot;seis&quot;), palo = c(&quot;treboles&quot;, &quot;treboles&quot;, &quot;treboles&quot;), value = c(1, 2, 3), stringsAsFactors = FALSE) Un data frame es una excelente manera de construir una baraja completa de cartas. Puede convertir cada fila del data frame en una carta de juego y cada columna en un tipo de valor, cada uno con su propio tipo de datos apropiado. El data frame se vería así: ## cara palo valor ## rey picas 13 ## reina picas 12 ## jota picas 11 ## diez picas 10 ## nueve picas 9 ## ocho picas 8 ## siete picas 7 ## seis picas 6 ## cinco picas 5 ## cuatro picas 4 ## tres picas 3 ## dos picas 2 ## as picas 1 ## rey treboles 13 ## reina treboles 12 ## jota treboles 11 ## diez treboles 10 ## ... y así sucesivamente. Podría crear este data frame con data.frame, ¡pero mire la escritura involucrada! Necesitas escribir tres vectores, cada uno con 52 elementos: baraja &lt;- data.frame( cara = c(&quot;rey&quot;, &quot;reina&quot;, &quot;jota&quot;, &quot;diez&quot;, &quot;nueve&quot;, &quot;ocho&quot;, &quot;siete&quot;, &quot;seis&quot;, &quot;cinco&quot;, &quot;cuatro&quot;, &quot;tres&quot;, &quot;dos&quot;, &quot;as&quot;, &quot;rey&quot;, &quot;reina&quot;, &quot;jota&quot;, &quot;diez&quot;, &quot;nueve&quot;, &quot;ocho&quot;, &quot;siete&quot;, &quot;seis&quot;, &quot;cinco&quot;, &quot;cuatro&quot;, &quot;tres&quot;, &quot;dos&quot;, &quot;as&quot;, &quot;rey&quot;, &quot;reina&quot;, &quot;jota&quot;, &quot;diez&quot;, &quot;nueve&quot;, &quot;ocho&quot;, &quot;siete&quot;, &quot;seis&quot;, &quot;cinco&quot;, &quot;cuatro&quot;, &quot;tres&quot;, &quot;dos&quot;, &quot;as&quot;, &quot;rey&quot;, &quot;reina&quot;, &quot;jota&quot;, &quot;diez&quot;, &quot;nueve&quot;, &quot;ocho&quot;, &quot;siete&quot;, &quot;seis&quot;, &quot;cinco&quot;, &quot;cuatro&quot;, &quot;tres&quot;, &quot;dos&quot;, &quot;as&quot;), palo = c(&quot;picas&quot;, &quot;picas&quot;, &quot;picas&quot;, &quot;picas&quot;, &quot;picas&quot;, &quot;picas&quot;, &quot;picas&quot;, &quot;picas&quot;, &quot;picas&quot;, &quot;picas&quot;, &quot;picas&quot;, &quot;picas&quot;, &quot;picas&quot;, &quot;treboles&quot;, &quot;treboles&quot;, &quot;treboles&quot;, &quot;treboles&quot;, &quot;treboles&quot;, &quot;treboles&quot;, &quot;treboles&quot;, &quot;treboles&quot;, &quot;treboles&quot;, &quot;treboles&quot;, &quot;treboles&quot;, &quot;treboles&quot;, &quot;treboles&quot;, &quot;diamantes&quot;, &quot;diamantes&quot;, &quot;diamantes&quot;, &quot;diamantes&quot;, &quot;diamantes&quot;, &quot;diamantes&quot;, &quot;diamantes&quot;, &quot;diamantes&quot;, &quot;diamantes&quot;, &quot;diamantes&quot;, &quot;diamantes&quot;, &quot;diamantes&quot;, &quot;diamantes&quot;, &quot;corazones&quot;, &quot;corazones&quot;, &quot;corazones&quot;, &quot;corazones&quot;, &quot;corazones&quot;, &quot;corazones&quot;, &quot;corazones&quot;, &quot;corazones&quot;, &quot;corazones&quot;, &quot;corazones&quot;, &quot;corazones&quot;, &quot;corazones&quot;, &quot;corazones&quot;), valor = c(13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1) ) Debe evitar escribir grandes conjuntos de datos a mano siempre que sea posible. Escribir invita a errores tipográficos y errores. Siempre es mejor adquirir grandes conjuntos de datos como un archivo de computadora. Luego puede pedirle a R que lea el archivo y almacene el contenido como un objeto. Creé un archivo para que lo cargues que contiene un data frame de información de naipes, así que no te preocupes por escribir el código. En su lugar, dirija su atención hacia la carga de datos en R. 5.9 Cargar Datos Puede cargar el data frame Mazo desde el archivo mazo.csv. Tómese un momento para descargar el archivo antes de seguir leyendo. Visite el sitio web, haga clic en “Descargar Zip” y luego descomprima y abra la carpeta que descarga su navegador web. mazo.csv estará dentro. mazo.csv es un archivo de valores separados por comas, o CSV para abreviar. Los CSV son archivos de texto sin formato, lo que significa que puede abrirlos en un editor de texto (así como en muchos otros programas). Si abre mazo.csv, notará que contiene una tabla de datos similar a la siguiente tabla. Cada fila de la tabla se guarda en su propia línea y se usa una coma para separar las celdas dentro de cada fila. Cada archivo CSV comparte este formato básico: &quot;cara&quot;,&quot;palo&quot;,&quot;valor&quot; &quot;rey&quot;,&quot;picas&quot;,13 &quot;reina&quot;,&quot;picas&quot;,12 &quot;jota&quot;,&quot;picas&quot;,11 &quot;diez&quot;,&quot;picas&quot;,10 &quot;nueve&quot;,&quot;picas&quot;,9 ... y así sucesivamente. La mayoría de las aplicaciones de ciencia de datos pueden abrir archivos de texto sin formato y exportar datos como archivos de texto sin formato. Esto hace que los archivos de texto sin formato sean una especie de lingua franca para la ciencia de datos. Para cargar un archivo de texto sin formato en R, haga clic en el icono Import Dataset en RStudio, que se muestra en la Figura 5.3. Luego seleccione “From text file (base)”. Figure 5.3: Puede importar datos desde archivos de texto sin formato con Import Dataset de RStudio. RStudio le pedirá que seleccione el archivo que desea importar, luego abrirá un asistente para ayudarlo a importar los datos, como en la Figura 5.4. Utilice el asistente para decirle a RStudio qué nombre dar al conjunto de datos. También puede usar el asistente para decirle a RStudio qué carácter usa el conjunto de datos como separador, qué carácter usa para representar decimales (generalmente un punto en los Estados Unidos y una coma en Europa) y si el conjunto de datos viene o no con una fila de nombres de columna (conocido como header). Para ayudarlo, el asistente le muestra cómo se ve el archivo sin procesar, así como también cómo se verán los datos cargados según la configuración de entrada. También puede desmarcar la casilla “Strings as factors” en el asistente. Recomiendo hacer esto. Si lo hace, R cargará todas sus cadenas de caracteres como cadenas de caracteres. Si no lo hace, R los convertirá en factores. Figure 5.4: Asistente de importación de RStudio. Una vez que todo se vea bien, haga clic en Import. RStudio leerá los datos y los guardará en un data frame. RStudio también abrirá un visor de datos, para que pueda ver sus nuevos datos en un formato de hoja de cálculo. Esta es una buena manera de verificar que todo salió como se esperaba. Si todo funcionó bien, su archivo debería aparecer en una pestaña View de RStudio, como se ve en la Figura 5.5. Puede examinar el data frame en la consola con head(mazo) Datos en Línea Puede cargar un archivo de texto sin formato directamente desde Internet haciendo click en Import Dataset &gt; From Text (readr) y copiando la url del archivo en la casilla “File/URL” del asistente de importación de RStudio. Para poder utlizar esta opción debera instalar el paquete readr. Figure 5.5: Cuando importa un conjunto de datos, RStudio guardará los datos en un data frame y luego mostrará el data frame en una pestaña View. Puede abrir cualquier data frame en una pestaña View en cualquier momento con la función View. Ahora es tu turno. Descargue mazo.csv e impórtelo a RStudio. Asegúrese de guardar la salida en un objeto de R llamado mazo: lo usará en los próximos capítulos. Si todo va correctamente, las primeras líneas de su data frame deberían verse así: head(mazo) ## cara palo valor ## rey picas 13 ## reina picas 12 ## jota picas 11 ## diez picas 10 ## nueve picas 9 ## ocho picas 8 head y tail son dos funciones que proporcionan una manera fácil de echar un vistazo a grandes conjuntos de datos. head devolverá solo las primeras seis filas del conjunto de datos, y tail devolverá solo las últimas seis filas. Para ver un número diferente de filas, dé a head o tail un segundo argumento, el número de filas que le gustaría ver, por ejemplo, head (mazo, 10). R puede abrir muchos tipos de archivos, no solo CSV. Visite Cargar y Guardar Datos en R para obtener información sobre cómo abrir otros tipos comunes de archivos en R. 5.10 Guardar Datos Antes de continuar, guardemos una copia de mazo como un nuevo archivo .csv. De esa manera, puede enviarlo por correo electrónico a un colega, almacenarlo en una memoria USB o abrirlo en un programa diferente. Puede guardar cualquier data frame en R en un archivo .csv con el comando write.csv. Para guardar mazo, ejecute: write.csv(mazo, file = &quot;cartas.csv&quot;, row.names = FALSE) R convertirá su data frame en un archivo de texto sin formato con el formato de valores separados por comas y guardará el archivo en su directorio de trabajo. Para ver dónde está su directorio de trabajo, ejecute getwd(). Para cambiar la ubicación de su directorio de trabajo, visite Session &gt; Set Working Directory &gt; Choose Directory en la barra de menú de RStudio. Puede personalizar el proceso de guardado con el amplio conjunto de argumentos opcionales de write.csv (consulte ?write.csv para obtener más detalles). Sin embargo, hay tres argumentos que debería usar cada vez que ejecute write.csv. Primero, debe darle a write.csv el nombre del data frame que desea guardar. A continuación, debe proporcionar un nombre de archivo para darle a su archivo. R tomará este nombre literalmente, así que asegúrese de proporcionar una extensión. Finalmente, debe agregar el argumento row.names = FALSE. Esto evitará que R agregue una columna de números al comienzo de su data frame. Estos números identificarán sus filas del 1 al 52, pero es poco probable que cualquier programa en el que abra cartas.csv comprenda el sistema de nombres de fila. Lo más probable es que el programa asuma que los nombres de las filas son la primera columna de datos en su data frame. De hecho, esto es exactamente lo que asumirá R si vuelve a abrir cartas.csv. Si guarda y abre cartas.csv varias veces en R, notará que se forman columnas duplicadas de números de fila al comienzo de su data frame. No puedo explicar por qué R hace esto, pero puedo explicar cómo evitarlo: use row.names = FALSE siempre que guarde datos con write.csv. Para obtener más detalles sobre cómo guardar archivos, incluido cómo comprimir archivos guardados y cómo guardar archivos en otros formatos, consulte Cargar y Guardar Datos en R. Buen trabajo. Ahora tiene una baraja de cartas virtual con la que trabajar. Tómese un respiro y, cuando regrese, comenzaremos a escribir algunas funciones para usar en su mazo. 5.11 Resumen Puede guardar datos en R con cinco objetos diferentes, que le permiten almacenar diferentes tipos de valores en diferentes tipos de relaciones, como en la Figura ??. De estos objetos, los data frame son, por mucho, los más útiles para la ciencia de datos. Los data frame almacenan una de las formas de datos más comunes utilizadas en la ciencia de datos, los datos tabulares. Figure 5.6: Las estructuras de datos más comunes de R son vectores, matrices, arreglos, listas y marcos de datos. Puede cargar datos tabulares en un data frame con el botón Import Dataset de RStudio, siempre que los datos se guarden como un archivo de texto sin formato. Este requisito no es tan limitante como parece. La mayoría de los programas de software pueden exportar datos como un archivo de texto sin formato. Entonces, si tiene un archivo de Excel (por ejemplo), puede abrir el archivo en Excel y exportar los datos como CSV para usar con R. De hecho, abrir un archivo en su programa original es una buena práctica. Los archivos de Excel usan metadatos, como hojas y fórmulas, que ayudan a Excel a trabajar con el archivo. R puede intentar extraer datos sin procesar del archivo, pero no será tan bueno para hacerlo como lo es Microsoft Excel. Ningún programa es mejor para convertir archivos de Excel que Excel. Del mismo modo, ningún programa es mejor para convertir archivos SAS Xport que SAS, y así sucesivamente. Sin embargo, es posible que se encuentre con un archivo específico del programa, pero no con el programa que lo creó. No querría comprar una licencia SAS de varios miles de dólares solo para abrir un archivo SAS. Afortunadamente, R puede abrir muchos tipos de archivos, incluidos archivos de otros programas y bases de datos. R incluso tiene sus propios formatos específicos del programa que pueden ayudarlo a ahorrar memoria y tiempo si sabe que trabajará completamente en R. Si desea obtener más información sobre todas sus opciones para cargar y guardar datos en R, consulte Cargar y Guardar Datos en R. Notación de R se basará en las habilidades que aprendió en este capítulo. Aquí, aprendió cómo almacenar datos en R. En Notación de R, aprenderá cómo acceder a los valores una vez que se han almacenado. También escribirá dos funciones que le permitirán comenzar a usar su mazo, una función para barajar y una función para repartir. "],["notation.html", "6 Notación de R 6.1 Selección de Valores 6.2 Repartir una Carta 6.3 Barajar el Mazo 6.4 Signos de Dólar y Corchetes Dobles 6.5 Resumen", " 6 Notación de R Ahora que tiene una baraja de cartas, necesita una forma de hacer: Primero, querrás una forma de barajar el mazo de vez en cuando. Y luego, querrás repartir cartas del mazo (una carta a la vez, cualquiera que sea la carta que esté arriba, no somos tramposos). Para hacer estas cosas, deberá trabajar con los valores individuales dentro de su data frame, una tarea esencial para la ciencia de datos. Por ejemplo, para repartir una carta de la parte superior de su mazo, deberá escribir una función que seleccione la primera fila de valores en su data frame, como esta repartir(mazo) ## cara palo valor ## rey picas 13 Puede seleccionar valores dentro de un objeto de R con el sistema de notación de R. 6.1 Selección de Valores R tiene un sistema de notación que le permite extraer valores de objetos de R. Para extraer un valor o un conjunto de valores de un data frame, escriba el nombre del data frame seguido de un par de corchetes: mazo[ , ] Entre paréntesis irán dos índices separados por una coma. Los índices le dicen a R qué valores devolver. R usará el primer índice para crear un subconjunto de las filas del data frame y el segundo índice para crear un subconjunto de las columnas. Tiene una opción cuando se trata de escribir índices. Hay seis formas diferentes de escribir un índice para R, y cada una hace algo ligeramente diferente. Todas son muy simples y bastante prácticas, así que echemos un vistazo a cada una de ellas. Puede crear índices con: Enteros positivos Enteros negativos Cero Espacios en blanco Valores lógicos Nombres La forma más simple de escribir índices es la de los números enteros positivos. 6.1.1 Números Enteros Positivos R trata los enteros positivos como la notación ij en álgebra lineal: mazo[i,j] devolverá el valor de mazo que está en la iésima fila y la jésima columna, Figura ??. Tenga en cuenta que i y j solo necesitan ser números enteros en el sentido matemático. Se pueden guardar como números en R head(mazo) ## cara palo valor ## rey picas 13 ## reina picas 12 ## jota picas 11 ## diez picas 10 ## nueve picas 9 ## ocho picas 8 mazo[1, 1] ## &quot;rey&quot; Para extraer más de un valor, utilice un vector de enteros positivos. Por ejemplo, puedes devolver la primera fila de mazo con mazo[1, c(1, 2, 3)] o mazo[1, 1:3]: mazo[1, c(1, 2, 3)] ## cara palo valor ## rey picas 13 R devolverá los valores de mazo que están tanto en la primera fila como en la primera, segunda y tercera columna. Tenga en cuenta que R en realidad no eliminará estos valores de mazo. R le dará un nuevo conjunto de valores que son copias de los valores originales. Luego puede guardar este nuevo conjunto en un objeto de R con el operador de asignación de R: nuevo &lt;- mazo[1, c(1, 2, 3)] nuevo ## cara palo valor ## rey picas 13 Repetición Si repite un número en su índice, R devolverá los valores correspondientes más de una vez en su “subconjunto”. Este código devolverá la primera fila de mazo dos veces: mazo[c(1, 1), c(1, 2, 3)] ## cara palo valor ## rey picas 13 ## rey picas 13 Figure 6.1: R usa el sistema de notación ij del álgebra lineal. Los comandos de esta figura devolverán los valores sombreados. El sistema de notación de R no se limita a tramas de datos. Puede usar la misma sintaxis para seleccionar valores en cualquier objeto de R, siempre que proporcione un índice para cada dimensión del objeto. Entonces, por ejemplo, puede crear un subconjunto de un vector (que tiene una dimensión) con un solo índice: vec &lt;- c(6, 1, 3, 6, 10, 5) vec[1:3] ## 6 1 3 La indexación comienza en 1 En algunos lenguajes de programación, la indexación comienza con 0. Esto significa que 0 devuelve el primer elemento de un vector, 1 devuelve el segundo elemento y así sucesivamente. Este no es el caso con R. La indexación en R se comporta como la indexación en álgebra lineal. El primer elemento siempre está indexado por 1. ¿Por qué R es diferente? Tal vez porque fue escrito para matemáticos. Aquellos de nosotros que aprendimos a indexar en un curso de álgebra lineal nos preguntamos por qué los programadores de computadoras comienzan con 0. drop = FALSE Si selecciona dos o más columnas de un data frame, R devolverá un nuevo data frame: mazo[1:2, 1:2] ## cara palo ## rey picas ## reina picas Sin embargo, si selecciona una sola columna, R devolverá un vector: mazo[1:2, 1] ## &quot;rey&quot; &quot;reina&quot; Si prefiere un data frame, puede agregar el argumento opcional drop = FALSE entre corchetes: mazo[1:2, 1, drop = FALSE] ## cara ## rey ## reina Este método también funciona para seleccionar una sola columna de una matriz o arreglo. 6.1.2 Números Enteros Negativos Los enteros negativos hacen exactamente lo contrario de los enteros positivos al indexar. R devolverá todos los elementos excepto los elementos en un índice negativo. Por ejemplo, mazo[-1, 1:3] devolverá todo menos la primera fila de mazo. mazo[-(2:52), 1:3] devolverá la primera fila (y excluirá todo lo demás): mazo[-(2:52), 1:3] ## cara palo valor ## rey picas 13 Los enteros negativos son una forma más eficaz de crear subconjuntos que los enteros positivos si desea incluir la mayoría de las filas o columnas de un data frame. R devolverá un error si intenta emparejar un entero negativo con un entero positivo en el mismo índice: mazo[c(-1, 1), 1] ## Error in xj[i] : only 0&#39;s may be mixed with negative subscripts Sin embargo, puede usar enteros negativos y positivos para crear subconjuntos de un objeto si los usa en índices diferentes (por ejemplo, si usa uno en el índice de filas y otro en el índice de columnas, como mazo[-1, 1]) . 6.1.3 Cero ¿Qué pasaría si usaras el cero como índice? El cero no es ni un entero positivo ni un entero negativo, pero R aún lo usará para hacer un tipo de subconjunto. R no devolverá nada de una dimensión cuando use cero como índice. Esto crea un objeto vacío: mazo[0, 0] ## data frame with 0 columns and 0 rows Para ser honesto, la indexación con cero no es muy útil. 6.1.4 Espacios en Blanco Puede usar un espacio en blanco para decirle a R que extraiga todos los valores en una dimensión. Esto le permite crear subconjuntos de un objeto en una dimensión pero no en las otras, lo cual es útil para extraer filas o columnas enteras de un data frame: mazo[1, ] ## cara palo valor ## rey picas 13 6.1.5 Valores Lógicos Si proporciona un vector de TRUE y FALSE como su índice, R hará coincidir cada TRUE y FALSE con una fila en su data frame (o una columna dependiendo de dónde coloque el índice). R luego devolverá cada fila que corresponda a un TRUE, Figura 6.2. Puede ser útil imaginar a R leyendo el data frame y preguntando: “¿Debería devolver la _i_ésima fila de la estructura de datos?” y luego consultando el valor _i_ésimo del índice para su respuesta. Para que este sistema funcione, su vector debe ser tan largo como la dimensión que está tratando de dividir en subconjuntos: mazo[1, c(TRUE, TRUE, FALSE)] ## cara palo ## rey picas filas &lt;- c(TRUE, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F) mazo[filas, ] ## cara palo valor ## rey picas 13 Figure 6.2: Puede usar vectores de TRUE y FALSE para decirle a R exactamente qué valores desea extraer y cuáles no. El comando devolvería solo los números 1, 6 y 5. Este sistema puede parecer extraño, ¿quién quiere escribir tantos TRUE y FALSE?, pero se volverá muy poderoso en Modificación de Valores. 6.1.6 Nombres Finalmente, puede solicitar los elementos que desee por nombre, si su objeto tiene nombres (consulte Nombres). Esta es una forma común de extraer las columnas de un data frame, ya que las columnas casi siempre tienen nombres: mazo[1, c(&quot;cara&quot;, &quot;palo&quot;, &quot;valor&quot;)] ## cara palo valor ## rey picas 13 # toda la columna de valor mazo[ , &quot;valor&quot;] ## 13 12 11 10 9 8 7 6 5 4 3 2 1 13 12 11 10 9 8 ## 7 6 5 4 3 2 1 13 12 11 10 9 8 7 6 5 4 3 2 ## 1 13 12 11 10 9 8 7 6 5 4 3 2 1 6.2 Repartir una Carta Ahora que conoce los conceptos básicos del sistema de notación de R, pongámoslo en práctica. Ejercicio 6.1 (Repartir una Carta) Complete el siguiente código para crear una función que devuelva la primera fila de un data frame: repartir &lt;- function(cartas) { # ? } Solution. Puede usar cualquiera de los sistemas que devuelven la primera fila de su data frame para escribir una función de repartir. Usaré enteros positivos y espacios en blanco porque creo que son fáciles de entender: repartir &lt;- function(cartas) { cartas[1, ] } La función hace exactamente lo que quieres: reparte la carta superior de tu conjunto de datos. Sin embargo, la función se vuelve menos impresionante si ejecuta `repartir`` una y otra vez: repartir(mazo) ## cara palo valor ## rey picas 13 repartir(mazo) ## cara palo valor ## rey picas 13 repartir(mazo) ## cara palo valor ## rey picas 13 repartir siempre devuelve el rey de picas porque mazo no sabe que hemos repartido la carta. Por lo tanto, el rey de picas se queda donde está, en la parte superior de la baraja, listo para ser repartido nuevamente. Este es un problema difícil de resolver, y lo trataremos en Entornos. Mientras tanto, puedes solucionar el problema barajando tu mazo después de cada vez que repartes. Entonces una nueva tarjeta siempre estará en la parte superior. Barajar es un compromiso temporal: las probabilidades en juego en su mazo no coincidirán con las probabilidades que ocurren cuando juega un juego con un solo mazo de cartas. Por ejemplo, seguirá existiendo la probabilidad de que el rey de picas aparezca dos veces seguidas. Sin embargo, las cosas no son tan malas como pueden parecer. La mayoría de los casinos usan cinco o seis mazos a la vez en los juegos de cartas para evitar el conteo de cartas. Las probabilidades que encontraría en esas situaciones son muy parecidas a las que crearemos aquí. 6.3 Barajar el Mazo Cuando barajas una baraja de cartas real, reorganizas aleatoriamente el orden de las cartas. En su mazo virtual, cada carta es una fila en un data frame. Para barajar el mazo, debe reordenar aleatoriamente las filas en el data frame. Se puede hacer esto? ¡Apuesta! Y ya sabes todo lo que necesitas para hacerlo. Esto puede sonar tonto, pero comience extrayendo cada fila en su data frame: mazo2 &lt;- mazo[1:52, ] head(mazo2) ## cara palo valor ## rey picas 13 ## reina picas 12 ## jota picas 11 ## diez picas 10 ## nueve picas 9 ## ocho picas 8 ¿Qué obtienes? Un nuevo data frame cuyo orden no ha cambiado en absoluto. ¿Qué pasa si le pides a R que extraiga las filas en un orden diferente? Por ejemplo, podría pedir la fila 2, luego la fila 1 y luego el resto de las tarjetas: mazo3 &lt;- mazo[c(2, 1, 3:52), ] head(mazo3) ## cara palo valor ## reina picas 12 ## rey picas 13 ## jota picas 11 ## diez picas 10 ## nueve picas 9 ## ocho picas 8 R cumple. Obtendrá todas las filas de vuelta, y vendrán en el orden que las pida. Si desea que las filas aparezcan en un orden aleatorio, debe ordenar los números enteros del 1 al 52 en un orden aleatorio y usar los resultados como un índice de fila. ¿Cómo podrías generar una colección tan aleatoria de enteros? Con nuestra amigable función vecinal sample: aleatorio &lt;- sample(1:52, size = 52) aleatorio ## 35 28 39 9 18 29 26 45 47 48 23 22 21 16 32 38 1 15 20 ## 11 2 4 14 49 34 25 8 6 10 41 46 17 33 5 7 44 3 27 ## 50 12 51 40 52 24 19 13 42 37 43 36 31 30 mazo4 &lt;- mazo[aleatorio, ] head(mazo4) ## cara palo valor ## cinco diamantes 5 ## reina diamantes 12 ## as diamantes 1 ## cinco picas 5 ## nueve trevoles 9 ## jota diamantes 11 Ahora el nuevo conjunto está verdaderamente barajado. Terminará una vez que ajuste estos pasos en una función. Ejercicio 6.2 (Barajar el Mazo) Usa las ideas anteriores para escribir una función barajar. barajar debe tomar un data frame y devolver una copia aleatoria del data frame. Solution. Su función barajar se verá como la siguiente: barajar &lt;- function(cartas) { aleatorio &lt;- sample(1:52, size = 52) cartas[aleatorio, ] } ¡Buen trabajo! Ahora puedes barajar tus cartas entre cada vez que reparte: repartir(mazo) ## cara palo valor ## rey picas 13 mazo2 &lt;- barajar(mazo) repartir(mazo2) ## cara palo valor ## jota treboles 11 6.4 Signos de Dólar y Corchetes Dobles Dos tipos de objetos en R obedecen a un segundo sistema opcional de notación. Puede extraer valores de data frame y listas con la sintaxis $. Encontrará la sintaxis $ una y otra vez como programador de R, así que examinemos cómo funciona. Para seleccionar una columna de un data frame, escriba el nombre del data frame y el nombre de la columna separados por un $. Tenga en cuenta que no se deben colocar comillas alrededor del nombre de la columna: mazo$valor ## 13 12 11 10 9 8 7 6 5 4 3 2 1 13 12 11 10 9 8 7 ## 6 5 4 3 2 1 13 12 11 10 9 8 7 6 5 4 3 2 1 13 ## 12 11 10 9 8 7 6 5 4 3 2 1 R devolverá todos los valores de la columna como un vector. Esta notación $ es increíblemente útil porque a menudo almacenará las variables de sus conjuntos de datos como columnas en un data frame.De vez en cuando, querrá ejecutar una función como mean o median en los valores de una variable. En R, estas funciones esperan un vector de valores como entrada, y mazo$valor entrega tus datos en el formato correcto: mean(mazo$valor) ## 7 median(mazo$valor) ## 7 Puede usar la misma notación $ con los elementos de una lista, si tienen nombres. Esta notación también tiene una ventaja con las listas. Si crea subconjuntos de una lista de la manera habitual, R devolverá una lista nueva que tiene los elementos que solicitó. Esto es cierto incluso si solo solicita un solo elemento. Para ver esto, haz una lista: lst &lt;- list(numeros = c(1, 2), logicos = TRUE, caracteres = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) lst ## $numeros ## [1] 1 2 ## $logicos ## [1] TRUE ## $caracteres ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; Y luego obten el subconjunto: lst[1] ## $numeros ## [1] 1 2 El resultado es una lista más pequeña con un elemento. Ese elemento es el vector c(1, 2). Esto puede resultar molesto porque muchas funciones de R no funcionan con listas. Por ejemplo, sum(lst[1]) devolverá un error. Sería horrible si una vez que almacena un vector en una lista, solo pudiera recuperarlo como una lista: sum(lst[1]) ## Error in sum(lst[1]) : invalid &#39;type&#39; (list) of argument Cuando usa la notación $, R devolverá los valores seleccionados tal como son, sin una estructura de lista a su alrededor: lst$numeros ## 1 2 Luego puede enviar inmediatamente los resultados a una función: sum(lst$numeros) ## 3 Si los elementos de su lista no tienen nombres (o no desea usar los nombres), puede usar dos corchetes, en lugar de uno, para crear un subconjunto de la lista. Esta notación hará lo mismo que la notación $: lst[[1]] ## 1 2 En otras palabras, si crea un subconjunto de una lista con notación de corchete único, R devolverá una lista más pequeña. Si crea un subconjunto de una lista con notación de corchetes dobles, R devolverá solo los valores que estaban dentro de un elemento de la lista. Puede combinar esta función con cualquiera de los métodos de indexación de R: lst[&quot;numeros&quot;] ## $numeros ## [1] 1 2 lst[[&quot;numeros&quot;]] ## 1 2 Esta diferencia es sutil pero importante. En la comunidad de R, hay una forma popular y útil de pensar en ello, Figure 6.3. Imagina que cada lista es un tren y cada elemento es un vagón de tren. Cuando usa corchetes individuales, R selecciona vagones de tren individuales y los devuelve como un tren nuevo. Cada vagón mantiene su contenido, pero ese contenido todavía está dentro de un vagón de tren (es decir, una lista). Cuando usa corchetes dobles, R en realidad descarga el automóvil y le devuelve el contenido. Figure 6.3: Puede ser útil pensar en su lista como un tren. Use corchetes simples para seleccionar vagones de tren, corchetes dobles para seleccionar el contenido dentro de un vagón. Nunca use attach En los primeros días de R, se hizo popular usar attach() en un conjunto de datos una vez que lo tenía cargado. ¡No hagas esto! attach recrea un entorno informático similar a los utilizados en otras aplicaciones estadísticas como Stata y SPSS, que gustaron a los usuarios cruzados. Sin embargo, R no es Stata o SPSS. R está optimizado para usar el entorno informático de R, y ejecutar attach() puede causar confusión con algunas funciones de R. ¿Qué hace attach()? En la superficie, attach te ahorra escribir. Si adjunta el conjunto de datos mazo, puede hacer referencia a cada una de sus variables por nombre; en lugar de escribir mazo$cara, puedes simplemente escribir cara. Pero escribir no está mal. Te da la oportunidad de ser explícito, y en la programación de computadoras, explícito es bueno. Adjuntar un conjunto de datos crea la posibilidad de que R confunda dos nombres de variables. Si esto ocurre dentro de una función, es probable que obtenga resultados inutilizables y un mensaje de error inútil para explicar lo que sucedió. Ahora que es un experto en recuperar valores almacenados en R, resumamos lo que ha logrado. 6.5 Resumen Ha aprendido a acceder a los valores que se han almacenado en R. Puede recuperar una copia de los valores que viven dentro de un data frame y usar las copias para nuevos cálculos. De hecho, puede usar el sistema de notación de R para acceder a valores en cualquier objeto R. Para usarlo, escriba el nombre de un objeto seguido de corchetes e índices. Si su objeto es unidimensional, como un vector, solo necesita proporcionar un índice. Si es bidimensional, como un data frame, debe proporcionar dos índices separados por una coma. Y, si es n-dimensional, debe proporcionar n índices, cada uno separado por una coma. En Modificación de Valores, llevará este sistema un paso más allá y aprenderá a cambiar los valores reales que se almacenan dentro de su data frame. Todo esto se suma a algo especial: control completo de sus datos. Ahora puede almacenar sus datos en su computadora, recuperar valores individuales a voluntad y usar su computadora para realizar cálculos correctos con esos valores. ¿Suena esto básico? Puede serlo, pero también es poderoso y esencial para una ciencia de datos eficiente. Ya no necesitas memorizar todo en tu cabeza, ni preocuparte por hacer mal el cálculo mental. Este control de bajo nivel sobre sus datos también es un requisito previo para programas de R más eficientes, el tema del Proyecto 3: Máquina Tragamonedas. "],["modify.html", "7 Modificación de Valores", " 7 Modificación de Valores ¿Estás listo para jugar algunos juegos con tu mazo virtual? ¡No tan rápido! El sistema de puntos en su mazo de cartas no se alinea bien con muchos juegos de cartas. Por ejemplo, en la guerra y el póquer, los ases suelen tener una puntuación más alta que los reyes. Tendrían un valor en puntos de 14, no de 1. En esta tarea, cambiará el sistema de puntos de su mazo tres veces para que coincida con tres juegos diferentes: guerra, corazones y blackjack. Cada uno de estos juegos te enseñará algo diferente sobre cómo modificar los valores dentro de un conjunto de datos. Comience por hacer una copia de mazo que pueda manipular. Esto asegurará que siempre tenga una copia impecable de mazo a la que recurrir (en caso de que las cosas salgan mal): mazo2 &lt;- mazo 7.0.1 Cambio de Valores en el Lugar Puede usar el sistema de notación de R para modificar valores dentro de un objeto de R. Primero, describa el valor (o valores) que desea modificar. Luego use el operador de asignación &lt;- para sobrescribir esos valores. R actualizará los valores seleccionados en el objeto original. Pongamos esto en práctica con un ejemplo real: vec &lt;- c(0, 0, 0, 0, 0, 0) vec ## 0 0 0 0 0 0 Así es como puede seleccionar el primer valor de vec: vec[1] ## 0 Y así es como puedes modificarlo: vec[1] &lt;- 1000 vec ## 1000 0 0 0 0 0 Puede reemplazar varios valores a la vez siempre que la cantidad de valores nuevos sea igual a la cantidad de valores seleccionados: vec[c(1, 3, 5)] &lt;- c(1, 1, 1) vec ## 1 0 1 0 1 0 vec[4:6] &lt;- vec[4:6] + 1 vec ## 1 0 1 1 2 1 También puede crear valores que aún no existen en su objeto. R expandirá el objeto para acomodar los nuevos valores: vec[7] &lt;- 0 vec ## 1 0 1 1 2 1 0 Esto proporciona una excelente manera de agregar nuevas variables a su conjunto de datos: mazo2$nuevo &lt;- 1:52 head(mazo2) ## cara palo valor nuevo ## rey picas 13 1 ## reina picas 12 2 ## jota picas 11 3 ## diez picas 10 4 ## nueve picas 9 5 ## ocho picas 8 6 También puede eliminar columnas de un data frame (y elementos de una lista) asignándoles el símbolo NULL: mazo2$nuevo &lt;- NULL head(mazo2) ## cara palo valor ## rey picas 13 ## reina picas 12 ## jota picas 11 ## diez picas 10 ## nueve picas 9 ## ocho picas 8 En el juego de la guerra, los ases son el rey (en sentido figurado). Reciben el valor más alto de todas las cartas, que sería algo así como 14. Todas las demás cartas obtienen el valor que ya tienen en el mazo. Para jugar a la guerra, solo necesitas cambiar los valores de tus ases del 1 al 14. Siempre que no hayas barajado tu mazo, sabes dónde están los ases. Aparecen cada 13 cartas. Por lo tanto, puede describirlos con el sistema de notación de R: mazo2[c(13, 26, 39, 52), ] ## cara palo valor ## as picas 1 ## as treboles 1 ## as diamantes 1 ## as corazones 1 Puede seleccionar solo los valores de los ases subdividiendo la dimensión de las columnas de mazo2. O, mejor aún, puede crear un subconjunto del vector de columna mazo2$valor: mazo2[c(13, 26, 39, 52), 3] ## 1 1 1 1 mazo2$valor[c(13, 26, 39, 52)] ## 1 1 1 1 Ahora todo lo que tiene que hacer es asignar un nuevo conjunto de valores a estos valores antiguos. El conjunto de valores nuevos deberá tener el mismo tamaño que el conjunto de valores que está reemplazando. Por lo tanto, podría guardar c(14, 14, 14, 14) en los valores as, o simplemente podría guardar 14 y confiar en las reglas de reciclaje de R para expandir 14 a c(14, 14, 14, 14): mazo2$valor[c(13, 26, 39, 52)] &lt;- c(14, 14, 14, 14) # or mazo2$valor[c(13, 26, 39, 52)] &lt;- 14 Observe que los valores cambian en su lugar. No terminas con una copia modificada de mazo2; los nuevos valores aparecerán dentro de mazo2: head(mazo2, 13) ## cara palo valor ## rey picas 13 ## reina picas 12 ## jota picas 11 ## diez picas 10 ## nueve picas 9 ## ocho picas 8 ## siete picas 7 ## seis picas 6 ## cinco picas 5 ## cuatro picas 4 ## tres picas 3 ## dos picas 2 ## as picas 14 La misma técnica funcionará ya sea que almacene sus datos en un vector, matriz, arreglo, lista o data frame. Simplemente describa los valores que desea cambiar con el sistema de notación de R, luego asigne sobre esos valores con el operador de asignación de R. Las cosas funcionaron muy fácilmente en este ejemplo porque sabías exactamente dónde estaba cada as. Las cartas se ordenaron de manera ordenada y apareció un as cada 13 filas. Pero, ¿y si se hubiera barajado la baraja? Podrías mirar todas las cartas y anotar las ubicaciones de los ases, pero eso sería tedioso. Si su data frame fuera más grande, podría ser imposible: mazo3 &lt;- barajar(mazo) ¿Dónde están los ases ahora? head(mazo3) ## cara palo valor ## reina treboles 12 ## rey treboles 13 ## as picas 1 # un as ## nueve treboles 9 ## siete picas 7 ## reina diamantes 12 ¿Por qué no pedirle a R que encuentre los ases por ti? Puede hacer esto con subconjuntos lógicos. La creación de subconjuntos lógicos proporciona una forma de realizar una extracción y modificación específicas con objetos R, una especie de misión de búsqueda y destrucción dentro de sus propios conjuntos de datos. 7.0.2 Subconjunto Lógico ¿Recuerdas el sistema de índice lógico de R, lógicos? Para recapitular, puede seleccionar valores con un vector de TRUE y FALSE. El vector debe tener la misma longitud que la dimensión que desea dividir en subconjuntos. R devolverá todos los elementos que coincidan con un VERDADERO: vec ## 1 0 1 1 2 1 0 vec[c(FALSE, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE)] ## 2 A primera vista, este sistema puede parecer poco práctico. ¿Quién quiere escribir largos vectores de TRUE y FALSE? Nadie. Pero no tienes que hacerlo. Puede dejar que una prueba lógica cree un vector de VERDADEROS y FALSOS para usted. 7.0.2.1 Pruebas Lógicas Una prueba lógica es una comparación como “¿es uno menos que dos?”, 1 &lt; 2 o “¿tres son mayores que cuatro?”, 3 &gt; 4. R proporciona siete operadores lógicos que puede usar para hacer comparaciones, que se muestran en la tabla 7.1. Table 7.1: Operadores Lógicos de R Operador Sintaxis Pruebas &gt; a &gt; b ¿Es a mayor que b? &gt;= a &gt;= b ¿Es a mayor que o igual que b? &lt; a &lt; b ¿Es a menor que b? &lt;= a &lt;= b ¿Es a menor que o igual que b? == a == b ¿Es a igual que b? != a != b ¿Es a distinto que b? %in% a %in% c(a, b, c) ¿Es a en el grupo c(a, b, c)? Cada operador devuelve un TRUE o un FALSE. Si usa un operador para comparar vectores, R hará comparaciones por elementos, tal como lo hace con los operadores aritméticos: 1 &gt; 2 ## FALSE 1 &gt; c(0, 1, 2) ## TRUE FALSE FALSE c(1, 2, 3) == c(3, 2, 1) ## FALSE TRUE FALSE %in% es el único operador que no realiza una ejecución normal de elementos. %in% comprueba si los valores del lado izquierdo están en el vector del lado derecho. Si proporciona un vector en el lado izquierdo, %in% no emparejará los valores de la izquierda con los valores de la derecha y luego realizará pruebas por elementos. En su lugar, %in% probará de forma independiente si cada valor de la izquierda está en algún lugar en el vector de la derecha: 1 %in% c(3, 4, 5) ## FALSE c(1, 2) %in% c(3, 4, 5) ## FALSE FALSE c(1, 2, 3) %in% c(3, 4, 5) ## FALSE FALSE TRUE c(1, 2, 3, 4) %in% c(3, 4, 5) ## FALSE FALSE TRUE TRUE Tenga en cuenta que comprueba la igualdad con un signo igual doble, ==, y no con un solo signo igual, =, que es otra forma de escribir &lt;-. Es fácil olvidar y usar a = b para probar si a es igual a b. Desafortunadamente, te llevarás una desagradable sorpresa. R no devolverá un TRUE o FALSE, porque no tendrá que hacerlo: a será igual a b, porque acabas de ejecutar el equivalente de a &lt;- b. = es un operador de asignación Tenga cuidado de no confundir = con ==. = hace lo mismo que &lt;-: asigna un valor a un objeto. Puede comparar dos objetos R cualquiera con un operador lógico; sin embargo, los operadores lógicos tienen más sentido si compara dos objetos del mismo tipo de datos. Si compara objetos de diferentes tipos de datos, R usará sus reglas de coerción para forzar los objetos al mismo tipo antes de realizar la comparación. Ejercicio 7.1 ¿Cuántas ases? Extraiga la columna cara de mazo2 y pruebe si cada valor es igual a as. Como desafío, use R para contar rápidamente cuántas cartas son iguales a as. Solution. Puede extraer la columna cara con la notación $ de R: mazo2$cara ## &quot;rey&quot; &quot;reina&quot; &quot;jota&quot; &quot;diez&quot; &quot;nueve&quot; ## &quot;ocho&quot; &quot;siete&quot; &quot;seis&quot; &quot;cinco&quot; &quot;cuatro&quot; ## &quot;tres&quot; &quot;dos&quot; &quot;as&quot; &quot;rey&quot; &quot;reina&quot; ## &quot;jota&quot; &quot;diez&quot; &quot;nueve&quot; &quot;ocho&quot; &quot;siete&quot; ## &quot;seis&quot; &quot;cinco&quot; &quot;cuatro&quot; &quot;tres&quot; &quot;dos&quot; ## &quot;as&quot; &quot;rey&quot; &quot;reina&quot; &quot;jota&quot; &quot;diez&quot; ## &quot;nueve&quot; &quot;ocho&quot; &quot;siete&quot; &quot;seis&quot; &quot;cinco&quot; ## &quot;cuatro&quot; &quot;tres&quot; &quot;dos&quot; &quot;as&quot; &quot;rey&quot; ## &quot;reina&quot; &quot;jota&quot; &quot;diez&quot; &quot;nueve&quot; &quot;ocho&quot; ## &quot;siete&quot; &quot;seis&quot; &quot;cinco&quot; &quot;cuatro&quot; &quot;tres&quot; ## &quot;dos&quot; &quot;as&quot; A continuación, puede utilizar el operador == para probar si cada valor es igual a as. En el siguiente código, R usará sus reglas de reciclaje para comparar individualmente cada valor de mazo2$cara con \"as\". Tenga en cuenta que las comillas son importantes. Si los omite, R intentará encontrar un objeto llamado as para compararlo con mazo2$cara: mazo2$cara == &quot;as&quot; ## FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## FALSE FALSE FALSE FALSE FALSE TRUE FALSE ## FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## FALSE FALSE FALSE FALSE TRUE FALSE FALSE ## FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## FALSE FALSE FALSE TRUE FALSE FALSE FALSE ## FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## FALSE FALSE TRUE Puede usar sum para contar rápidamente el número de TRUE en el vector anterior. Recuerde que R convertirá los lógicos en numéricos cuando haga operaciones matemáticas con ellos. R convertirá TRUE en unos y FALSE en ceros. Como resultado, sum contará el número de TRUE: sum(mazo2$cara == &quot;as&quot;) ## 4 Puede usar este método para detectar y luego cambiar los ases en su mazo, incluso si ha barajado sus cartas. Primero, crea una prueba lógica que identifique los ases en tu baraja barajada: mazo3$cara == &quot;as&quot; Luego use la prueba para seleccionar los valores de puntos as. Dado que la prueba devuelve un vector lógico, puede usarlo como índice: mazo3$valor[mazo3$cara == &quot;as&quot;] ## 1 1 1 1 Finalmente, usa la asignación para cambiar los valores de as en mazo3: mazo3$valor[mazo3$cara == &quot;as&quot;] &lt;- 14 head(mazo3) ## cara palo valor ## queen treboles 12 ## rey treboles 13 ## as picas 14 # un as ## nueve treboles 9 ## siete picas 7 ## reina diamantes 12 Para resumir, puede usar una prueba lógica para seleccionar valores dentro de un objeto. La creación de subconjuntos lógicos es una técnica poderosa porque le permite identificar, extraer y modificar rápidamente valores individuales en su conjunto de datos. Cuando trabaja con subconjuntos lógicos, no necesita saber dónde en su conjunto de datos existe un valor. Solo necesita saber cómo describir el valor con una prueba lógica. El subconjunto lógico es una de las cosas que R hace mejor. De hecho, el subconjunto lógico es un componente clave de la programación vectorizada, un estilo de codificación que le permite escribir código R rápido y eficiente, que estudiaremos en Velocidad. Usemos subconjuntos lógicos con un nuevo juego: corazones. En corazones, cada carta tiene un valor de cero: mazo4 &lt;- mazo mazo4$valor &lt;- 0 head(mazo4, 13) ## cara palo valor ## rey picas 0 ## reina picas 0 ## jota picas 0 ## diez picas 0 ## nueve picas 0 ## ocho picas 0 ## siete picas 0 ## seis picas 0 ## cinco picas 0 ## cuatro picas 0 ## tres picas 0 ## dos picas 0 ## as picas 0 excepto las cartas del palo de corazones y la reina de picas. Cada carta del palo de corazones tiene un valor de 1. ¿Puedes encontrar estas cartas y reemplazar sus valores? Intentalo. Ejercicio 7.2 (Dar Valor al Mazo para el Juego Corazones) Asigne un valor de 1 a cada carta en mazo4 que tenga un palo de corazones. Solution. Para hacer esto, primero escribe una prueba que identifique las cartas en el palo corazones: mazo4$palo == &quot;corazones&quot; ## FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## FALSE FALSE FALSE FALSE TRUE TRUE TRUE ## TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## TRUE TRUE TRUE Luego usa tu prueba para seleccionar los valores de estas cartas: mazo4$valor[mazo4$palo == &quot;corazones&quot;] ## 0 0 0 0 0 0 0 0 0 0 0 0 0 Finalmente, asigne un nuevo número a estos valores: mazo4$valor[mazo4$palo == &quot;corazones&quot;] &lt;- 1 Ahora todas sus cartas de corazones han sido actualizadas: mazo4$valor[mazo4$palo == &quot;corazones&quot;] ## 1 1 1 1 1 1 1 1 1 1 1 1 1 En corazones, la reina de picas tiene el valor más inusual de todos: vale 13 puntos. Debería ser sencillo cambiar su valor, pero es sorprendentemente difícil de encontrar. Podrías encontrar todas las reinas: mazo4[mazo4$cara == &quot;reina&quot;, ] ## cara palo valor ## reina picas 0 ## reina treboles 0 ## reina diamantes 0 ## reina corazones 1 Pero son tres cartas de más. Por otro lado, podrías encontrar todas las cartas en picas: mazo4[mazo4$palo == &quot;picas&quot;, ] ## cara palo valor ## rey picas 0 ## reina picas 0 ## jota picas 0 ## diez picas 0 ## nueve picas 0 ## ocho picas 0 ## siete picas 0 ## seis picas 0 ## cinco picas 0 ## cuatro picas 0 ## tres picas 0 ## dos picas 0 ## as picas 0 Pero son 12 cartas de más. Lo que realmente quiere encontrar es todas las cartas que tienen un valor de cara igual a la reina y un valor del palo igual a las picas. Puede hacerlo con un operador booleano. Los operadores booleanos combinan varias pruebas lógicas en una sola prueba. 7.0.2.2 Operadores Booleanos Los operadores booleanos son cosas como y (&amp;) y o (|). Colapsan los resultados de múltiples pruebas lógicas en un solo TRUE o FALSE. R tiene seis operadores booleanos, que se muestran en la tabla 7.2. Table 7.2: Operadores Booleanos Operador Sintaxis Pruebas &amp; cond1 &amp; cond2 ¿Son verdaderas cond1 y cond2? | cond1 | cond2 ¿Es verdadera una o más de cond1 ycond2? xor xor(cond1, cond2) ¿Es exactamente una de cond1 y cond2 verdadera? ! !cond1 ¿Es cond1 falsa? (por ejemplo, ! invierte los resultados de una prueba lógica) any any(cond1, cond2, cond3, ...) ¿Alguna de las condiciones es verdadera? all all(cond1, cond2, cond3, ...) ¿Son verdaderas todas las condiciones? Para usar un operador booleano, colóquelo entre dos pruebas lógicas completas. R ejecutará cada prueba lógica y luego usará el operador booleano para combinar los resultados en un solo TRUE o FALSE, figura 7.1. El error más común con los operadores Booleanos Es fácil olvidar poner una prueba completa a cada lado de un operador booleano. En español, es eficiente decir “¿Es x mayor que dos y menor que nueve?” Pero en R, necesitas escribir el equivalente de “¿Es x mayor que dos y es x menor que nueve?” Esto se muestra en la Figura 7.1. Figure 7.1: R evaluará las expresiones en cada lado de un operador booleano por separado y luego combinará los resultados en un solo TRUE o FALSE. Si no proporciona una prueba completa a cada lado del operador, R devolverá un error. Cuando se usan con vectores, los operadores booleanos seguirán la misma ejecución de elementos que los operadores aritméticos y lógicos: a &lt;- c(1, 2, 3) b &lt;- c(1, 2, 3) c &lt;- c(1, 2, 4) a == b ## TRUE TRUE TRUE b == c ## TRUE TRUE FALSE a == b &amp; b == c ## TRUE TRUE FALSE ¿Podría usar un operador booleano para ubicar la reina de picas en su mazo? Por supuesto que puede. Desea probar cada carta para ver si es tanto una reina como una pica. Puedes escribir esta prueba en R con: mazo4$cara == &quot;reina&quot; &amp; mazo4$palo == &quot;picas&quot; ## FALSE TRUE FALSE FALSE FALSE FALSE FALSE ## FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## FALSE FALSE FALSE Guardaré los resultados de esta prueba en su propio objeto. Eso hará que sea más fácil trabajar con los resultados: reinaDePicas &lt;- mazo4$cara == &quot;reina&quot; &amp; mazo4$palo == &quot;picas&quot; A continuación, puede utilizar la prueba como índice para seleccionar el valor de la reina de picas. Asegúrese de que la prueba realmente seleccione el valor correcto: mazo4[reinaDePicas, ] ## cara palo valor ## reina picas 0 mazo4$valor[reinaDePicas] ## 0 Ahora que encontraste la reina de picas, puedes actualizar su valor: mazo4$valor[reinaDePicas] &lt;- 13 mazo4[reinaDePicas, ] ## cara palo valor ## reina picas 13 Tu mazo está listo para jugar corazones. Ejercicio 7.3 (Practica con Pruebas) Si cree que domina las pruebas lógicas, intente convertir estas oraciones en pruebas escritas con código R. Para ayudarte, he definido algunos objetos de R después de las oraciones que puedes usar para probar tus respuestas: ¿Es w positivo? ¿Es x mayor que 10 y menor que 20? ¿Es objeto y la palabra Febrero? ¿Son todos los valores de z un día de la semana? w &lt;- c(-1, 0, 1) x &lt;- c(5, 15) y &lt;- &quot;Febrero&quot; z &lt;- c(&quot;Lunes&quot;, &quot;Martes&quot;, &quot;Viernes&quot;) Solution. Aquí hay algunas respuestas de ejemplo. Si se quedó atascado, asegúrese de volver a leer cómo R evalúa las pruebas lógicas que usan valores booleanos: w &gt; 0 10 &lt; x &amp; x &lt; 20 y == &quot;Febrero&quot; all(z %in% c(&quot;Lunes&quot;, &quot;Martes&quot;, &quot;Miercoles&quot;, &quot;Jueves&quot;, &quot;Viernes&quot;, &quot;Sabado&quot;, &quot;Domingo&quot;)) Consideremos un último juego, el blackjack. En el blackjack, cada carta numérica tiene un valor igual a su valor nominal. Cada figura (rey, reina o jota) tiene un valor de 10. Finalmente, cada as tiene un valor de 11 o 1, dependiendo de los resultados finales del juego. Comencemos con una copia nueva de mazo; de esa manera, las cartas numéricas (dos a diez) comenzarán con el valor correcto: mako5 &lt;- mazo head(mazo5, 13) ## rey picas 13 ## reina picas 12 ## jota picas 11 ## diez picas 10 ## nueve picas 9 ## ocho picas 8 ## siete picas 7 ## seis picas 6 ## cinco picas 5 ## cuatro picas 4 ## tres picas 3 ## dos picas 2 ## as picas 1 Puedes cambiar el valor de las figuras de una sola vez con %in%: caracartas &lt;- mazo5$cara %in% c(&quot;rey&quot;, &quot;reina&quot;, &quot;jota&quot;) mazo5[caracartas, ] ## cara palo valor ## rey picas 13 ## reina picas 12 ## jota picas 11 ## rey treboles 13 ## reina treboles 12 ## jota treboles 11 ## rey diamantes 13 ## reina diamantes 12 ## jota diamantes 11 ## rey corazones 13 ## reina corazones 12 ## jota corazones 11 mazo5$valor[caracartas] &lt;- 10 head(mazo5, 13) ## cara palo valor ## rey picas 10 ## reina picas 10 ## jota picas 10 ## diez picas 10 ## nueve picas 9 ## ocho picas 8 ## siete picas 7 ## seis picas 6 ## cinco picas 5 ## cuatro picas 4 ## tres picas 3 ## dos picas 2 ## as picas 1 Ahora solo necesita corregir los valores de as, ¿o no? Es difícil decidir qué valor dar a los ases porque su valor exacto cambiará de una mano a otra. Al final de cada mano, un as será igual a 11 si la suma de las cartas del jugador no supera los 21. De lo contrario, el as será igual a 1. El valor real del as dependerá de las otras cartas en la mano del jugador. Este es un caso de falta de información. Por el momento, no tiene suficiente información para asignar un valor de puntos correcto a las cartas de as. 7.0.3 Información Faltante Los problemas de falta de información ocurren con frecuencia en la ciencia de datos. Por lo general, son más sencillos: no conoce un valor porque la medida se perdió, se corrompió o nunca se tomó para empezar. R tiene una manera de ayudarlo a administrar estos valores faltantes. El carácter NA es un símbolo especial en R. Significa “no disponible” y se puede utilizar como marcador de posición para la información que falta. R tratará a NA exactamente como usted debería querer que se trate la información faltante. Por ejemplo, ¿qué resultado esperaría si suma 1 a la información que falta? 1 + NA ## NA R devolverá una segunda pieza de información faltante. No sería correcto decir que 1 + NA = 1 porque existe una buena posibilidad de que la cantidad que falta no sea cero. No tienes suficiente información para determinar el resultado. ¿Qué pasa si prueba si una parte de la información que falta es igual a 1? NA == 1 ## NA Nuevamente, su respuesta sería algo como “No sé si esto es igual a uno”, es decir, NA. Generalmente, los NA se propagarán cada vez que los use en una operación o función de R. Esto puede evitar que cometa errores basados en datos faltantes. 7.0.3.1 na.rm Los valores faltantes pueden ayudarlo a solucionar los agujeros en sus conjuntos de datos, pero también pueden crear algunos problemas frustrantes. Suponga, por ejemplo, que ha recopilado 1.000 pases:[observaciones] y desea tomar su promedio con la función mean de R. Si incluso uno de los valores es NA, su resultado será NA: c(NA, 1:50) ## NA 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ## 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ## 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 mean(c(NA, 1:50)) ## NA Es comprensible que prefieras un comportamiento diferente. La mayoría de las funciones de R vienen con el argumento opcional, na.rm, que significa remove los NA. R ignorará NAs cuando evalúa una función si agrega el argumento na.rm = TRUE: mean(c(NA, 1:50), na.rm = TRUE) ## 25.5 7.0.3.2 is.na En ocasiones, es posible que desee identificar las NA en su conjunto de datos con una prueba lógica, pero eso también crea un problema. ¿Cómo lo harías? Si algo es un valor faltante, cualquier prueba lógica que lo use devolverá un valor faltante, incluso esta prueba: NA == NA ## NA Lo que significa que pruebas como esta no te ayudarán a encontrar valores faltantes: c(1, 2, 3, NA) == NA ## NA NA NA NA Pero no te preocupes demasiado; R proporciona una función especial que puede probar si un valor es un NA. La función se llama sensatamente is.na: is.na(NA) ## TRUE vec &lt;- c(1, 2, 3, NA) is.na(vec) ## FALSE FALSE FALSE TRUE Establezcamos todos sus valores de as en NA. Esto logrará dos cosas. Primero, te recordará que no sabes el valor final de cada as. En segundo lugar, evitará que anotes accidentalmente una mano que tenga un as antes de determinar el valor final del as. Puede establecer sus valores de as en NA de la misma manera que los establecería en un número: mazo5$valor[mazo5$cara == &quot;as&quot;] &lt;- NA head(mazo5, 13) ## cara palo valor ## rey picas 10 ## reina picas 10 ## jota picas 10 ## diez picas 10 ## nueve picas 9 ## ocho picas 8 ## siete picas 7 ## seis picas 6 ## cinco picas 5 ## cuatro picas 4 ## tres picas 3 ## dos picas 2 ## as picas NA Felicidades. Su mazo ahora está listo para un juego de blackjack. 7.0.4 Resumen Puede modificar valores en su lugar dentro de un objeto de R cuando combina la sintaxis de notación de R con el operador de asignación, &lt;-. Esto le permite actualizar sus datos y limpiar sus conjuntos de datos. Cuando trabaja con grandes conjuntos de datos, modificar y recuperar valores crea un problema logístico propio. ¿Cómo puede buscar en los datos para encontrar los valores que desea modificar o recuperar? Como usuario de R, puede hacer esto con subconjuntos lógicos. Cree una prueba lógica con operadores lógicos y booleanos y luego use la prueba como un índice en la notación de paréntesis de R. R devolverá los valores que está buscando, incluso si no sabe dónde están. Recuperar valores individuales no será su única preocupación como programador de R. También deberá recuperar conjuntos de datos completos; por ejemplo, puede llamar a uno en una función. Entornos le enseñará cómo R busca y guarda conjuntos de datos y otros objetos R en su sistema de entorno. Luego usará este conocimiento para corregir las funciones repartir y barajar. "],["environment.html", "8 Entornos 8.1 Entornos 8.2 Trabajar con Entornos 8.3 Reglas de Alcance 8.4 Asignación 8.5 Evaluación 8.6 Cierres 8.7 Resumen 8.8 Resumen del Proyecto 2", " 8 Entornos Su mazo ahora está listo para un juego de blackjack (o de corazones o de guerra), pero ¿sus funciones de barajar y repartir están a la altura? Definitivamente no. Por ejemplo, repartir reparte la misma carta una y otra vez: repartir(mazo) ## cara palo valor ## rey picas 13 repartir(mazo) ## cara palo valor ## rey picas 13 repartir(mazo) ## cara palo valor ## rey picas 13 Y la función barajar en realidad no baraja el mazo (devuelve una copia del mazo que se ha barajado). En resumen, ambas funciones usan mazo, pero ninguna manipula mazo, y nos gustaría que lo hicieran. Para corregir estas funciones, deberá aprender cómo R almacena, busca y manipula objetos como mazo. R hace todas estas cosas con la ayuda de un sistema de entorno. 8.1 Entornos Considere por un momento cómo su computadora almacena archivos. Cada archivo se guarda en una carpeta y cada carpeta se guarda en otra carpeta, lo que forma un sistema de archivos jerárquico. Si su computadora quiere abrir un archivo, primero debe buscar el archivo en este sistema de archivos. Puede ver su sistema de archivos abriendo una ventana del buscador. Por ejemplo, la figura 8.1 muestra parte del sistema de archivos de mi computadora. Tengo toneladas de carpetas. Dentro de uno de ellos hay una subcarpeta llamada Documentos, dentro de esa subcarpeta hay una subsubcarpeta llamada ggsubplot, dentro de esa carpeta hay una carpeta llamada inst, dentro de esa subcarpeta hay una carpeta llamada doc, y dentro de eso hay un archivo llamado manual .pdf. Figure 8.1: Su computadora organiza los archivos en una jerarquía de carpetas y subcarpetas. Para mirar un archivo, necesita encontrar dónde está guardado en el sistema de archivos. R usa un sistema similar para guardar objetos de R. Cada objeto se guarda dentro de un entorno, un objeto similar a una lista que se asemeja a una carpeta en su computadora. Cada entorno está conectado a un entorno principal, un entorno de nivel superior, que crea una jerarquía de entornos. Puede ver el sistema de entorno de R con la función parenvs en el paquete pryr (tenga en cuenta que parenvs venía en el paquete pryr cuando este libro se publicó por primera vez). parenvs(all = TRUE) devolverá una lista de los entornos que utiliza su sesión de R. El resultado real variará de una sesión a otra según los paquetes que haya cargado. Aquí está el resultado de mi sesión actual: library(pryr) parenvs(all = TRUE) ## label name ## 1 &lt;environment: R_GlobalEnv&gt; &quot;&quot; ## 2 &lt;environment: package:pryr&gt; &quot;package:pryr&quot; ## 3 &lt;environment: 0x7fff3321c388&gt; &quot;tools:rstudio&quot; ## 4 &lt;environment: package:stats&gt; &quot;package:stats&quot; ## 5 &lt;environment: package:graphics&gt; &quot;package:graphics&quot; ## 6 &lt;environment: package:grDevices&gt; &quot;package:grDevices&quot; ## 7 &lt;environment: package:utils&gt; &quot;package:utils&quot; ## 8 &lt;environment: package:datasets&gt; &quot;package:datasets&quot; ## 9 &lt;environment: package:methods&gt; &quot;package:methods&quot; ## 10 &lt;environment: 0x7fff3193dab0&gt; &quot;Autoloads&quot; ## 11 &lt;environment: base&gt; &quot;&quot; ## 12 &lt;environment: R_EmptyEnv&gt; &quot;&quot; Se necesita algo de imaginación para interpretar este resultado, así que visualicemos los entornos como un sistema de carpetas, Figura 8.2. Puedes pensar en el árbol del entorno de esta manera. El entorno de nivel más bajo se llama R_GlobalEnv y se guarda dentro de un entorno llamado package:pryr, que se guarda dentro del entorno llamado 0x7fff3321c388, y así sucesivamente, hasta llegar al entorno final de más alto nivel. R_EmptyEnv. R_EmptyEnv es el único entorno de R que no tiene un entorno principal. Figure 8.2: R almacena objetos de R en un árbol de entorno que se asemeja al sistema de carpetas de su computadora. Recuerde que este ejemplo es solo una metáfora. Los entornos de R existen en su memoria RAM y no en su sistema de archivos. Además, los entornos de R técnicamente no se guardan uno dentro de otro. Cada entorno está conectado a un entorno principal, lo que facilita la búsqueda en el árbol de entornos de R. Pero esta conexión es unidireccional: no hay forma de mirar un entorno y decir cuáles son sus “hijos”. Por lo tanto, no puede buscar en el árbol de entorno de R. Sin embargo, en otras formas, el sistema de entorno de R funciona de manera similar a un sistema de archivos. 8.2 Trabajar con Entornos R viene con algunas funciones de ayuda que puede usar para explorar su árbol de entorno. Primero, puede referirse a cualquiera de los entornos en su árbol con as.environment. as.environment toma un nombre de entorno (como una cadena de caracteres) y devuelve el entorno correspondiente: as.environment(&quot;package:stats&quot;) ## &lt;environment: package:stats&gt; ## attr(,&quot;name&quot;) ## [1] &quot;package:stats&quot; ## attr(,&quot;path&quot;) ## [1] &quot;/Library/Frameworks/R.framework/Versions/3.0/Resources/library/stats&quot; Tres entornos en su árbol también vienen con sus propias funciones de acceso. Estos son el entorno global (R_GlobalEnv), el entorno base (base) y el entorno vacío (R_EmptyEnv). Puedes referirte a ellos con: globalenv() ## &lt;environment: R_GlobalEnv&gt; baseenv() ## &lt;environment: base&gt; emptyenv() ##&lt;environment: R_EmptyEnv&gt; A continuación, puede buscar el padre de un entorno con parent.env: parent.env(globalenv()) ## &lt;environment: package:pryr&gt; ## attr(,&quot;name&quot;) ## [1] &quot;package:pryr&quot; ## attr(,&quot;path&quot;) ## [1] &quot;/Library/Frameworks/R.framework/Versions/3.0/Resources/library/pryr&quot; Tenga en cuenta que el entorno vacío es el único entorno R sin padre: parent.env(emptyenv()) ## Error in parent.env(emptyenv()) : the empty environment has no parent Puede ver los objetos guardados en un entorno con ls o ls.str. ls devolverá solo los nombres de los objetos, pero ls.str mostrará un poco sobre la estructura de cada objeto: ls(emptyenv()) ## character(0) ls(globalenv()) ## &quot;ahora&quot; &quot;barajar&quot; &quot;dado&quot; &quot;genero&quot; &quot;lst&quot; &quot;mano&quot; ## &quot;mazo&quot; &quot;mazo2&quot; &quot;mazo3&quot; &quot;mazo4&quot; &quot;mazo5&quot; &quot;millon&quot; ## &quot;nuevo&quot; &quot;repartir&quot; &quot;vec&quot; El entorno vacío es, como es lógico, vacío; el entorno base tiene demasiados objetos para enumerarlos aquí; y el entorno global tiene algunas caras conocidas. Es donde R ha guardado todos los objetos que ha creado hasta ahora. El panel de Global Environment de RStudio muestra todos los objetos en su entorno global. Puede usar la sintaxis $ de R para acceder a un objeto en un entorno específico. Por ejemplo, puedes acceder a mazo desde el entorno global: head(globalenv()$mazo, 3) ## cara palo valor ## rey picas 13 ## reina picas 12 ## jota picas 11 Y puede usar la función assign para guardar un objeto en un entorno particular. Primero dale a assign el nombre del nuevo objeto (como una cadena de caracteres). Luego dale a assign el valor del nuevo objeto, y finalmente el entorno para guardar el objeto: assign(&quot;nuevo&quot;, &quot;Hola Global&quot;, envir = globalenv()) globalenv()$nuevo ## &quot;Hola Global&quot; Tenga en cuenta que assign funciona de forma similar a &lt;-. Si un objeto ya existe con el nombre dado en el entorno dado, assign lo sobrescribirá sin pedir permiso. Esto hace que assign sea útil para actualizar objetos. Ahora que puede explorar el árbol de entorno de R, examinemos cómo lo usa R. R trabaja en estrecha colaboración con el árbol del entorno para buscar objetos, almacenar objetos y evaluar funciones. La forma en que R realice cada una de estas tareas dependerá del entorno activo actual. 8.2.1 El Entorno Activo En cualquier momento, R está trabajando en estrecha colaboración con un solo entorno. R almacenará nuevos objetos en este entorno (si crea alguno), y R utilizará este entorno como punto de partida para buscar objetos existentes (si llama a alguno). Llamaré a este entorno especial el entorno activo. El entorno activo suele ser el entorno global, pero esto puede cambiar cuando ejecuta una función. Puede usar environment para ver el entorno activo actual: environment() &lt;environment: R_GlobalEnv&gt; El entorno global juega un papel especial en R. Es el entorno activo para cada comando que ejecuta en la línea de comandos. Como resultado, cualquier objeto que cree en la línea de comandos se guardará en el entorno global. Puede pensar en el entorno global como su espacio de trabajo de usuario. Cuando llama a un objeto en la línea de comando, R lo buscará primero en el entorno global. Pero, ¿y si el objeto no está allí? En ese caso, R seguirá una serie de reglas para buscar el objeto. 8.3 Reglas de Alcance R sigue un conjunto especial de reglas para buscar objetos. Estas reglas se conocen como reglas de alcance de R y ya conoce un par de ellas: R busca objetos en el entorno activo actual. Cuando trabaja en la línea de comandos, el entorno activo es el entorno global. Por lo tanto, R busca objetos a los que llama en la línea de comando en el entorno global. Aquí hay una tercera regla que explica cómo R encuentra objetos que no están en el entorno activo. Cuando R no encuentra un objeto en un entorno, R busca en el entorno principal del entorno, luego en el principal del principal, y así sucesivamente, hasta que R encuentra el objeto o llega al entorno vacío. Entonces, si llama a un objeto en la línea de comando, R lo buscará en el entorno global. Si R no puede encontrarlo allí, R buscará en el padre del entorno global, y luego en el padre del padre, y así sucesivamente, ascendiendo por el árbol del entorno hasta que encuentre el objeto, como en la Figura @ ref(figura:path). Si R no puede encontrar el objeto en ningún entorno, devolverá un error que dice que no se encuentra el objeto. Figure 8.3: R buscará un objeto por su nombre en el entorno activo, aquí el entorno global. Si R no encuentra el objeto allí, buscará en el padre del entorno activo y luego en el padre del padre, y así sucesivamente hasta que R encuentre el objeto o se quede sin entornos. Recuerde que las funciones son un tipo de objeto en R. R almacenará y buscará funciones de la misma manera que almacena y busca otros objetos, buscándolos por nombre en el árbol del entorno. 8.4 Asignación Cuando asigna un valor a un objeto, R guarda el valor en el entorno activo bajo el nombre del objeto. Si ya existe un objeto con el mismo nombre en el entorno activo, R lo sobrescribirá. Por ejemplo, existe un objeto llamado nuevo en el entorno global: nuevo ## &quot;Hola Global&quot; Puede guardar un nuevo objeto llamado nuevo en el entorno global con este comando. R sobrescribirá el objeto anterior como resultado: nuevo &lt;- &quot;Hola Activo&quot; nuevo ## &quot;Hola Activo&quot; Este arreglo crea un dilema para R cada vez que R ejecuta una función. Muchas funciones guardan objetos temporales que les ayudan a hacer su trabajo. Por ejemplo, la función tirar del Proyecto 1: Dados Ponderados guardó un objeto llamado dado y un objeto llamado dados: tirar &lt;- function() { dado &lt;- 1:6 dados &lt;- sample(dado, size = 2, replace = TRUE) sum(dados) } R debe guardar estos objetos temporales en el entorno activo; pero si R hace eso, puede sobrescribir los objetos existentes. Los autores de funciones no pueden adivinar de antemano qué nombres pueden existir ya en su entorno activo. ¿Cómo evita R este riesgo? Cada vez que R ejecuta una función, crea un nuevo entorno activo para evaluar la función. 8.5 Evaluación R crea un nuevo entorno cada vez que evalúa una función. R usará el nuevo entorno como el entorno activo mientras ejecuta la función, y luego R volverá al entorno desde el que llamó a la función, trayendo consigo el resultado de la función. Llamemos a estos nuevos entornos entornos de tiempo de ejecución porque R los crea en tiempo de ejecución para evaluar funciones. Usaremos la siguiente función para explorar los entornos de tiempo de ejecución de R. Queremos saber cómo son los entornos: ¿cuáles son sus entornos principales y qué objetos contienen? show_env está diseñado para decirnos: show_env &lt;- function(){ list(ran.in = environment(), parent = parent.env(environment()), objects = ls.str(environment())) } show_env es en sí mismo una función, por lo que cuando llamamos a show_env(), R creará un entorno de tiempo de ejecución para evaluar la función. Los resultados de show_env nos dirán el nombre del entorno de tiempo de ejecución, su padre y qué objetos entorno de tiempo de ejecución contiene: show_env() ## $ran.in ## &lt;environment: 0x7ff711d12e28&gt; ## ## $parent ## &lt;environment: R_GlobalEnv&gt; ## ## $objects Los resultados revelan que R creó un nuevo entorno llamado 0x7ff711d12e28 para ejecutar show_env(). El entorno no tenía objetos y su padre era el entorno global. Entonces, para ejecutar show_env, el árbol de entorno de R se parecía a la figura 8.4. Ejecutemos show_env de nuevo: show_env() ## $ran.in ## &lt;environment: 0x7ff715f49808&gt; ## ## $parent ## &lt;environment: R_GlobalEnv&gt; ## ## $objects Esta vez show_env se ejecutó en un nuevo entorno, 0x7ff715f49808. R crea un nuevo entorno cada vez que ejecuta una función. El entorno 0x7ff715f49808 se ve exactamente igual que 0x7ff711d12e28. Está vacío y tiene el mismo entorno global que su padre. Figure 8.4: R crea un nuevo entorno para ejecutar show_env. El entorno es un elemento secundario del entorno global. Ahora, consideremos qué entorno usará R como padre del entorno de tiempo de ejecución. R conectará el entorno de tiempo de ejecución de una función con el entorno en el que la función fue creada por primera vez. Este entorno juega un papel importante en la vida de la función, porque todos los entornos de tiempo de ejecución de la función lo utilizarán como padre. Llamemos a este entorno el entorno de origen. Puede buscar el entorno de origen de una función ejecutando environment en la función: environment(show_env) ## &lt;environment: R_GlobalEnv&gt; El entorno de origen de show_env es el entorno global porque creamos show_env en la línea de comando, pero no es necesario que el entorno de origen sea el entorno global. Por ejemplo, el entorno de parenvs es el paquete pryr: environment(parenvs) ## &lt;environment: namespace:pryr&gt; En otras palabras, el padre de un entorno de tiempo de ejecución no siempre será el entorno global; será el entorno en el que se creó la función por primera vez. Finalmente, veamos los objetos contenidos en un entorno de tiempo de ejecución. Por el momento, los entornos de ejecución de show_env no contienen ningún objeto, pero eso es fácil de arreglar. Simplemente haga que show_env cree algunos objetos en el cuerpo de su código. R almacenará cualquier objeto creado por show_env en su entorno de ejecución. ¿Por qué? Debido a que el entorno de tiempo de ejecución será el entorno activo cuando se creen esos objetos: show_env &lt;- function(){ a &lt;- 1 b &lt;- 2 c &lt;- 3 list(ran.in = environment(), parent = parent.env(environment()), objects = ls.str(environment())) } Esta vez, cuando ejecutamos show_env, R almacena a, b y c en el entorno de ejecución: show_env() ## $ran.in ## &lt;environment: 0x7ff712312cd0&gt; ## ## $parent ## &lt;environment: R_GlobalEnv&gt; ## ## $objects ## a : num 1 ## b : num 2 ## c : num 3 Así es como R se asegura de que una función no sobrescriba nada que no debería. Todos los objetos creados por la función se almacenan en un entorno de tiempo de ejecución seguro y apartado. R también pondrá un segundo tipo de objeto en un entorno de tiempo de ejecución. Si una función tiene argumentos, R copiará cada argumento en el entorno de tiempo de ejecución. El argumento aparecerá como un objeto que tiene el nombre del argumento pero el valor de cualquier entrada que el usuario proporcionó para el argumento. Esto asegura que una función podrá encontrar y usar cada uno de sus argumentos: foo &lt;- &quot;llevame a tu tiempo de ejecucion&quot; show_env &lt;- function(x = foo){ list(ran.in = environment(), parent = parent.env(environment()), objects = ls.str(environment())) } show_env() ## $ran.in ## &lt;environment: 0x7ff712398958&gt; ## ## $parent ## &lt;environment: R_GlobalEnv&gt; ## ## $objects ## x : chr &quot;llevame a tu tiempo de ejecucion&quot; Pongamos todo esto junto para ver cómo R evalúa una función. Antes de llamar a una función, R está trabajando en un entorno activo; llamemos a esto el entorno de llamadas. Es el entorno desde el que R llama a la función. Luego llamas a la función. R responde configurando un nuevo entorno de tiempo de ejecución. Este entorno será un elemento secundario del entorno de origen de la función. R copiará cada uno de los argumentos de la función en el entorno de tiempo de ejecución y luego hará que el entorno de tiempo de ejecución sea el nuevo entorno activo. A continuación, R ejecuta el código en el cuerpo de la función. Si el código crea objetos, R los almacena en el entorno activo, es decir, en tiempo de ejecución. Si el código llama a algún objeto, R usa sus reglas de alcance para buscarlos. R buscará el entorno de tiempo de ejecución, luego el padre del entorno de tiempo de ejecución (que será el entorno de origen), luego el padre del entorno de origen, y así sucesivamente. Tenga en cuenta que es posible que el entorno de llamada no esté en la ruta de búsqueda. Por lo general, una función solo llamará a sus argumentos, que R puede encontrar en el entorno de tiempo de ejecución activo. Finalmente, R termina de ejecutar la función. Cambia el entorno activo de nuevo al entorno de llamada. Ahora R ejecuta cualquier otro comando en la línea de código que llamó a la función. Entonces, si guarda el resultado de la función en un objeto con &lt;-, el nuevo objeto se almacenará en el entorno de llamada. En resumen, R almacena sus objetos en un sistema de entorno. En cualquier momento, R está trabajando en estrecha colaboración con un único entorno activo. Almacena nuevos objetos en este entorno y utiliza el entorno como punto de partida cuando busca objetos existentes. El entorno activo de R suele ser el entorno global, pero R ajustará el entorno activo para hacer cosas como ejecutar funciones de forma segura. ¿Cómo puedes usar este conocimiento para arreglar las funciones repartir y barajar? Primero, comencemos con una pregunta de calentamiento. Supongamos que redefino repartir en la línea de comando de esta manera: repartir &lt;- function() { mazo[1, ] } Tenga en cuenta que repartir ya no toma un argumento y llama al objeto mazo, que vive en el entorno global. Ejercicio 8.1 (¿Funcionará repartir?) ¿Podrá R encontrar mazo y devolver una respuesta cuando llame a la nueva versión de repartir, como repartir()? Solution. Sí. repartir seguirá funcionando igual que antes. R ejecutará repartir en un entorno de tiempo de ejecución que es un elemento secundario del entorno global. ¿Por qué será un hijo del entorno global? Debido a que el entorno global es el entorno de origen de repartir (definimos repartir en el entorno global): environment(repartir) ## &lt;environment: R_GlobalEnv&gt; Cuando repartir llama a mazo, R necesitará buscar el objeto mazo. Las reglas de alcance de R lo llevarán a la versión de repartir en el entorno global, como en la Figura 8.5. mazo funciona como se esperaba como resultado: repartir() ## cara palo valor ## rey picas 13 Figure 8.5: R encuentra el mazo mirando en el padre del entorno de tiempo de ejecución de repartir. El padre es el entorno global, el entorno de origen de repartir. Aquí, R encuentra la copia del mazo. Ahora arreglemos la función repartir para eliminar las cartas que ha repartido del mazo. Recuerde que repartir devuelve la carta superior de mazo pero no elimina la carta de la baraja. Como resultado, repartir siempre devuelve la misma carta: repartir() ## cara palo valor ## rey picas 13 repartir() ## cara palo valor ## rey picas 13 Conoces suficiente sintaxis de R para eliminar la carta superior de mazo. El siguiente código guardará una copia prístina de mazo y luego eliminará la carta superior: MAZO &lt;- mazo mazo &lt;- mazo[-1, ] head(mazo, 3) ## cara palo valor ## reina picas 12 ## jota picas 11 ## diez picas 10 Ahora agreguemos el código a repartir. Aquí repartir guarda (y luego devuelve) la carta superior de mazo. En el medio, quita la carta del mazo… ¿o no? repartir &lt;- function() { carta &lt;- mazo[1, ] mazo &lt;- mazo[-1, ] carta } Este código no funcionará porque R estará en un entorno de tiempo de ejecución cuando ejecute mazo &lt;- mazo[-1, ]. En lugar de sobrescribir la copia global de mazo con mazo[-1, ], repartir`` simplemente creará una copia ligeramente alterada demazo` en su entorno de tiempo de ejecución, como en la Figura 8.6. Figure 8.6: La función de repartir busca el mazo en el entorno global pero guarda el mazo[-1, ] en el entorno de tiempo de ejecución como un nuevo objeto llamado mazo. Ejercicio 8.2 (Sobreescribir el mazo) Vuelva a escribir la línea mazo &lt;- mazo[-1, ] de repartir para asignar mazo[-1, ] a un objeto llamado mazo en el entorno global. Sugerencia: considere la función assign. Solution. Puede asignar un objeto a un entorno específico con la función assign: repartir &lt;- function() { carta &lt;- mazo[1, ] assign(&quot;mazo&quot;, mazo[-1, ], envir = globalenv()) carta } Ahora repartir finalmente limpiará la copia global de mazo, y podemos repartir cartas tal como lo haríamos en la vida real: repartir() ## cara palo valor ## reina picas 12 repartir() ## cara palo valor ## jota picas 11 repartir() ## cara palo valor ## diez picas 10 Volvamos nuestra atención a la función barajar: barajar &lt;- function(cartas) { aleatorio &lt;- sample(1:52, size = 52) cartas[aleatorio, ] } barajar(mazo) no mezcla el objeto mazo; devuelve una copia barajada del objeto mazo: head(mazo, 3) ## cara palo valor ## nueve picas 9 ## ocho picas 8 ## siete picas 7 a &lt;- barajar(mazo) head(mazo, 3) ## cara palo valor ## nueve picas 9 ## ocho picas 8 ## siete picas 7 head(a, 3) ## cara palo valor ## as diamantes 1 ## siete treboles 7 ## dos treboles 2 Este comportamiento es ahora indeseable de dos maneras. Primero, barajr falla al barajar mazo. En segundo lugar, barajar devuelve una copia de mazo, a la que pueden faltarle las cartas que se han repartido. Sería mejor si barajar devolviera las cartas repartidas a la baraja y luego se barajaran. Esto es lo que sucede cuando barajas una baraja de cartas en la vida real. Ejercicio 8.3 (Rescribir barajr) Vuelva a escribir barajar para que reemplace la copia de mazo que vive en el entorno global con una versión barajada de MAZO, la copia intacta de mazo que también vive en el entorno global. La nueva versión de barajar no debería tener argumentos y no devolver ningún resultado. Solution. Puede actualizar barajar de la misma manera que actualizó repartir. La siguiente versión hará el trabajo: barajar &lt;- function(){ aleatorio &lt;- sample(1:52, size = 52) assign(&quot;mazo&quot;, MAZO[aleatorio, ], envir = globalenv()) } Dado que MAZO vive en el entorno global, el entorno de origen de barajar, barajar podrá encontrar MAZO en tiempo de ejecución. R buscará MAZO primero en el entorno de tiempo de ejecución de barajar y luego en el entorno de origen de barajar, el entorno global, que es donde se almacena MAZO. La segunda línea de barajar creará una copia reordenada de MAZO y la guardará como mazo en el entorno global. Esto sobrescribirá la versión anterior, no barajada, de mazo. 8.6 Cierres Nuestro sistema finalmente funciona. Por ejemplo, puede barajar las cartas y luego repartir una mano de blackjack: barajar() repartir() ## cara palo valor ## reina corazones 12 repartir() ## cara palo valor ## ocho corazones 8 Pero el sistema requiere que mazo y MAZO existan en el entorno global. Muchas cosas suceden en este entorno, y es posible que el mazo se modifique o borre por accidente. Sería mejor si pudiéramos almacenar mazo en un lugar seguro y apartado, como uno de esos entornos seguros y apartados que R crea para ejecutar funciones. De hecho, almacenar mazo en un entorno de tiempo de ejecución no es tan mala idea. Podrías crear una función que tome mazo como argumento y guarde una copia de mazo como MAZO. La función también podría guardar sus propias copias de repartir y barajar: setup &lt;- function(mazo) { MAZO &lt;- mazo REPARTIR &lt;- function() { carta &lt;- mazo[1, ] assign(&quot;mazo&quot;, mazo[-1, ], envir = globalenv()) carta } BARAJAR &lt;- function(){ aleatorio &lt;- sample(1:52, size = 52) assign(&quot;mazo&quot;, MAZO[aleatorio, ], envir = globalenv()) } } Cuando ejecuta setup, R creará un entorno de tiempo de ejecución para almacenar estos objetos. El entorno se verá como la Figura 8.7. Ahora todas estas cosas están seguras fuera del camino en un hijo del entorno global. Eso los hace seguros pero difíciles de usar. Pidamos a setup que devuelva REPARTIR y BARAJAR para poder usarlos. La mejor manera de hacer esto es devolver las funciones como una lista: setup &lt;- function(mazo) { MAZO &lt;- mazo REPARTIR &lt;- function() { carta &lt;- mazo[1, ] assign(&quot;mazo&quot;, mazo[-1, ], envir = globalenv()) carta } BARAJAR &lt;- function(){ aleatorio &lt;- sample(1:52, size = 52) assign(&quot;mazo&quot;, MAZO[aleatorio, ], envir = globalenv()) } list(repartir = REPARTIR, barajar = BARAJAR) } cartas &lt;- setup(mazo) Figure 8.7: Ejecutar setup almacenará mazo y MAZO en un lugar apartado y creará una función REPARTIR y BARAJAR. Cada uno de estos objetos se almacenará en un entorno cuyo padre es el entorno global. Luego puede guardar cada uno de los elementos de la lista en un objeto dedicado en el entorno global: repartir &lt;- cartas$repartir barajar &lt;- cartas$barajar Ahora puedes ejecutar repartir y barajar como antes. Cada objeto contiene el mismo código que el repartir y barajar originales: repartir ## function() { ## carta &lt;- mazo[1, ] ## assign(&quot;mazo&quot;, mazo[-1, ], envir = globalenv()) ## carta ## } ## &lt;environment: 0x7ff7169c3390&gt; barajar ## function(){ ## aleatorio &lt;- sample(1:52, size = 52) ## assign(&quot;mazo&quot;, MAZO[aleatorio, ], envir = globalenv()) ## } ## &lt;environment: 0x7ff7169c3390&gt; Sin embargo, las funciones ahora tienen una diferencia importante. Su entorno de origen ya no es el entorno global (aunque repartir y barajar están actualmente guardados allí). Su entorno de origen es el entorno de tiempo de ejecución que creó R cuando ejecutó setup. Ahí es donde R creó REPARTIR y BARAJAR, las funciones copiadas en el nuevo repartir y barajar, como se muestra en: environment(repartir) ## &lt;environment: 0x7ff7169c3390&gt; environment(barajar) ## &lt;environment: 0x7ff7169c3390&gt; ¿Por qué importa esto? Porque ahora, cuando ejecuta repartir o barajar, R evaluará las funciones en un entorno de tiempo de ejecución que usa 0x7ff7169c3390 como padre. MAZO y mazo estarán en este entorno principal, lo que significa que repartir y barajar podrán encontrarlos en tiempo de ejecución. MAZO y mazo estarán en la ruta de búsqueda de funciones, pero seguirán fuera del camino en todos los demás aspectos, como se muestra en la Figura 8.8. Figure 8.8: Ahora, repartir y barajar se ejecutará en un entorno que tenga el mazo protegido y el MAZO en su ruta de búsqueda.. Este arreglo se llama cierre. El entorno de tiempo de ejecución de setup “encierra” las funciones repartir y barajar. Tanto repartir como barajar pueden trabajar de cerca con los objetos contenidos en el entorno circundante, pero casi nada más puede hacerlo. El entorno envolvente no está en la ruta de búsqueda de ninguna otra función o entorno de R. Es posible que haya notado que repartir y barajar aún actualizan el objeto mazo en el entorno global. No te preocupes, estamos a punto de cambiar eso. Queremos que repartir y barajar funcionen exclusivamente con los objetos en el entorno principal (incluyente) de sus entornos de tiempo de ejecución. En lugar de hacer que cada función haga referencia al entorno global para actualizar mazo, puede hacer que hagan referencia a su entorno principal en tiempo de ejecución, como se muestra en la Figura 8.9: setup &lt;- function(mazo) { MAZO &lt;- mazo REPARTIR &lt;- function() { carta &lt;- mazo[1, ] assign(&quot;mazo&quot;, mazo[-1, ], envir = parent.env(environment())) carta } BARAJAR &lt;- function(){ aleatorio &lt;- sample(1:52, size = 52) assign(&quot;mazo&quot;, MAZO[aleatorio, ], envir = parent.env(environment())) } list(repartir = REPARTIR, barajar = BARAJAR) } cartas &lt;- setup(mazo) repartir &lt;- cartas$repartir barajar &lt;- cartas$barajar Figure 8.9: Cuando cambie su código, repartir y barajar pasarán de actualizar el entorno global (izquierda) a actualizar su entorno principal (derecha). Finalmente tenemos un juego de cartas autónomo. Puedes borrar (o modificar) la copia global de mazo tanto como quieras y seguir jugando cartas. repartir y barajar utilizarán la copia protegida y prístina de mazo: rm(mazo) barajar() repartir() ## cara palo value ## as corazones 1 repartir() ## cara palo valor ## jota treboles 11 Blackjack! 8.7 Resumen R guarda sus objetos en un sistema de entorno que se asemeja al sistema de archivos de su computadora. Si comprende este sistema, puede predecir cómo R buscará objetos. Si llama a un objeto en la línea de comando, R buscará el objeto en el entorno global y luego los padres del entorno global, ascendiendo en el árbol de entornos, un entorno a la vez. R usará una ruta de búsqueda ligeramente diferente cuando llame a un objeto desde dentro de una función. Cuando ejecuta una función, R crea un nuevo entorno para ejecutar comandos. Este entorno será un elemento secundario del entorno donde se definió originalmente la función. Este puede ser el entorno global, pero también puede no serlo. Puede usar este comportamiento para crear cierres, que son funciones vinculadas a objetos en entornos protegidos. A medida que se familiarice con el sistema de entorno de R, puede usarlo para producir resultados elegantes, como lo hicimos aquí. Sin embargo, el valor real de comprender el sistema de entorno proviene de saber cómo las funciones de R hacen su trabajo. Puede usar este conocimiento para descubrir qué está fallando cuando una función no funciona como se esperaba. 8.8 Resumen del Proyecto 2 Ahora tiene control total sobre los conjuntos de datos y los valores que carga en R. Puede almacenar datos como objetos de R, puede recuperar y manipular valores de datos a voluntad e incluso puede predecir cómo R almacenará y buscará sus objetos en la memoria de tu computadora. Es posible que aún no se dé cuenta, pero su experiencia lo convierte en un poderoso usuario de datos aumentados por computadora. Puede usar R para guardar y trabajar con conjuntos de datos más grandes de los que podría manejar de otra manera. Hasta ahora solo hemos trabajado con mazo, un pequeño conjunto de datos; pero puede usar las mismas técnicas para trabajar con cualquier conjunto de datos que quepa en la memoria de su computadora. Sin embargo, el almacenamiento de datos no es la única tarea logística a la que se enfrentará como científico de datos. A menudo querrá realizar tareas con sus datos que son tan complejas o repetitivas que son difíciles de realizar sin una computadora. Algunas de las cosas se pueden hacer con funciones que ya existen en R y sus paquetes, pero otras no. Serás el más versátil como científico de datos si puedes escribir tus propios programas para que los sigan las computadoras. R puede ayudarte a hacer esto. Cuando esté listo, Project 3: Máquina Tragamonedas le enseñará las habilidades más útiles para escribir programas en R. "],["slots.html", "9 Proyecto 3: Máquina Tragamonedas", " 9 Proyecto 3: Máquina Tragamonedas Las máquinas tragamonedas son el juego más popular en los casinos modernos. Si nunca has visto una, una máquina tragamonedas se parece a un juego de arcade que tiene una palanca en un costado. Por una pequeña tarifa, puede tirar de la palanca y la máquina generará una combinación aleatoria de tres símbolos. Si aparece la combinación correcta, puede ganar un premio, tal vez incluso el mejor premio. Las máquinas tragamonedas generan ganancias fantásticas para los casinos porque ofrecen una tasa de pago muy baja. En muchos juegos, como el Blackjack y la Ruleta, las probabilidades están ligeramente a favor del casino. A la larga, el casino paga de 97 a 98 centavos en premios por cada dólar que gasta un jugador en estos juegos. Con las máquinas tragamonedas, es típico que un casino solo pague de 90 a 95 centavos, y el casino se queda con el resto. Si esto parece turbio, tenga en cuenta que las máquinas tragamonedas son uno de los juegos más populares en un casino; a pocas personas parece importarles. Y si considera que las loterías estatales tienen tasas de pago mucho más cercanas a los 50 centavos por dólar, las máquinas tragamonedas no se ven tan mal. En este proyecto, construirá una máquina tragamonedas real que funcione, modelada a partir de algunas Terminales de Lotería de Video de la vida real de Manitoba, Canadá. Los terminales fueron motivo de escándalo en la década de los 90. Llegarás al fondo de este escándalo escribiendo un programa que recree las máquinas tragamonedas. Luego hará algunos cálculos y ejecutará algunas simulaciones que revelarán la verdadera tasa de pago de las máquinas. Este proyecto le enseñará a escribir programas y ejecutar simulaciones en R. También aprenderá a: Usar una estrategia práctica para diseñar programas Usar declaraciones if y else para decirle a R qué hacer y cuando Crear tablas de búsqueda para encontrar valores Usar bucles for, while y repeat para automatizar operaciones repetitivas Usar métodos S3, la versión de R de Programación Orientada a Objetos Medir la velocidad del código R Escribir código R rápido y vectorizado "],["programs.html", "10 Programas 10.1 Estrategia 10.2 Declaraciones if 10.3 Declaraciones else 10.4 Tablas de Búsqueda 10.5 Comentarios de Código 10.6 Resumen", " 10 Programas En este capítulo, construirá una máquina tragamonedas real y funcional que puede jugar ejecutando una función R. Cuando termines, podrás jugarlo así: play() ## 0 0 DD ## $0 play() ## 7 7 7 ## $80 La función play necesitará hacer dos cosas. Primero, necesitará generar aleatoriamente tres símbolos; y, segundo, necesitará calcular un premio basado en esos símbolos. El primer paso es fácil de simular. Puede generar aleatoriamente tres símbolos con la función sample, tal como “lanzó” aleatoriamente dos dados en Proyecto 1: Dados Ponderados. La siguiente función genera tres símbolos de un grupo de símbolos comunes de máquinas tragamonedas: diamantes (DD), sietes (7), barras triples (BBB), barras dobles (BB), barras simples (B), cerezas (C) y ceros (0). Los símbolos se seleccionan al azar y cada símbolo aparece con una probabilidad diferente: obt_simbolos() &lt;- function() { rueda &lt;- c(&quot;DD&quot;, &quot;7&quot;, &quot;BBB&quot;, &quot;BB&quot;, &quot;B&quot;, &quot;C&quot;, &quot;0&quot;) sample(rueda, size = 3, replace = TRUE, prob = c(0.03, 0.03, 0.06, 0.1, 0.25, 0.01, 0.52)) } Puedes usar obt_simbolos() para generar los símbolos usados en tu máquina tragamonedas: obt_simbolos() ## &quot;BBB&quot; &quot;0&quot; &quot;C&quot; obt_simbolos() ## &quot;0&quot; &quot;0&quot; &quot;0&quot; obt_simbolos() ## &quot;7&quot; &quot;0&quot; &quot;B&quot; obt_simbolos utiliza las probabilidades observadas en un grupo de Terminales de Video Lotería de Manitoba, Canadá. Estas máquinas tragamonedas se volvieron brevemente controvertidas en la década de 1990, cuando un reportero decidió probar su tasa de pago. Las máquinas parecían pagar solo 40 centavos por dólar, aunque el fabricante afirmó que pagarían 92 centavos por dólar. Los datos originales recopilados en las máquinas y una descripción de la controversia están disponibles en línea en un artículo de revista de W. John Braun. La controversia se calmó cuando las pruebas adicionales mostraron que el fabricante tenía razón. Las máquinas tragamonedas de Manitoba utilizan el complicado esquema de pagos que se muestra en la Tabla 10.1. Un jugador ganará un premio si obtiene: Tres del mismo tipo de símbolo (excepto tres ceros) Tres barras (de variedad mixta) Una o más cerezas De lo contrario, el jugador no recibe ningún premio. El valor monetario del premio está determinado por la combinación exacta de símbolos y se modifica aún más por la presencia de diamantes. Los diamantes se tratan como “comodines”, lo que significa que pueden considerarse cualquier otro símbolo si aumentara el premio de un jugador. Por ejemplo, un jugador que lanza 7 7 DD ganaría un premio por obtener tres sietes. Sin embargo, hay una excepción a esta regla: un diamante no se puede considerar una cereza a menos que el jugador también obtenga una cereza real. Esto evita que una tirada sin fondos como 0 DD 0 se puntúe como 0 C 0. Los diamantes también son especiales de otra manera. Cada diamante que aparece en una combinación duplica el importe del premio final. Así que 7 7 DD en realidad tendría una puntuación más alta que 7 7 7. Tres sietes te darían $80, pero dos sietes y un diamante te darían $160. Un siete y dos diamantes sería aún mejor, lo que daría como resultado un premio que se ha duplicado dos veces, o $320. Un premio mayor ocurre cuando un jugador lanza DD DD DD. Luego, un jugador gana $100 duplicados tres veces, lo que equivale a $800. Table 10.1: Cada juego de la máquina tragamonedas cuesta $1. Los símbolos de un jugador determinan cuánto gana. Los diamantes (DD) son comodines y cada diamante duplica el premio final. * = cualquier símbolo. Combinación Premios($) DD DD DD 100 7 7 7 80 BBB BBB BBB 40 BB BB BB 25 B B B 10 C C C 10 Cualquier combinación de barras 5 C C * 5 C * C 5 * C C 5 C * * 2 * C * 2 * * C 2 Para crear su función play, necesitará escribir un programa que pueda tomar la salida de obt_simbolos y calcular el premio correcto basado en Tabla 10.1. En R, los programas se guardan como scripts de R o como funciones. Guardaremos su programa como una función llamada puntuacion. Cuando termines, podrás usar puntuacion para calcular un premio como este: puntuacion(c(&quot;DD&quot;, &quot;DD&quot;, &quot;DD&quot;)) ## 800 Después de eso, será fácil crear la máquina tragamonedas completa, así: play &lt;- function() { simbolos &lt;- obt_simbolos() print(simbolos) puntuacion(simbolos) } El comando print imprime su salida en la ventana de la consola, lo que hace que print sea una forma útil de mostrar mensajes desde el cuerpo de una función. Puede notar que play llama a una nueva función, print. Esto ayudará a play a mostrar los tres símbolos de máquinas tragamonedas, ya que la última línea de la función no los devuelve. El comando print imprime su salida en la ventana de la consola, incluso si R lo llama desde dentro de una función. En Proyecto 1: Dados Ponderados, lo animé a escribir todo su código R en un script R, un archivo de texto donde puede redactar y guardar el código. Ese consejo será muy importante a medida que avance en este capítulo. Recuerde que puede abrir un script R en RStudio yendo a la barra de menú y haciendo clic en File &gt; New File &gt; R Script. 10.1 Estrategia La puntuación de los resultados de las máquinas tragamonedas es una tarea compleja que requerirá un algoritmo complejo. Puede facilitar esta y otras tareas de codificación utilizando una estrategia simple: Dividir tareas complejas en subtareas simples. Utilice ejemplos concretos. Describa sus soluciones en español, luego conviértalas a R. Comencemos por ver cómo puede dividir un programa en subtareas con las que es fácil trabajar. Un programa es un conjunto de instrucciones paso a paso que debe seguir su computadora. En conjunto, estas instrucciones pueden lograr algo muy sofisticado. Por separado, cada paso individual probablemente será simple y directo. Puede facilitar la codificación identificando los pasos o subtareas individuales dentro de su programa. A continuación, puede trabajar en cada subtarea por separado. Si una subtarea parece complicada, intente dividirla nuevamente en subtareas pares que sean aún más simples. A menudo, puede reducir un programa de R en subtareas tan simples que cada una se puede realizar con una función preexistente. Los programas de R contienen dos tipos de subtareas: pasos secuenciales y casos paralelos. 10.1.1 Pasos Secuenciales Una forma de subdividir un programa es en una serie de pasos secuenciales. La función play toma el enfoque que se muestra en la Figura 10.1. Primero, genera tres símbolos (paso 1), luego los muestra en la ventana de la consola (paso 2) y luego los puntúa (paso 3): play &lt;- function() { # step 1: genera simbolos simbolos &lt;- obt_simbolos() # step 2: muestra los simbolos print(simbolos) # step 3: puntua los simbolos puntuacion(simbolos) } Para que R ejecute los pasos en secuencia, coloque los pasos uno tras otro en un script de R o en el cuerpo de una función. Figure 10.1: La función play utiliza una serie de pasos. 10.1.2 Casos Paralelos Otra forma de dividir una tarea es detectar grupos de casos similares dentro de la tarea. Algunas tareas requieren diferentes algoritmos para diferentes grupos de entrada. Si puede identificar esos grupos, puede resolver sus algoritmos uno a la vez. Por ejemplo, puntuacion necesitará calcular el premio de una manera si simbolos contiene tres de una clase (en ese caso, puntuacion necesitará hacer coincidir el símbolo común con un premio). puntuacion necesitará calcular el premio de una segunda manera si los símbolos son todos barras (en ese caso, puntuacion puede asignar un premio de $5). Y, por último, puntuacion necesitará calcular el premio de una tercera forma si los símbolos no contienen tríos o todas las barras (en ese caso, puntuacion debe contar el número de cerezas presentes). puntuacion nunca usará estos tres algoritmos a la vez; siempre elegirá solo un algoritmo para ejecutar en función de la combinación de símbolos. Los diamantes complican todo esto porque los diamantes pueden ser tratados como comodines. Ignoremos eso por ahora y concentrémonos en el caso más simple donde los diamantes duplican el premio pero no son comodines. puntuacion puede duplicar el premio según sea necesario después de ejecutar uno de los siguientes algoritmos, como se muestra en la Figura 10.2. Agregar los casos de puntuación a los pasos de play revela una estrategia para el programa completo de máquinas tragamonedas, como se muestra en la Figura 10.3. Ya hemos resuelto los primeros pasos de esta estrategia. Nuestro programa puede obtener tres símbolos de máquinas tragamonedas con la función obt_simbolos. Entonces puede mostrar los símbolos con la función print. Ahora examinemos cómo el programa puede manejar los casos de puntuación paralela. Figure 10.2: La función de puntuación debe distinguir entre casos paralelos. Figure 10.3: La simulación completa de la máquina tragamonedas implicará subtareas que se organizan tanto en serie como en paralelo. 10.2 Declaraciones if Vincular casos en paralelo requiere un poco de estructura; su programa se enfrenta a una bifurcación en el camino cada vez que debe elegir entre casos. Puedes ayudar al programa a navegar por esta bifurcación con una instrucción if. Una declaración if le dice a R que haga una tarea determinada para un caso determinado. En español dirías algo como: “Si esto es cierto, haz aquello”. En R, dirías: if (esto) { aquello } El objeto esto debe ser una prueba lógica o una expresión de R que se evalúe a un solo TRUE o FALSE. Si esto se evalúa como TRUE, R ejecutará todo el código que aparece entre las llaves que siguen a la instrucción if (es decir, entre los símbolos { y }). Si esto se evalúa como FALSE, R omitirá el código entre llaves sin ejecutarlo. Por ejemplo, podría escribir una declaración if que asegure que algún objeto, num, sea positivo: if (num &lt; 0) { num &lt;- num * -1 } Si num &lt; 0 es TRUE, R multiplicará num por uno negativo, lo que hará que num sea positivo: num &lt;- -2 if (num &lt; 0) { num &lt;- num * -1 } num ## 2 Si num &lt; 0 es FALSE, R no hará nada y num permanecerá como está: positivo (o cero): num &lt;- 4 if (num &lt; 0) { num &lt;- num * -1 } num ## 4 La condición de una declaración if debe evaluarse como un único TRUE o FALSE. Si la condición crea un vector de TRUE y FALSE (que es más fácil de hacer de lo que piensa), su declaración if imprimirá un mensaje de advertencia y usará solo el primer elemento del vector. Recuerda que puedes condensar vectores de valores lógicos en un solo TRUE o FALSE con las funciones any y all. No tienes que limitar tus declaraciones if a una sola línea de código; puede incluir tantas líneas como desee entre las llaves. Por ejemplo, el siguiente código usa muchas líneas para asegurar que num sea positivo. Las líneas adicionales imprimen algunas declaraciones informativas si num comienza como un número negativo. R omitirá todo el bloque de código, declaraciones print y todo, si num comienza como un número positivo: num &lt;- -1 if (num &lt; 0) { print(&quot;num es negativo.&quot;) print(&quot;No te preocupes, lo arreglaré.&quot;) num &lt;- num * -1 print(&quot;Ahora num es positivo.&quot;) } ## &quot;num es negativo.&quot; ## &quot;No te preocupes, lo arreglaré.&quot; ## &quot;Ahora num es positivo.&quot; num ## 1 Pruebe las siguientes pruebas para desarrollar su comprensión de las declaraciones if. Ejercicio 10.1 (Cuestionario A) ¿Qué devolverá esto? x &lt;- 1 if (3 == 3) { x &lt;- 2 } x Solution. El código devolverá el número 2. x comienza como 1, y luego R encuentra la declaración if. Dado que la condición se evalúa como TRUE, R ejecutará x &lt;- 2, cambiando el valor de x. Ejercicio 10.2 (Cuestionario B) ¿Qué devolverá esto? x &lt;- 1 if (TRUE) { x &lt;- 2 } x Solution. Este código también devolverá el número 2. Funciona igual que el código en la prueba A, excepto que la condición en esta declaración ya es TRUE. R ni siquiera necesita evaluarlo. Como resultado, se ejecutará el código dentro de la instrucción if y x se establecerá en 2. Ejercicio 10.3 (Cuestionario C) ¿Qué devolverá esto? x &lt;- 1 if (x == 1) { x &lt;- 2 if (x == 1) { x &lt;- 3 } } x Solution. Una vez más, el código devolverá el número 2. x comienza como 1, y la condición de la primera declaración if se evaluará como TRUE, lo que hace que R ejecute el código en el cuerpo de la esa declaración if. Primero, R establece x igual a 2, luego R evalúa la segunda declaración if, que está en el cuerpo de la primera. Esta vez x == 1 se evaluará como FALSE porque x ahora es igual a 2. Como resultado, R ignora x &lt;- 3 y sale de ambas declaraciones if. 10.3 Declaraciones else Las declaraciones if le dicen a R qué hacer cuando su condición es verdadera, pero también puede decirle a R qué hacer cuando la condición es falsa. else es una contraparte de if que extiende una declaración if para incluir un segundo caso. En español, dirías: “Si esto es cierto, haz el plan A; de lo contrario, haz el plan B”. En R, dirías: if (esto) { Plan A } else { Plan B } Cuando esto se evalúa como TRUE, R ejecutará el código en el primer conjunto de llaves, pero no el código en el segundo. Cuando esto se evalúa como FALSE, R ejecutará el código en el segundo conjunto de llaves, pero no en el primero. Puede utilizar este arreglo para cubrir todos los casos posibles. Por ejemplo, podría escribir algún código que redondee un decimal al entero más cercano. Comience con un decimal: a &lt;- 3.14 Luego aísle el componente decimal con trunc: dec &lt;- a - trunc(a) dec ## 0.14 trunc toma un número y devuelve solo la parte del número que aparece a la izquierda del lugar decimal (es decir, la parte entera del número). a - trunc(a) es una forma conveniente de devolver la parte decimal de a. Luego use un árbol if else para redondear el número (hacia arriba o hacia abajo): if (dec &gt;= 0.5) { a &lt;- trunc(a) + 1 } else { a &lt;- trunc(a) } a ## 3 Si su situación tiene más de dos casos que se excluyen mutuamente, puede unir varias declaraciones if y else agregando una nueva declaración if inmediatamente después de else. Por ejemplo: a &lt;- 1 b &lt;- 1 if (a &gt; b) { print(&quot;¡A gana!&quot;) } else if (a &lt; b) { print(&quot;¡B gana!&quot;) } else { print(&quot;Empate.&quot;) } ## &quot;Empate.&quot; R trabajará a través de las condiciones if hasta que una se evalúe como TRUE, entonces R ignorará cualquier cláusula if y else restante en el árbol. Si ninguna condición se evalúa como TRUE, R ejecutará la declaración else final. Si dos sentencias if describen eventos que se excluyen mutuamente, es mejor unir las sentencias if con else if que listarlas por separado. Esto le permite a R ignorar la segunda declaración if siempre que la primera devuelva un TRUE, lo que ahorra trabajo. Puede usar if y else para vincular las subtareas en su función de máquina tragamonedas. Abra un script R nuevo y copie este código en él. El código será el esqueleto de nuestra función puntuación final. Compáralo con el diagrama de flujo para puntuación en la Figura 10.2: if ( # Caso 1: todos son iguales &lt;1&gt;) { premio &lt;- # Buscar el premio &lt;3&gt; } else if ( # Caso 2: todos barras &lt;2&gt; ) { premio &lt;- # asignar $5 &lt;4&gt; } else { # contar cerezas &lt;5&gt; premio &lt;- # calcular el premio &lt;7&gt; } # contar diamantes &lt;6&gt; # duplicar el premio si es necesario &lt;8&gt; Nuestro esqueleto es bastante incompleto; hay muchas secciones que son solo comentarios de código en lugar de código real. Sin embargo, hemos reducido el programa a ocho subtareas simples: &lt;1&gt; - Prueba si los símbolos son tres de una clase. &lt;2&gt; - Prueba si los símbolos son solo barras. &lt;3&gt; - Busque el premio de tres iguales según el símbolo común. &lt;4&gt; - Asigne un premio de $5. &lt;5&gt; - Cuenta el número de cerezas. &lt;6&gt; - Cuenta el número de diamantes. &lt;7&gt; - Calcula un premio basado en el número de cerezas. &lt;8&gt; - Ajustar el premio por diamantes. Si lo desea, puede reorganizar su diagrama de flujo en torno a estas tareas, como en la Figura 10.4. El gráfico describirá la misma estrategia, pero de una manera más precisa. Usaré una forma de diamante para simbolizar una decisión if else. Figure 10.4: puntuacion puede navegar tres casos con dos decisiones if else. También podemos dividir algunas de nuestras tareas en dos pasos. Ahora podemos trabajar en las subtareas una a la vez, agregando código de R al árbol if a medida que avanzamos. Cada subtarea será fácil de resolver si configura un ejemplo concreto para trabajar e intenta describir una solución en español antes de codificar en R. La primera subtarea le pide que pruebe si los símbolos son tres de una clase. ¿Cómo debería comenzar a escribir el código para esta subtarea? Sabes que la función puntuacion final se verá así: puntuacion &lt;- function(simbolos) { # calcular el premio premio } Su argumento, simbolos, será la salida de obt_simbolos, un vector que contiene tres cadenas de caracteres. Podría comenzar a escribir puntuacion como lo he escrito, definiendo un objeto llamado puntuacion y luego completando lentamente el cuerpo de la función. Sin embargo, esto sería una mala idea. La función eventual tendrá ocho partes separadas, y no funcionará correctamente hasta que todas esas partes estén escritas (y funcionen correctamente). Esto significa que tendría que escribir toda la función puntuacion antes de poder probar cualquiera de las subtareas. Si puntuacion no funciona, lo cual es muy probable, no sabrá qué subtarea debe corregirse. Puede ahorrarse tiempo y dolores de cabeza si se enfoca en una subtarea a la vez. Para cada subtarea, cree un ejemplo concreto en el que pueda probar su código. Por ejemplo, sabe que puntuacion necesitará trabajar en un vector llamado simbolos que contiene tres cadenas de caracteres. Si crea un vector real llamado simbolos, puede ejecutar el código para muchas de sus subtareas en el vector a medida que avanza: simbolos &lt;- c(&quot;7&quot;, &quot;7&quot;, &quot;7&quot;) Si una pieza de código no funciona en simbolos, sabrá que necesita arreglarlo antes de continuar. Puedes cambiar el valor de simbolos de subtarea a subtarea para asegurarte de que tu código funcione en todas las situaciones: simbolos &lt;- c(&quot;B&quot;, &quot;BB&quot;, &quot;BBB&quot;) simbolos &lt;- c(&quot;C&quot;, &quot;DD&quot;, &quot;0&quot;) Solo combine sus subtareas en una función de puntuacion una vez que cada subtarea funcione en un ejemplo concreto. Si sigue este plan, pasará más tiempo usando sus funciones y menos tratando de averiguar por qué no funcionan. Después de establecer un ejemplo concreto, intente describir cómo realizará la subtarea en español. Cuanto más precisamente pueda describir su solución, más fácil será escribir su código de R. Nuestra primera subtarea nos pide que “probemos si los símbolos son tres iguales”. Esta frase no me sugiere ningún código de R útil. Sin embargo, podría describir una prueba más precisa para el trío: tres símbolos serán iguales si el primer símbolo es igual al segundo y el segundo símbolo es igual al tercero. O, aún más precisamente: Un vector llamado simbolos contendrá tres del mismo símbolo si el primer elemento de simbolos es igual al segundo elemento de simbolos y el segundo elemento de simbolos es igual al tercer elemento de simbolos. Ejercicio 10.4 (Escribe una Prueba) Convierta la declaración anterior en una prueba lógica escrita en R. Use su conocimiento de pruebas lógicas, operadores booleanos y subconjuntos de Notación de R. La prueba debería funcionar con el vector simbolos y devolver un TRUE si y solo si cada elemento en simbolos es el mismo. Asegúrese de probar su código en simbolos. Solution. Aquí hay un par de formas de probar que simbolos contiene tres del mismo símbolo. El primer método es paralelo a la sugerencia en español anterior, pero hay otras formas de hacer la misma prueba. No hay una respuesta correcta o incorrecta, siempre y cuando su solución funcione, lo cual es fácil de comprobar porque ha creado un vector llamado simbolos: simbolos ## &quot;7&quot; &quot;7&quot; &quot;7&quot; simbolos[1] == simbolos[2] &amp; simbolos[2] == simbolos[3] ## TRUE simbolos[1] == simbolos[2] &amp; simbolos[1] == simbolos[3] ## TRUE all(simbolos == simbolos[1]) ## TRUE A medida que su vocabulario de funciones de R se amplíe, pensará en más formas de realizar tareas básicas. Un método que me gusta para verificar si tres son iguales es: length(unique(simbolos)) == 1 La función unique devuelve cada término único que aparece en un vector. Si su vector simbolos contiene tres iguales (es decir, un término único que aparece tres veces), entonces unique(simbolos) devolverá un vector de longitud 1. Ahora que tiene una prueba que funciona, puede agregarla a la secuencia de comandos de su máquina tragamonedas: iguales &lt;- simbolos[1] == simbolos[2] &amp;&amp; simbolos[2] == simbolos[3] if (iguales) { premio &lt;- # Buscar el premio } else if ( # Caso 2: todos barras) { premio &lt;- # asignar $5 } else { # contar cerezas premio &lt;- # calcular el premio } # contar diamantes # duplicar el premio si es necesario &amp;&amp; y || se comportan como &amp; y | pero a veces pueden ser más eficientes. Los operadores dobles no evaluarán la segunda prueba en un par de pruebas si la primera prueba aclara el resultado. Por ejemplo, si simbolos[1] no es igual a simbolos[2] en la siguiente expresión, &amp;&amp; no evaluará simbolos[2] == simbolos[3]; puede devolver inmediatamente un FALSE para toda la expresión (porque FALSE &amp; TRUE y FALSE &amp; FALSE ambos se evalúan como FALSE). Esta eficiencia puede acelerar sus programas; sin embargo, los operadores dobles no son apropiados en todas partes. &amp;&amp; y || no están vectorizados, lo que significa que solo pueden manejar una sola prueba lógica en cada lado del operador. El segundo caso de premio ocurre cuando todos los símbolos son un tipo de barra, por ejemplo, B, BB y BBB. Empecemos por crear un ejemplo concreto con el que trabajar: simbolos &lt;- c(&quot;B&quot;, &quot;BBB&quot;, &quot;BB&quot;) Ejercicio 10.5 (Probar si todos son barras) Use los operadores lógicos y booleanos de R para escribir una prueba que determinará si un vector llamado simbolos contiene solo símbolos que son un tipo de barra. Compruebe si su prueba funciona con nuestro vector de simbolos de ejemplo. Recuerde describir cómo debería funcionar la prueba en español y luego convertir la solución a R. Solution. Al igual que con muchas cosas en R, hay varias formas de probar si los simbolos contienen todos barras. Por ejemplo, podría escribir una prueba muy larga que use múltiples operadores booleanos, como esta: (simbolos[1] == &quot;B&quot; | simbolos[1] == &quot;BB&quot; | simbolos[1] == &quot;BBB&quot;) &amp; (simbolos[2] == &quot;B&quot; | simbolos[2] == &quot;BB&quot; | simbolos[2] == &quot;BBB&quot;) &amp; (simbolos[3] == &quot;B&quot; | simbolos[3] == &quot;BB&quot; | simbolos[3] == &quot;BBB&quot;) ## TRUE Sin embargo, esta no es una solución muy eficiente, porque R tiene que ejecutar nueve pruebas lógicas (y usted tiene que escribirlas). A menudo puede reemplazar múltiples operadores | con un único %in%. Además, puede verificar que una prueba sea verdadera para cada elemento en un vector con all. Estos dos cambios acortan el código anterior a: all(simbolos %in% c(&quot;B&quot;, &quot;BB&quot;, &quot;BBB&quot;)) ## TRUE Agreguemos este código a nuestro script: iguales &lt;- simbolos[1] == simbolos[2] &amp;&amp; simbolos[2] == simbolos[3] barras &lt;- simbolos %in% c(&quot;B&quot;, &quot;BB&quot;, &quot;BBB&quot;) if (iguales) { prize &lt;- # Buscar el premio } else if (all(barras)) { prize &lt;- # asiganr $5 } else { # contar cerezas premio &lt;- # calcular el premio } # contar diamantes # duplicar el premio si es necesario Es posible que haya notado que dividí esta prueba en dos pasos, barras y all(barras). Eso es solo una cuestión de preferencia personal. Siempre que sea posible, me gusta escribir mi código para que pueda leerse con nombres de funciones y objetos que transmitan lo que hacen. También puede haber notado que nuestra prueba para el Caso 2 capturará algunos símbolos que deberían estar en el Caso 1 porque contienen tres de una clase: simbolos &lt;- c(&quot;B&quot;, &quot;B&quot;, &quot;B&quot;) all(simbolos %in% c(&quot;B&quot;, &quot;BB&quot;, &quot;BBB&quot;)) ## TRUE Eso no será un problema, sin embargo, porque hemos conectado nuestros casos con else if en el árbol if. Tan pronto como R llegue a un caso que se evalúe como VERDADERO, se saltará el resto del árbol. Piénselo de esta manera: cada else le dice a R que solo ejecute el código que le sigue si no se ha cumplido ninguna de las condiciones anteriores. Entonces, cuando tenemos tres del mismo tipo de barra, R evaluará el código para el Caso 1 y luego omitirá el código para el Caso 2 (y el Caso 3). Nuestra próxima subtarea es asignar un premio a los simbolos. Cuando el vector de simbolos contiene tres del mismo símbolo, el premio dependerá de qué símbolo haya tres. Si hay tres DDs, el premio será de $100; si hay tres 7s, el premio será de $80; y así. Esto sugiere otro árbol if. Podrías asignar un premio con algún código como este: if (iguales) { simbolo &lt;- simbolos[1] if (simbolo == &quot;DD&quot;) { premmio &lt;- 800 } else if (simbolo == &quot;7&quot;) { premio &lt;- 80 } else if (simbolo == &quot;BBB&quot;) { premio &lt;- 40 } else if (simbolo == &quot;BB&quot;) { premio &lt;- 5 } else if (simbolo == &quot;B&quot;) { premio &lt;- 10 } else if (simbolo == &quot;C&quot;) { premio &lt;- 10 } else if (simbol == &quot;0&quot;) { premio &lt;- 0 } } Si bien este código funcionará, es un poco largo de escribir y leer, y puede requerir que R realice varias pruebas lógicas antes de entregar el premio correcto. Podemos hacerlo mejor con un método diferente. 10.4 Tablas de Búsqueda Muy a menudo en R, la forma más sencilla de hacer algo implicará la creación de subconjuntos. ¿Cómo podrías usar subconjuntos aquí? Como conoce la relación exacta entre los símbolos y sus premios, puede crear un vector que capture esta información. Este vector puede almacenar símbolos como nombres y valores de premios como elementos: pagos &lt;- c(&quot;DD&quot; = 100, &quot;7&quot; = 80, &quot;BBB&quot; = 40, &quot;BB&quot; = 25, &quot;B&quot; = 10, &quot;C&quot; = 10, &quot;0&quot; = 0) pagos ## DD 7 BBB BB B C 0 ## 100 80 40 25 10 10 0 Ahora puede extraer el premio correcto para cualquier símbolo subdividiendo el vector con el nombre del símbolo: pagos[&quot;DD&quot;] ## DD ## 100 pagos[&quot;B&quot;] ## B ## 10 Si desea dejar atrás el nombre del símbolo al crear subconjuntos, puede ejecutar la función unname en la salida: unname(pagos[&quot;DD&quot;]) ## 100 unname devuelve una copia de un objeto con el atributo de nombres eliminado. pagos es un tipo de tabla de búsqueda, un objeto de R que puede usar para buscar valores. Subdividir pagos proporciona una forma sencilla de encontrar el premio de un símbolo. No requiere muchas líneas de código y hace la misma cantidad de trabajo ya sea que su símbolo sea DD o 0. Puede crear tablas de búsqueda en R mediante la creación de objetos con nombre que se pueden dividir en subconjuntos de formas inteligentes. Lamentablemente, nuestro método no es del todo automático; necesitamos decirle a R qué símbolo buscar en pagos. ¿Tenemos? ¿Qué pasaría si dividieras los pagos por simbolos[1]? Probemos: simbolos &lt;- c(&quot;7&quot;, &quot;7&quot;, &quot;7&quot;) simbolos[1] ## &quot;7&quot; pagos[simbolos[1]] ## 7 ## 80 simbolos &lt;- c(&quot;C&quot;, &quot;C&quot;, &quot;C&quot;) pagos[simbolos[1]] ## C ## 10 No necesita saber el símbolo exacto para buscar porque puede decirle a R que busque cualquier símbolo que esté en simbolos. Puede encontrar este símbolo con simbolos[1], simbolos[2] o simbolos[3], porque cada uno contiene el mismo símbolo en este caso. Ahora tiene una forma sencilla y automatizada de calcular el premio cuando los simbolos contienen tres iguales. Vamos a agregarlo a nuestro código y luego veamos el Caso 2: iguales &lt;- simbolos[1] == simbolos[2] &amp;&amp; simbolos[2] == simbolos[3] barras &lt;- simbolos %in% c(&quot;B&quot;, &quot;BB&quot;, &quot;BBB&quot;) if (iguales) { pagos &lt;- c(&quot;DD&quot; = 100, &quot;7&quot; = 80, &quot;BBB&quot; = 40, &quot;BB&quot; = 25, &quot;B&quot; = 10, &quot;C&quot; = 10, &quot;0&quot; = 0) premio &lt;- unname(pagos[simbolos[1]]) } else if (all(barras)) { premio &lt;- # asignar $5 } else { # contar cerezas premio &lt;- # calcular el premio } # contar diamantes # duplicar el premio si es necesario El caso 2 ocurre cuando los símbolos son todos barras. En ese caso, el premio será de $5, que es fácil de asignar: iguales &lt;- simbolos[1] == simbolos[2] &amp;&amp; simbolos[2] == simbolos[3] barras &lt;- simbolos %in% c(&quot;B&quot;, &quot;BB&quot;, &quot;BBB&quot;) if (iguales) { pagos &lt;- c(&quot;DD&quot; = 100, &quot;7&quot; = 80, &quot;BBB&quot; = 40, &quot;BB&quot; = 25, &quot;B&quot; = 10, &quot;C&quot; = 10, &quot;0&quot; = 0) premio &lt;- unname(pagos[simbolos[1]]) } else if (all(barras)) { premio &lt;- 5 } else { # contar cerezas premio &lt;- # calcular el premio } # contar diamantes # duplicar el premio si es necesario Ahora podemos trabajar en el último caso. Aquí, necesitará saber cuántas cerezas hay en los simbolos antes de poder calcular un premio. Ejercicio 10.6 (Encuentra las C) ¿Cómo puedes saber qué elementos de un vector llamado simbolos son una C? Diseñe una prueba y pruébela. Desafío ¿Cómo podrías contar el número de ‘C’ en un vector llamado ‘símbolos’? Recuerda las reglas de coerción de R. Solution. Como siempre, trabajemos con un ejemplo real: simbolos &lt;- c(&quot;C&quot;, &quot;DD&quot;, &quot;C&quot;) Una forma de probar las cerezas sería verificar cuál de los símbolos, si alguno, es una C: simbolos == &quot;C&quot; ## TRUE FALSE TRUE Sería aún más útil contar cuántos de los símbolos son cerezas. Puede hacer esto con sum, que espera una entrada numérica, no lógica. Sabiendo esto, R forzará los TRUE y FALSE a 1 y 0 antes de hacer la suma. Como resultado, sum devolverá el número de TRUE, que también es el número de cerezas: sum(simbolos == &quot;C&quot;) ## 2 Puede usar el mismo método para contar la cantidad de diamantes en simbolos: sum(simbolos == &quot;DD&quot;) ## 1 Agreguemos estas dos subtareas al esqueleto del programa: iguales &lt;- simbolos[1] == simbolos[2] &amp;&amp; simbolos[2] == simbolos[3] barras &lt;- simbolos %in% c(&quot;B&quot;, &quot;BB&quot;, &quot;BBB&quot;) if (iguales) { pagos &lt;- c(&quot;DD&quot; = 100, &quot;7&quot; = 80, &quot;BBB&quot; = 40, &quot;BB&quot; = 25, &quot;B&quot; = 10, &quot;C&quot; = 10, &quot;0&quot; = 0) premio &lt;- unname(pagos[simbolos[1]]) } else if (all(barras)) { premio &lt;- 5 } else { cerezas &lt;- sum(simbolos == &quot;C&quot;) premio &lt;- # calcular el premio } diamantes &lt;- sum(simbolos == &quot;DD&quot;) # duplicar el premio si es necesario Dado que el Caso 3 aparece más abajo en el árbol if que los Casos 1 y 2, el código del Caso 3 solo se aplicará a los jugadores que no tengan trío o todas las barras. De acuerdo con el esquema de pagos de la máquina tragamonedas, estos jugadores ganarán $5 si tienen dos cerezas y $2 si tienen una cereza. Si el jugador no tiene cerezas, obtiene un premio de $0. No necesitamos preocuparnos por tres cerezas porque ese resultado ya está cubierto en el Caso 1. Como en el Caso 1, podría escribir un árbol if que maneje cada combinación de cerezas, pero al igual que en el Caso 1, esta sería una solución ineficiente: if (cerezas == 2) { premio &lt;- 5 } else if (cerezas == 1) { premio &lt;- 2 } else {} premio &lt;- 0 } Nuevamente, creo que la mejor solución implicará subconjuntos. Si se siente ambicioso, puede intentar resolver esta solución por su cuenta, pero aprenderá con la misma rapidez trabajando mentalmente en la siguiente solución propuesta. Sabemos que nuestro premio debe ser $0 si no tenemos cerezas, $2 si tenemos una cereza y $5 si tenemos dos cerezas. Puede crear un vector que contenga esta información. Esta será una tabla de búsqueda muy simple: c(0, 2, 5) Ahora, como en el Caso 1, puede crear subconjuntos del vector para recuperar el premio correcto. En este caso, los premios no se identifican con el nombre de un símbolo, sino con el número de cerezas presentes. ¿Tenemos esa información? Sí, se almacena en cerezas. Podemos usar subconjuntos enteros básicos para obtener el premio correcto de la tabla de búsqueda anterior, por ejemplo, c(0, 2, 5)[1]. cerezas no es exactamente adecuado para subconjuntos enteros porque podría contener un cero, pero eso es fácil de arreglar. Podemos crear un subconjunto con cerezas + 1. Ahora, cuando cerezas es igual a cero, tenemos: cerezas + 1 ## 1 c(0, 2, 5)[cerezas + 1] ## 0 Cuando cerezas es igual a uno, tenemos: cerezas + 1 ## 2 c(0, 2, 5)[cerezas + 1] ## 2 Y cuando cerezas es igual a dos, tenemos: cerezas + 1 ## 3 c(0, 2, 5)[cerezas + 1] ## 5 Examine estas soluciones hasta que esté seguro de que arrojan el premio correcto por cada número de cerezas. Luego agregue el código a su secuencia de comandos, de la siguiente manera: iguales &lt;- simbolos[1] == simbolos[2] &amp;&amp; simbolos[2] == simbolos[3] barras &lt;- simbolos %in% c(&quot;B&quot;, &quot;BB&quot;, &quot;BBB&quot;) if (iguales) { pagos &lt;- c(&quot;DD&quot; = 100, &quot;7&quot; = 80, &quot;BBB&quot; = 40, &quot;BB&quot; = 25, &quot;B&quot; = 10, &quot;C&quot; = 10, &quot;0&quot; = 0) premio &lt;- unname(pagos[simbolos[1]]) } else if (all(barras)) { premio &lt;- 5 } else { cerezas &lt;- sum(simbolos == &quot;C&quot;) premio &lt;- c(0, 2, 5)[cerezas + 1] } diamantes &lt;- sum(simbolos == &quot;DD&quot;) # duplicar el premio si es necesario Tablas de Búsqueda vs Árboles if Esta es la segunda vez que creamos una tabla de búsqueda para evitar escribir un árbol if. ¿Por qué es útil esta técnica y por qué sigue apareciendo? Muchos árboles if en R son esenciales. Proporcionan una forma útil de decirle a R que use diferentes algoritmos en diferentes casos. Sin embargo, los árboles if no son apropiados en todas partes. Los if árboles tienen un par de inconvenientes. En primer lugar, requieren que R ejecute varias pruebas a medida que avanza por el árbol if, lo que puede generar trabajo innecesario. En segundo lugar, como verá en Velocidad, puede ser difícil usar árboles if en código vectorizado, un estilo de código que aprovecha las fortalezas de programación de R para crear programas rápidos. Las tablas de búsqueda no sufren ninguno de estos inconvenientes. No podrá reemplazar cada árbol if con una tabla de búsqueda, ni debería hacerlo. Sin embargo, generalmente puede usar tablas de búsqueda para evitar asignar variables con árboles if. Como regla general, use un árbol if si cada rama del árbol ejecuta un código diferente. Use una tabla de búsqueda si cada rama del árbol solo asigna un valor diferente. Para convertir un árbol if en una tabla de búsqueda, identifique los valores que se asignarán y guárdelos en un vector. A continuación, identifique los criterios de selección utilizados en las condiciones del árbol if. Si las condiciones usan cadenas de caracteres, proporcione los nombres de sus vectores y use subconjuntos basados en nombres. Si las condiciones usan números enteros, use subconjuntos basados en números enteros. La subtarea final es duplicar el premio una vez por cada diamante presente. Esto significa que el premio final será un múltiplo del premio actual. Por ejemplo, si no hay diamantes presentes, el premio será: premio * 1 # 1 = 2 ^ 0 Si un diamante está presente, será: premio * 2 # 2 = 2 ^ 1 Si hay dos diamantes presentes, será: premio * 4 # 4 = 2 ^ 2 Y si hay tres diamantes presentes, será: premio * 8 # 8 = 2 ^ 3 ¿Puedes pensar en una manera fácil de manejar esto? ¿Qué tal algo similar a estos ejemplos? Ejercicio 10.7 (Adjuste para Diamantes) Escribe un método para ajustar el premio basado en diamantes. Describa primero una solución en español y luego escriba su código. Solution. Aquí hay una solución concisa inspirada en el patrón anterior. El premio ajustado será igual a: premio * 2 ^ diamantes lo que nos da nuestro script final de puntuacion: iguales &lt;- simbolos[1] == simbolos[2] &amp;&amp; simbolos[2] == simbolos[3] barras &lt;- simbolos %in% c(&quot;B&quot;, &quot;BB&quot;, &quot;BBB&quot;) if (iguales) { pagos &lt;- c(&quot;DD&quot; = 100, &quot;7&quot; = 80, &quot;BBB&quot; = 40, &quot;BB&quot; = 25, &quot;B&quot; = 10, &quot;C&quot; = 10, &quot;0&quot; = 0) premio &lt;- unname(pagos[simbolos[1]]) } else if (all(barras)) { premio &lt;- 5 } else { cerezas &lt;- sum(simbolos == &quot;C&quot;) premio &lt;- c(0, 2, 5)[cerezas + 1] } diamantes &lt;- sum(simbolos == &quot;DD&quot;) premio * 2 ^ diamantes 10.5 Comentarios de Código Ahora tiene un script de puntuacion que puede guardar en una función. Sin embargo, antes de guardar su secuencia de comandos, considere agregar comentarios a su código con un #. Los comentarios pueden hacer que su código sea más fácil de entender al explicar por qué el código hace lo que hace. También puede usar comentarios para dividir programas largos en fragmentos escaneables. Por ejemplo, incluiría tres comentarios en el código puntuacion: # identificar caso iguales &lt;- simbolos[1] == simbolos[2] &amp;&amp; simbolos[2] == simbolos[3] barras &lt;- simbolos %in% c(&quot;B&quot;, &quot;BB&quot;, &quot;BBB&quot;) # obtener premio if (iguales) { pagos &lt;- c(&quot;DD&quot; = 100, &quot;7&quot; = 80, &quot;BBB&quot; = 40, &quot;BB&quot; = 25, &quot;B&quot; = 10, &quot;C&quot; = 10, &quot;0&quot; = 0) premio &lt;- unname(pagos[simbolos[1]]) } else if (all(barras)) { premio &lt;- 5 } else { cerezas &lt;- sum(simbolos == &quot;C&quot;) premio &lt;- c(0, 2, 5)[cerezas + 1] } # ajustar para diamantes diamantes &lt;- sum(simbolos == &quot;DD&quot;) premio * 2 ^ diamantes Ahora que cada parte de tu código funciona, puedes envolverlo en una función con los métodos que aprendiste en Escribir tus propias funciones. Utilice la opción Extract Function de RStudio en la barra de menú en Code, o utilice la función function. Asegúrese de que la última línea de la función devuelva un resultado (lo hace) e identifique los argumentos utilizados por su función. A menudo, los ejemplos concretos que utilizó para probar su código, como símbolos, se convertirán en los argumentos de su función. Ejecute el siguiente código para comenzar a usar la función puntuacion: puntuacion &lt;- function (simbolos) { # identificar caso iguales &lt;- simbolos[1] == simbolos[2] &amp;&amp; simbolos[2] == simbolos[3] barras &lt;- simbolos %in% c(&quot;B&quot;, &quot;BB&quot;, &quot;BBB&quot;) # obtener premio if (iguales) { pagos &lt;- c(&quot;DD&quot; = 100, &quot;7&quot; = 80, &quot;BBB&quot; = 40, &quot;BB&quot; = 25, &quot;B&quot; = 10, &quot;C&quot; = 10, &quot;0&quot; = 0) premio &lt;- unname(pagos[simbolos[1]]) } else if (all(barras)) { premio &lt;- 5 } else { cerezas &lt;- sum(simbolos == &quot;C&quot;) premio &lt;- c(0, 2, 5)[cerezas + 1] } # ajustar para diamantes diamantes &lt;- sum(simbolos == &quot;DD&quot;) premio * 2 ^ diamantes } Una vez que haya definido la función puntuacion, la función play también funcionará: play &lt;- function() { simbolos &lt;- obt_simbolos() print(simbolos) puntuacion(simbolos) } Ahora es fácil jugar en la máquina tragamonedas: play() ## &quot;0&quot; &quot;BB&quot; &quot;B&quot; ## 0 play() ## &quot;DD&quot; &quot;0&quot; &quot;B&quot; ## 0 play() ## &quot;BB&quot; &quot;BB&quot; &quot;B&quot; ## 25 10.6 Resumen Un programa en R es un conjunto de instrucciones que su computadora debe seguir y que se ha organizado en una secuencia de pasos y casos. Esto puede hacer que los programas parezcan simples, pero no se deje engañar: puede crear resultados complicados con la combinación correcta de pasos simples (y casos). Como programador, es más probable que te engañen de la manera opuesta. Un programa puede parecer imposible de escribir cuando sabes que debe hacer algo impresionante. No se asuste en estas situaciones. Divida el trabajo que tiene delante en tareas simples y luego vuelva a dividir las tareas. Puede visualizar la relación entre las tareas con un diagrama de flujo si le ayuda. Luego trabaje en las subtareas una a la vez. Describa las soluciones en español y luego conviértalas a código de R. Pruebe cada solución con ejemplos concretos a medida que avanza. Una vez que cada una de sus subtareas funcione, combine su código en una función que pueda compartir y reutilizar. R proporciona herramientas que pueden ayudarlo a hacer esto. Puede administrar casos con declaraciones if y else. Puede crear una tabla de búsqueda con objetos y subconjuntos. Puede agregar comentarios de código con #. Y puede guardar sus programas como una función con function Las cosas suelen salir mal cuando la gente escribe programas. Dependerá de usted encontrar la fuente de cualquier error que ocurra y corregirlo. Debería ser fácil encontrar la fuente de sus errores si utiliza un enfoque paso a paso para escribir funciones, escribir y luego probar, un poco a la vez. Sin embargo, si la fuente de un error se le escapa, o se encuentra trabajando con grandes fragmentos de código no probado, considere usar las herramientas de depuración integradas de R, descritas en Depuración de Código de R. Los siguientes dos capítulos le enseñarán más herramientas que puede usar en sus programas. A medida que domine estas herramientas, le resultará más fácil escribir programas en R que le permitan hacer lo que desee con sus datos. En S3, aprenderá a usar el sistema S3 de R, una mano invisible que da forma a muchas partes de R. Usará el sistema para crear una clase personalizada para la salida de su máquina tragamonedas y le dirá a R cómo mostrar objetos que tienen tu clase. "],["s3.html", "11 S3 11.1 The S3 System 11.2 Attributes 11.3 Generic Functions 11.4 Methods 11.5 Classes 11.6 S3 and Debugging 11.7 S4 and R5 11.8 Summary", " 11 S3 You may have noticed that your slot machine results do not look the way I promised they would. I suggested that the slot machine would display its results like this: play() ## 0 0 DD ## $0 But the current machine displays its results in a less pretty format: play() ## &quot;0&quot; &quot;0&quot; &quot;DD&quot; ## 0 Moreover, the slot machine uses a hack to display symbols (we call print from within play). As a result, the symbols do not follow your prize output if you save it: one_play &lt;- play() ## &quot;B&quot; &quot;0&quot; &quot;B&quot; one_play ## 0 You can fix both of these problems with R’s S3 system. 11.1 The S3 System S3 refers to a class system built into R. The system governs how R handles objects of different classes. Certain R functions will look up an object’s S3 class, and then behave differently in response. The print function is like this. When you print a numeric vector, print will display a number: num &lt;- 1000000000 print(num) ## 1000000000 But if you give that number the S3 class POSIXct followed by POSIXt, print will display a time: class(num) &lt;- c(&quot;POSIXct&quot;, &quot;POSIXt&quot;) print(num) ## &quot;2001-09-08 19:46:40 CST&quot; If you use objects with classes—and you do—you will run into R’s S3 system. S3 behavior can seem odd at first, but is easy to predict once you are familiar with it. R’s S3 system is built around three components: attributes (especially the class attribute), generic functions, and methods. 11.2 Attributes In Attributes, you learned that many R objects come with attributes, pieces of extra information that are given a name and appended to the object. Attributes do not affect the values of the object, but stick to the object as a type of metadata that R can use to handle the object. For example, a data frame stores its row and column names as attributes. Data frames also store their class, \"data.frame\", as an attribute. You can see an object’s attributes with attribute. If you run attribute on the deck data frame that you created in [Project 2: Playing Cards], you will see: attributes(deck) ## $names ## [1] &quot;face&quot; &quot;suit&quot; &quot;value&quot; ## ## $class ## [1] &quot;data.frame&quot; ## ## $row.names ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ## [20] 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 ## [37] 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 R comes with many helper functions that let you set and access the most common attributes used in R. You’ve already met the names, dim, and class functions, which each work with an eponymously named attribute. However, R also has row.names, levels, and many other attribute-based helper functions. You can use any of these functions to retrieve an attribute’s value: row.names(deck) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; &quot;10&quot; &quot;11&quot; &quot;12&quot; &quot;13&quot; ## [14] &quot;14&quot; &quot;15&quot; &quot;16&quot; &quot;17&quot; &quot;18&quot; &quot;19&quot; &quot;20&quot; &quot;21&quot; &quot;22&quot; &quot;23&quot; &quot;24&quot; &quot;25&quot; &quot;26&quot; ## [27] &quot;27&quot; &quot;28&quot; &quot;29&quot; &quot;30&quot; &quot;31&quot; &quot;32&quot; &quot;33&quot; &quot;34&quot; &quot;35&quot; &quot;36&quot; &quot;37&quot; &quot;38&quot; &quot;39&quot; ## [40] &quot;40&quot; &quot;41&quot; &quot;42&quot; &quot;43&quot; &quot;44&quot; &quot;45&quot; &quot;46&quot; &quot;47&quot; &quot;48&quot; &quot;49&quot; &quot;50&quot; &quot;51&quot; &quot;52&quot; or to change an attribute’s value: row.names(deck) &lt;- 101:152 or to give an object a new attribute altogether: levels(deck) &lt;- c(&quot;level 1&quot;, &quot;level 2&quot;, &quot;level 3&quot;) attributes(deck) ## $names ## [1] &quot;face&quot; &quot;suit&quot; &quot;value&quot; ## ## $class ## [1] &quot;data.frame&quot; ## ## $row.names ## [1] 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 ## [18] 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 ## [35] 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 ## [52] 152 ## ## $levels ## [1] &quot;level 1&quot; &quot;level 2&quot; &quot;level 3&quot; R is very laissez faire when it comes to attributes. It will let you add any attributes that you like to an object (and then it will usually ignore them). The only time R will complain is when a function needs to find an attribute and it is not there. You can add any general attribute to an object with attr; you can also use attr to look up the value of any attribute of an object. Let’s see how this works with one_play, the result of playing our slot machine one time: one_play &lt;- play() one_play ## 0 attributes(one_play) ## NULL attr takes two arguments: an R object and the name of an attribute (as a character string). To give the R object an attribute of the specified name, save a value to the output of attr. Let’s give one_play an attribute named symbols that contains a vector of character strings: attr(one_play, &quot;symbols&quot;) &lt;- c(&quot;B&quot;, &quot;0&quot;, &quot;B&quot;) attributes(one_play) ## $symbols ## [1] &quot;B&quot; &quot;0&quot; &quot;B&quot; To look up the value of any attribute, give attr an R object and the name of the attribute you would like to look up: attr(one_play, &quot;symbols&quot;) ## &quot;B&quot; &quot;0&quot; &quot;B&quot; If you give an attribute to an atomic vector, like one_play, R will usually display the attribute beneath the vector’s values. However, if the attribute changes the vector’s class, R may display all of the information in the vector in a new way (as we saw with POSIXct objects): one_play ## [1] 0 ## attr(,&quot;symbols&quot;) ## [1] &quot;B&quot; &quot;0&quot; &quot;B&quot; R will generally ignore an object’s attributes unless you give them a name that an R function looks for, like names or class. For example, R will ignore the symbols attribute of one_play as you manipulate one_play: one_play + 1 ## 1 ## attr(,&quot;symbols&quot;) ## &quot;B&quot; &quot;0&quot; &quot;B&quot; Exercise 11.1 (Add an Attribute) Modify play to return a prize that contains the symbols associated with it as an attribute named symbols. Remove the redundant call to print(symbols): play &lt;- function() { symbols &lt;- get_symbols() print(symbols) score(symbols) } Solution. You can create a new version of play by capturing the output of score(symbols) and assigning an attribute to it. play can then return the enhanced version of the output: play &lt;- function() { symbols &lt;- get_symbols() prize &lt;- score(symbols) attr(prize, &quot;symbols&quot;) &lt;- symbols prize } Now play returns both the prize and the symbols associated with the prize. The results may not look pretty, but the symbols stick with the prize when we copy it to a new object. We can work on tidying up the display in a minute: play() ## [1] 0 ## attr(,&quot;symbols&quot;) ## [1] &quot;B&quot; &quot;BB&quot; &quot;0&quot; two_play &lt;- play() two_play ## [1] 0 ## attr(,&quot;symbols&quot;) ## [1] &quot;0&quot; &quot;B&quot; &quot;0&quot; You can also generate a prize and set its attributes in one step with the structure function. structure creates an object with a set of attributes. The first argument of structure should be an R object or set of values, and the remaining arguments should be named attributes for structure to add to the object. You can give these arguments any argument names you like. structure will add the attributes to the object under the names that you provide as argument names: play &lt;- function() { symbols &lt;- get_symbols() structure(score(symbols), symbols = symbols) } three_play &lt;- play() three_play ## 0 ## attr(,&quot;symbols&quot;) ## &quot;0&quot; &quot;BB&quot; &quot;B&quot; Now that your play output contains a symbols attribute, what can you do with it? You can write your own functions that lookup and use the attribute. For example, the following function will look up one_play’s symbols attribute and use it to display one_play in a pretty manner. We will use this function to display our slot results, so let’s take a moment to study what it does: slot_display &lt;- function(prize){ # extract symbols symbols &lt;- attr(prize, &quot;symbols&quot;) # collapse symbols into single string symbols &lt;- paste(symbols, collapse = &quot; &quot;) # combine symbol with prize as a character string # \\n is special escape sequence for a new line (i.e. return or enter) string &lt;- paste(symbols, prize, sep = &quot;\\n$&quot;) # display character string in console without quotes cat(string) } slot_display(one_play) ## B 0 B ## $0 The function expects an object like one_play that has both a numerical value and a symbols attribute. The first line of the function will look up the value of the symbols attribute and save it as an object named symbols. Let’s make an example symbols object so we can see what the rest of the function does. We can use one_play’s symbols attribute to do the job. symbols will be a vector of three-character strings: symbols &lt;- attr(one_play, &quot;symbols&quot;) symbols ## &quot;B&quot; &quot;0&quot; &quot;B&quot; Next, slot_display uses paste to collapse the three strings in symbols into a single-character string. paste collapses a vector of character strings into a single string when you give it the collapse argument. paste will use the value of collapse to separate the formerly distinct strings. Hence, symbols becomes B 0 B the three strings separated by a space: symbols &lt;- paste(symbols, collapse = &quot; &quot;) symbols ## &quot;B 0 B&quot; Our function then uses paste in a new way to combine symbols with the value of prize. paste combines separate objects into a character string when you give it a sep argument. For example, here paste will combine the string in symbols, B 0 B, with the number in prize, 0. paste will use the value of sep argument to separate the inputs in the new string. Here, that value is \\n$, so our result will look like \"B 0 B\\n$0\": prize &lt;- one_play string &lt;- paste(symbols, prize, sep = &quot;\\n$&quot;) string ## &quot;B 0 B\\n$0&quot; The last line of slot_display calls cat on the new string. cat is like print; it displays its input at the command line. However, cat does not surround its output with quotation marks. cat also replaces every \\n with a new line or line break. The result is what we see. Notice that it looks just how I suggested that our play output should look in [Programs]: cat(string) ## B 0 B ## $0 You can use slot_display to manually clean up the output of play: slot_display(play()) ## C B 0 ## $2 slot_display(play()) ## 7 0 BB ## $0 This method of cleaning the output requires you to manually intervene in your R session (to call slot_display). There is a function that you can use to automatically clean up the output of play each time it is displayed. This function is print, and it is a generic function. 11.3 Generic Functions R uses print more often than you may think; R calls print each time it displays a result in your console window. This call happens in the background, so you do not notice it; but the call explains how output makes it to the console window (recall that print always prints its argument in the console window). This print call also explains why the output of print always matches what you see when you display an object at the command line: print(pi) ## 3.141593 pi ## 3.141593 print(head(deck)) ## face suit value ## king spades 13 ## queen spades 12 ## jack spades 11 ## ten spades 10 ## nine spades 9 ## eight spades 8 head(deck) ## face suit value ## king spades 13 ## queen spades 12 ## jack spades 11 ## ten spades 10 ## nine spades 9 ## eight spades 8 print(play()) ## 5 ## attr(,&quot;symbols&quot;) ## &quot;B&quot; &quot;BB&quot; &quot;B&quot; play() ## 5 ## attr(,&quot;symbols&quot;) ## &quot;B&quot; &quot;BB&quot; &quot;B&quot; You can change how R displays your slot output by rewriting print to look like slot_display. Then R would print the output in our tidy format. However, this method would have negative side effects. You do not want R to call slot_display when it prints a data frame, a numerical vector, or any other object. Fortunately, print is not a normal function; it is a generic function. This means that print is written in a way that lets it do different things in different cases. You’ve already seen this behavior in action (although you may not have realized it). print did one thing when we looked at the unclassed version of num: num &lt;- 1000000000 print(num) ## 1000000000 and a different thing when we gave num a class: class(num) &lt;- c(&quot;POSIXct&quot;, &quot;POSIXt&quot;) print(num) ## &quot;2001-09-08 19:46:40 CST&quot; Take a look at the code inside print to see how it does this. You may imagine that print looks up the class attribute of its input and then uses an +if+ tree to pick which output to display. If this occurred to you, great job! print does something very similar, but much more simple. 11.4 Methods When you call print, print calls a special function, UseMethod: print ## function (x, ...) ## UseMethod(&quot;print&quot;) ## &lt;bytecode: 0x7ffee4c62f80&gt; ## &lt;environment: namespace:base&gt; UseMethod examines the class of the input that you provide for the first argument of print, and then passes all of your arguments to a new function designed to handle that class of input. For example, when you give print a POSIXct object, UseMethod will pass all of print’s arguments to print.POSIXct. R will then run print.POSIXct and return the results: print.POSIXct ## function (x, ...) ## { ## max.print &lt;- getOption(&quot;max.print&quot;, 9999L) ## if (max.print &lt; length(x)) { ## print(format(x[seq_len(max.print)], usetz = TRUE), ...) ## cat(&quot; [ reached getOption(\\&quot;max.print\\&quot;) -- omitted&quot;, ## length(x) - max.print, &quot;entries ]\\n&quot;) ## } ## else print(format(x, usetz = TRUE), ...) ## invisible(x) ## } ## &lt;bytecode: 0x7fa948f3d008&gt; ## &lt;environment: namespace:base&gt; If you give print a factor object, UseMethod will pass all of print’s arguments to print.factor. R will then run print.factor and return the results: print.factor ## function (x, quote = FALSE, max.levels = NULL, width = getOption(&quot;width&quot;), ## ...) ## { ## ord &lt;- is.ordered(x) ## if (length(x) == 0L) ## cat(if (ord) ## &quot;ordered&quot; ## ... ## drop &lt;- n &gt; maxl ## cat(if (drop) ## paste(format(n), &quot;&quot;), T0, paste(if (drop) ## c(lev[1L:max(1, maxl - 1)], &quot;...&quot;, if (maxl &gt; 1) lev[n]) ## else lev, collapse = colsep), &quot;\\n&quot;, sep = &quot;&quot;) ## } ## invisible(x) ## } ## &lt;bytecode: 0x7fa94a64d470&gt; ## &lt;environment: namespace:base&gt; print.POSIXct and print.factor are called methods of print. By themselves, print.POSIXct and print.factor work like regular R functions. However, each was written specifically so UseMethod could call it to handle a specific class of print input. Notice that print.POSIXct and print.factor do two different things (also notice that I abridged the middle of print.factor—it is a long function). This is how print manages to do different things in different cases. print calls UseMethod, which calls a specialized method based on the class of print’s first argument. You can see which methods exist for a generic function by calling methods on the function. For example, print has almost 200 methods (which gives you an idea of how many classes exist in R): methods(print) ## [1] print.acf* ## [2] print.anova ## [3] print.aov* ## ... ## [176] print.xgettext* ## [177] print.xngettext* ## [178] print.xtabs* ## ## Nonvisible functions are asterisked This system of generic functions, methods, and class-based dispatch is known as S3 because it originated in the third version of S, the programming language that would evolve into S-PLUS and R. Many common R functions are S3 generics that work with a set of class methods. For example, summary and head also call UseMethod. More basic functions, like c, +, -, &lt; and others also behave like generic functions, although they call .primitive instead of UseMethod. The S3 system allows R functions to behave in different ways for different classes. You can use S3 to format your slot output. First, give your output its own class. Then write a print method for that class. To do this efficiently, you will need to know a little about how UseMethod selects a method function to use. 11.4.1 Method Dispatch UseMethod uses a very simple system to match methods to functions. Every S3 method has a two-part name. The first part of the name will refer to the function that the method works with. The second part will refer to the class. These two parts will be separated by a period. So for example, the print method that works with functions will be called print.function. The summary method that works with matrices will be called summary.matrix. And so on. When UseMethod needs to call a method, it searches for an R function with the correct S3-style name. The function does not have to be special in any way; it just needs to have the correct name. You can participate in this system by writing your own function and giving it a valid S3-style name. For example, let’s give one_play a class of its own. It doesn’t matter what you call the class; R will store any character string in the class attribute: class(one_play) &lt;- &quot;slots&quot; Now let’s write an S3 print method for the +slots+ class. The method doesn’t need to do anything special—it doesn’t even need to print one_play. But it does need to be named print.slots; otherwise UseMethod will not find it. The method should also take the same arguments as print; otherwise, R will give an error when it tries to pass the arguments to print.slots: args(print) ## function (x, ...) ## NULL print.slots &lt;- function(x, ...) { cat(&quot;I&#39;m using the print.slots method&quot;) } Does our method work? Yes, and not only that; R uses the print method to display the contents of one_play. This method isn’t very useful, so I’m going to remove it. You’ll have a chance to write a better one in a minute: print(one_play) ## I&#39;m using the print.slots method one_play ## I&#39;m using the print.slots method rm(print.slots) Some R objects have multiple classes. For example, the output of Sys.time has two classes. Which class will UseMethod use to find a print method? now &lt;- Sys.time() attributes(now) ## $class ## [1] &quot;POSIXct&quot; &quot;POSIXt&quot; UseMethod will first look for a method that matches the first class listed in the object’s class vector. If UseMethod cannot find one, it will then look for the method that matches the second class (and so on if there are more classes in an object’s class vector). If you give print an object whose class or classes do not have a print method, UseMethod will call print.default, a special method written to handle general cases. Let’s use this system to write a better print method for the slot machine output. Exercise 11.2 (Make a Print Method) Write a new print method for the slots class. The method should call slot_display to return well-formatted slot-machine output. What name must you use for this method? Solution. It is surprisingly easy to write a good print.slots method because we’ve already done all of the hard work when we wrote slot_display. For example, the following method will work. Just make sure the method is named print.slots so UseMethod can find it, and make sure that it takes the same arguments as print so UseMethod can pass those arguments to print.slots without any trouble: print.slots &lt;- function(x, ...) { slot_display(x) } Now R will automatically use slot_display to display objects of class +slots+ (and only objects of class “slots”): one_play ## B 0 B ## $0 Let’s ensure that every piece of slot machine output has the slots class. Exercise 11.3 (Add a Class) Modify the play function so it assigns slots to the class attribute of its output: play &lt;- function() { symbols &lt;- get_symbols() structure(score(symbols), symbols = symbols) } Solution. You can set the class attribute of the output at the same time that you set the +symbols+ attribute. Just add class = \"slots\" to the structure call: play &lt;- function() { symbols &lt;- get_symbols() structure(score(symbols), symbols = symbols, class = &quot;slots&quot;) } Now each of our slot machine plays will have the class slots: class(play()) ## &quot;slots&quot; As a result, R will display them in the correct slot-machine format: play() ## BB BB BBB ## $5 play() ## BB 0 0 ## $0 11.5 Classes You can use the S3 system to make a robust new class of objects in R. Then R will treat objects of your class in a consistent, sensible manner. To make a class: Choose a name for your class. Assign each instance of your class a +class+ attribute. Write class methods for any generic function likely to use objects of your class. Many R packages are based on classes that have been built in a similar manner. While this work is simple, it may not be easy. For example, consider how many methods exist for predefined classes. You can call methods on a class with the class argument, which takes a character string. methods will return every method written for the class. Notice that methods will not be able to show you methods that come in an unloaded R package: methods(class = &quot;factor&quot;) ## [1] [.factor [[.factor ## [3] [[&lt;-.factor [&lt;-.factor ## [5] all.equal.factor as.character.factor ## [7] as.data.frame.factor as.Date.factor ## [9] as.list.factor as.logical.factor ## [11] as.POSIXlt.factor as.vector.factor ## [13] droplevels.factor format.factor ## [15] is.na&lt;-.factor length&lt;-.factor ## [17] levels&lt;-.factor Math.factor ## [19] Ops.factor plot.factor* ## [21] print.factor relevel.factor* ## [23] relist.factor* rep.factor ## [25] summary.factor Summary.factor ## [27] xtfrm.factor ## ## Nonvisible functions are asterisked This output indicates how much work is required to create a robust, well-behaved class. You will usually need to write a class method for every basic R operation. Consider two challenges that you will face right away. First, R drops attributes (like class) when it combines objects into a vector: play1 &lt;- play() play1 ## B BBB BBB ## $5 play2 &lt;- play() play2 ## 0 B 0 ## $0 c(play1, play2) ## [1] 5 0 Here, R stops using print.slots to display the vector because the vector c(play1, play2) no longer has a “slots” +class+ attribute. Next, R will drop the attributes of an object (like class) when you subset the object: play1[1] ## [1] 5 You can avoid this behavior by writing a c.slots method and a [.slots method, but then difficulties will quickly accrue. How would you combine the symbols attributes of multiple plays into a vector of symbols attributes? How would you change print.slots to handle vectors of outputs? These challenges are open for you to explore. However, you will usually not have to attempt this type of large-scale programming as a data scientist. In our case, it is very handy to let slots objects revert to single prize values when we combine groups of them together into a vector. 11.6 S3 and Debugging S3 can be annoying if you are trying to understand R functions. It is difficult to tell what a function does if its code body contains a call to UseMethod. Now that you know that UseMethod calls a class-specific method, you can search for and examine the method directly. It will be a function whose name follows the &lt;function.class&gt; syntax, or possibly &lt;function.default&gt;. You can also use the methods function to see what methods are associated with a function or a class. 11.7 S4 and R5 R also contains two other systems that create class specific behavior. These are known as S4 and R5 (or reference classes). Each of these systems is much harder to use than S3, and perhaps as a consequence, more rare. However, they offer safeguards that S3 does not. If you’d like to learn more about these systems, including how to write and use your own generic functions, I recommend the book Advanced R Programming by Hadley Wickham. 11.8 Summary Values are not the only place to store information in R, and functions are not the only way to create unique behavior. You can also do both of these things with R’s S3 system. The S3 system provides a simple way to create object-specific behavior in R. In other words, it is R’s version of object-oriented programming (OOP). The system is implemented by generic functions. These functions examine the class attribute of their input and call a class-specific method to generate output. Many S3 methods will look for and use additional information that is stored in an object’s attributes. Many common R functions are S3 generics. R’s S3 system is more helpful for the tasks of computer science than the tasks of data science, but understanding S3 can help you troubleshoot your work in R as a data scientist. You now know quite a bit about how to write R code that performs custom tasks, but how could you repeat these tasks? As a data scientist, you will often repeat tasks, sometimes thousands or even millions of times. Why? Because repetition lets you simulate results and estimate probabilities. Loops will show you how to automate repetition with R’s for and while functions. You’ll use for to simulate various slot machine plays and to calculate the payout rate of your slot machine. "],["loops.html", "12 Loops 12.1 Expected Values 12.2 expand.grid 12.3 for Loops 12.4 while Loops 12.5 repeat Loops 12.6 Summary", " 12 Loops Loops are R’s method for repeating a task, which makes them a useful tool for programming simulations. This chapter will teach you how to use R’s loop tools. Let’s use the score function to solve a real-world problem. Your slot machine is modeled after real machines that were accused of fraud. The machines appeared to pay out 40 cents on the dollar, but the manufacturer claimed that they paid out 92 cents on the dollar. You can calculate the exact payout rate of your machine with the score program. The payout rate will be the expected value of the slot machine’s prize. 12.1 Expected Values The expected value of a random event is a type of weighted average; it is the sum of each possible outcome of the event, weighted by the probability that each outcome occurs: \\[ E(x) = \\sum_{i = 1}^{n}\\left( x_{i} \\cdot P(x_{i}) \\right) \\] You can think of the expected value as the average prize that you would observe if you played the slot machine an infinite number of times. Let’s use the formula to calculate some simple expected values. Then we will apply the formula to your slot machine. Do you remember the die you created in [Project 1: Weighted Dice]? die &lt;- c(1, 2, 3, 4, 5, 6) Each time you roll the die, it returns a value selected at random (one through six). You can find the expected value of rolling the die with the formula: \\[ E(\\text{die}) = \\sum_{i = 1}^{n}\\left( \\text{die}_{i} \\cdot P(\\text{die}_{i}) \\right) \\] The \\(\\text{die}_{i}\\)s are the possible outcomes of rolling the die: 1, 2, 3, 4, 5, and 6; and the \\(P(\\text{die}_{i})\\)’s are the probabilities associated with each of the outcomes. If your die is fair, each outcome will occur with the same probability: 1/6. So our equation simplifies to: \\[ \\begin{array}{rl} E(\\text{die}) &amp; = \\sum_{i = 1}^{n}\\left( \\text{die}_{i} \\cdot P(\\text{die}_{i}) \\right)\\\\ &amp; = 1 \\cdot \\frac{1}{6} + 2 \\cdot \\frac{1}{6} + 3 \\cdot \\frac{1}{6} + 4 \\cdot \\frac{1}{6} + 5 \\cdot \\frac{1}{6} + 6 \\cdot \\frac{1}{6}\\\\ &amp; = 3.5\\\\ \\end{array} \\] Hence, the expected value of rolling a fair die is 3.5. You may notice that this is also the average value of the die. The expected value will equal the average if every outcome has the same chance of occurring. But what if each outcome has a different chance of occurring? For example, we weighted our dice in [Packages and Help Pages] so that each die rolled 1, 2, 3, 4, and 5 with probability 1/8 and 6 with probability 3/8. You can use the same formula to calculate the expected value in these conditions: \\[ \\begin{array}{rl} E(die) &amp; = 1 \\cdot \\frac{1}{8} + 2 \\cdot \\frac{1}{8} + 3 \\cdot \\frac{1}{8} + 4 \\cdot \\frac{1}{8} + 5 \\cdot \\frac{1}{8} + 6 \\cdot \\frac{3}{8}\\\\ &amp; = 4.125\\\\ \\end{array} \\] Hence, the expected value of a loaded die does not equal the average value of its outcomes. If you rolled a loaded die an infinite number of times, the average outcome would be 4.125, which is higher than what you would expect from a fair die. Notice that we did the same three things to calculate both of these expected values. We have: Listed out all of the possible outcomes Determined the value of each outcome (here just the value of the die) Calculated the probability that each outcome occurred The expected value was then just the sum of the values in step 2 multiplied by the probabilities in step 3. You can use these steps to calculate more sophisticated expected values. For example, you could calculate the expected value of rolling a pair of weighted dice. Let’s do this step by step. First, list out all of the possible outcomes. A total of 36 different outcomes can appear when you roll two dice. For example, you might roll (1, 1), which notates one on the first die and one on the second die. Or, you may roll (1, 2), one on the first die and two on the second. And so on. Listing out these combinations can be tedious, but R has a function that can help. 12.2 expand.grid The expand.grid function in R provides a quick way to write out every combination of the elements in n vectors. For example, you can list every combination of two dice. To do so, run expand.grid on two copies of die: rolls &lt;- expand.grid(die, die) expand.grid will return a data frame that contains every way to pair an element from the first die vector with an element from the second die vector. This will capture all 36 possible combinations of values: rolls ## Var1 Var2 ## 1 1 1 ## 2 2 1 ## 3 3 1 ## ... ## 34 4 6 ## 35 5 6 ## 36 6 6 You can use expand.grid with more than two vectors if you like. For example, you could list every combination of rolling three dice with expand.grid(die, die, die) and every combination of rolling four dice with expand.grid(die, die, die, die), and so on. expand.grid will always return a data frame that contains each possible combination of n elements from the n vectors. Each combination will contain exactly one element from each vector. You can determine the value of each roll once you’ve made your list of outcomes. This will be the sum of the two dice, which you can calculate using R’s element-wise execution: rolls$value &lt;- rolls$Var1 + rolls$Var2 head(rolls, 3) ## Var1 Var2 value ## 1 1 2 ## 2 1 3 ## 3 1 4 R will match up the elements in each vector before adding them together. As a result, each element of value will refer to the elements of Var1 and Var2 that appear in the same row. Next, you must determine the probability that each combination appears. You can calculate this with a basic rule of probability: The probability that n independent, random events all occur is equal to the product of the probabilities that each random event occurs. Or more succinctly: \\[ P(A \\&amp; B \\&amp; C \\&amp; ...) = P(A) \\cdot P(B) \\cdot P(C) \\cdot ... \\] So the probability that we roll a (1, 1) will be equal to the probability that we roll a one on the first die, 1/8, times the probability that we roll a one on the second die, 1/8: \\[ \\begin{array}{rl} P(1 \\&amp; 1) &amp; = P(1) \\cdot P(1) \\\\ &amp; = \\frac{1}{8} \\cdot \\frac{1}{8}\\\\ &amp; = \\frac{1}{64} \\end{array} \\] And the probability that we roll a (1, 2) will be: \\[ \\begin{array}{rl} P(1 \\&amp; 2) &amp; = P(1) \\cdot P(2) \\\\ &amp; = \\frac{1}{8} \\cdot \\frac{1}{8}\\\\ &amp; = \\frac{1}{64} \\end{array} \\] And so on. Let me suggest a three-step process for calculating these probabilities in R. First, we can look up the probabilities of rolling the values in Var1. We’ll do this with the lookup table that follows: prob &lt;- c(&quot;1&quot; = 1/8, &quot;2&quot; = 1/8, &quot;3&quot; = 1/8, &quot;4&quot; = 1/8, &quot;5&quot; = 1/8, &quot;6&quot; = 3/8) prob ## 1 2 3 4 5 6 ## 0.125 0.125 0.125 0.125 0.125 0.375 If you subset this table by rolls$Var1, you will get a vector of probabilities perfectly keyed to the values of Var1: rolls$Var1 ## 1 2 3 4 5 6 1 2 3 4 5 6 1 2 3 4 5 6 1 2 3 4 5 6 1 2 3 4 5 6 1 2 3 4 5 6 prob[rolls$Var1] ## 1 2 3 4 5 6 1 2 3 4 5 6 ## 0.125 0.125 0.125 0.125 0.125 0.375 0.125 0.125 0.125 0.125 0.125 0.375 ## 1 2 3 4 5 6 1 2 3 4 5 6 ## 0.125 0.125 0.125 0.125 0.125 0.375 0.125 0.125 0.125 0.125 0.125 0.375 ## 1 2 3 4 5 6 1 2 3 4 5 6 ## 0.125 0.125 0.125 0.125 0.125 0.375 0.125 0.125 0.125 0.125 0.125 0.375 rolls$prob1 &lt;- prob[rolls$Var1] head(rolls, 3) ## Var1 Var2 value prob1 ## 1 1 2 0.125 ## 2 1 3 0.125 ## 3 1 4 0.125 Second, we can look up the probabilities of rolling the values in Var2: rolls$prob2 &lt;- prob[rolls$Var2] head(rolls, 3) ## Var1 Var2 value prob1 prob2 ## 1 1 2 0.125 0.125 ## 2 1 3 0.125 0.125 ## 3 1 4 0.125 0.125 Third, we can calculate the probability of rolling each combination by multiplying prob1 by prob2: rolls$prob &lt;- rolls$prob1 * rolls$prob2 head(rolls, 3) ## Var1 Var2 value prob1 prob2 prob ## 1 1 2 0.125 0.125 0.015625 ## 2 1 3 0.125 0.125 0.015625 ## 3 1 4 0.125 0.125 0.015625 It is easy to calculate the expected value now that we have each outcome, the value of each outcome, and the probability of each outcome. The expected value will be the summation of the dice values multiplied by the dice probabilities: sum(rolls$value * rolls$prob) ## 8.25 So the expected value of rolling two loaded dice is 8.25. If you rolled a pair of loaded dice an infinite number of times, the average sum would be 8.25. (If you are curious, the expected value of rolling a pair of fair dice is 7, which explains why 7 plays such a large role in dice games like craps.) Now that you’ve warmed up, let’s use our method to calculate the expected value of the slot machine prize. We will follow the same steps we just took: We will list out every possible outcome of playing the machine. This will be a list of every combination of three slot symbols. We will calculate the probability of getting each combination when you play the machine. We will determine the prize that we would win for each combination. When we are finished, we will have a data set that looks like this: ## Var1 Var2 Var3 prob1 prob2 prob3 prob prize ## DD DD DD 0.03 0.03 0.03 0.000027 800 ## 7 DD DD 0.03 0.03 0.03 0.000027 0 ## BBB DD DD 0.06 0.03 0.03 0.000054 0 ## ... and so on. The expected value will then be the sum of the prizes multiplied by their probability of occuring: \\[ E(\\text{prize}) = \\sum_{i = 1}^{n}\\left( \\text{prize}_{i} \\cdot P(\\text{prize}_{i}) \\right) \\] Ready to begin? Exercise 12.1 (List the Combinations) Use expand.grid to make a data frame that contains every possible combination of three symbols from the wheel vector: wheel &lt;- c(&quot;DD&quot;, &quot;7&quot;, &quot;BBB&quot;, &quot;BB&quot;, &quot;B&quot;, &quot;C&quot;, &quot;0&quot;) Be sure to add the argument stringsAsFactors = FALSE to your expand.grid call; otherwise, expand.grid will save the combinations as factors, an unfortunate choice that will disrupt the score function. Solution. To create a data frame of each combination of three symbols, you need to run expand.grid and give it three copies of wheel. The result will be a data frame with 343 rows, one for each unique combination of three slot symbols: combos &lt;- expand.grid(wheel, wheel, wheel, stringsAsFactors = FALSE) combos ## Var1 Var2 Var3 ## 1 DD DD DD ## 2 7 DD DD ## 3 BBB DD DD ## 4 BB DD DD ## 5 B DD DD ## 6 C DD DD ## ... ## 341 B 0 0 ## 342 C 0 0 ## 343 0 0 0 Now, let’s calculate the probability of getting each combination. You can use the probabilities contained in the prob argument of get_symbols to do this. These probabilities determine how frequently each symbol is chosen when your slot machine generates symbols. They were calculated after observing 345 plays of the Manitoba video lottery terminals. Zeroes have the largest chance of being selected (0.52) and cherries the least (0.01): get_symbols &lt;- function() { wheel &lt;- c(&quot;DD&quot;, &quot;7&quot;, &quot;BBB&quot;, &quot;BB&quot;, &quot;B&quot;, &quot;C&quot;, &quot;0&quot;) sample(wheel, size = 3, replace = TRUE, prob = c(0.03, 0.03, 0.06, 0.1, 0.25, 0.01, 0.52) } Exercise 12.2 (Make a Lookup Table) Isolate the previous probabilities in a lookup table. What names will you use in your table? Solution. Your names should match the input that you want to look up. In this case, the input will be the character strings that appear in Var1, Var2, and Var3. So your lookup table should look like this: prob &lt;- c(&quot;DD&quot; = 0.03, &quot;7&quot; = 0.03, &quot;BBB&quot; = 0.06, &quot;BB&quot; = 0.1, &quot;B&quot; = 0.25, &quot;C&quot; = 0.01, &quot;0&quot; = 0.52) Now let’s look up our probabilities. Exercise 12.3 (Lookup the Probabilities) Look up the probabilities of getting the values in Var1. Then add them to combos as a column named prob1. Then do the same for Var2 (prob2) and Var3 (prob3). Solution. Remember that you use R’s selection notation to look up values in a lookup table. The values that result will be keyed to the index that you use: combos$prob1 &lt;- prob[combos$Var1] combos$prob2 &lt;- prob[combos$Var2] combos$prob3 &lt;- prob[combos$Var3] head(combos, 3) ## Var1 Var2 Var3 prob1 prob2 prob3 ## DD DD DD 0.03 0.03 0.03 ## 7 DD DD 0.03 0.03 0.03 ## BBB DD DD 0.06 0.03 0.03 Now how should we calculate the total probability of each combination? Our three slot symbols are all chosen independently, which means that the same rule that governed our dice probabilities governs our symbol probabilities: \\[ P(A \\&amp; B \\&amp; C \\&amp; ...) = P(A) \\cdot P(B) \\cdot P(C) \\cdot ... \\] Exercise 12.4 (Calculate Probabilities for Each Combination) Calculate the overall probabilities for each combination. Save them as a column named prob in combos, then check your work. You can check that the math worked by summing the probabilities. The probabilities should add up to one, because one of the combinations must appear when you play the slot machine. In other words, a combination will appear, with probability of one. You can calculate the probabilities of every possible combination in one fell swoop with some element-wise execution: combos$prob &lt;- combos$prob1 * combos$prob2 * combos$prob3 head(combos, 3) ## Var1 Var2 Var3 prob1 prob2 prob3 prob ## DD DD DD 0.03 0.03 0.03 0.000027 ## 7 DD DD 0.03 0.03 0.03 0.000027 ## BBB DD DD 0.06 0.03 0.03 0.000054 The sum of the probabilities is one, which suggests that our math is correct: sum(combos$prob) ## 1 You only need to do one more thing before you can calculate the expected value: you must determine the prize for each combination in combos. You can calculate the prize with score. For example, we can calculate the prize for the first row of combos like this: symbols &lt;- c(combos[1, 1], combos[1, 2], combos[1, 3]) ## &quot;DD&quot; &quot;DD&quot; &quot;DD&quot; score(symbols) ## 800 However there are 343 rows, which makes for tedious work if you plan to calculate the scores manually. It will be quicker to automate this task and have R do it for you, which you can do with a for loop. 12.3 for Loops A for loop repeats a chunk of code many times, once for each element in a set of input. for loops provide a way to tell R, “Do this for every value of that.” In R syntax, this looks like: for (value in that) { this } The that object should be a set of objects (often a vector of numbers or character strings). The for loop will run the code in that appears between the braces once for each member of that. For example, the for loop below runs print(\"one run\") once for each element in a vector of character strings: for (value in c(&quot;My&quot;, &quot;first&quot;, &quot;for&quot;, &quot;loop&quot;)) { print(&quot;one run&quot;) } ## &quot;one run&quot; ## &quot;one run&quot; ## &quot;one run&quot; ## &quot;one run&quot; The value symbol in a for loop acts like an argument in a function. The for loop will create an object named value and assign it a new value on each run of the loop. The code in your loop can access this value by calling the value object. What values will the for loop assign to value? It will use the elements in the set that you run the loop on. for starts with the first element and then assigns a different element to value on each run of the for loop, until all of the elements have been assigned to value. For example, the for loop below will run print(value) four times and will print out one element of c(\"My\", \"second\", \"for\", \"loop\") each time: for (value in c(&quot;My&quot;, &quot;second&quot;, &quot;for&quot;, &quot;loop&quot;)) { print(value) } ## &quot;My&quot; ## &quot;second&quot; ## &quot;for&quot; ## &quot;loop&quot; On the first run, the for loop substituted \"My\" for value in print(value). On the second run it substituted \"second\", and so on until for had run print(value) once with every element in the set: If you look at value after the loop runs, you will see that it still contains the value of the last element in the set: value ## &quot;loop&quot; I’ve been using the symbol value in my for loops, but there is nothing special about it. You can use any symbol you like in your loop to do the same thing as long as the symbol appears before in in the parentheses that follow for. For example, you could rewrite the previous loop with any of the following: for (word in c(&quot;My&quot;, &quot;second&quot;, &quot;for&quot;, &quot;loop&quot;)) { print(word) } for (string in c(&quot;My&quot;, &quot;second&quot;, &quot;for&quot;, &quot;loop&quot;)) { print(string) } for (i in c(&quot;My&quot;, &quot;second&quot;, &quot;for&quot;, &quot;loop&quot;)) { print(i) } Choose your symbols carefully R will run your loop in whichever environment you call it from. This is bad news if your loop uses object names that already exist in the environment. Your loop will overwrite the existing objects with the objects that it creates. This applies to the value symbol as well. For loops run on sets In many programming languages, for loops are designed to work with integers, not sets. You give the loop a starting value and an ending value, as well as an increment to advance the value by between loops. The for loop then runs until the loop value exceeds the ending value. You can recreate this effect in R by having a for loop execute on a set of integers, but don’t lose track of the fact that R’s for loops execute on members of a set, not sequences of integers. for loops are very useful in programming because they help you connect a piece of code with each element in a set. For example, we could use a for loop to run score once for each row in combos. However, R’s for loops have a shortcoming that you’ll want to know about before you start using them: for loops do not return output. for loops are like Las Vegas: what happens in a for loop stays in a for loop. If you want to use the products of a for loop, you must write the for loop so that it saves its own output as it goes. Our previous examples appeared to return output, but this was misleading. The examples worked because we called print, which always prints its arguments in the console (even if it is called from a function, a for loop, or anything else). Our for loops won’t return anything if you remove the print call: for (value in c(&quot;My&quot;, &quot;third&quot;, &quot;for&quot;, &quot;loop&quot;)) { value } ## To save output from a for loop, you must write the loop so that it saves its own output as it runs. You can do this by creating an empty vector or list before you run the for loop. Then use the for loop to fill up the vector or list. When the for loop is finished, you’ll be able to access the vector or list, which will now have all of your results. Let’s see this in action. The following code creates an empty vector of length 4: chars &lt;- vector(length = 4) The next loop will fill it with strings: words &lt;- c(&quot;My&quot;, &quot;fourth&quot;, &quot;for&quot;, &quot;loop&quot;) for (i in 1:4) { chars[i] &lt;- words[i] } chars ## &quot;My&quot; &quot;fourth&quot; &quot;for&quot; &quot;loop&quot; This approach will usually require you to change the sets that you execute your for loop on. Instead of executing on a set of objects, execute on a set of integers that you can use to index both your object and your storage vector. This approach is very common in R. You’ll find in practice that you use for loops not so much to run code, but to fill up vectors and lists with the results of code. Let’s use a for loop to calculate the prize for each row in combos. To begin, create a new column in combos to store the results of the for loop: combos$prize &lt;- NA head(combos, 3) ## Var1 Var2 Var3 prob1 prob2 prob3 prob prize ## DD DD DD 0.03 0.03 0.03 0.000027 NA ## 7 DD DD 0.03 0.03 0.03 0.000027 NA ## BBB DD DD 0.06 0.03 0.03 0.000054 NA The code creates a new column named prize and fills it with NAs. R uses its recycling rules to populate every value of the column with NA. Exercise 12.5 (Build a Loop) Construct a for loop that will run score on all 343 rows of combos. The loop should run score on the first three entries of the _i_th row of combos and should store the results in the _i_th entry of combos$prize. Solution. You can score the rows in combos with: for (i in 1:nrow(combos)) { symbols &lt;- c(combos[i, 1], combos[i, 2], combos[i, 3]) combos$prize[i] &lt;- score(symbols) } After you run the for loop, combos$prize will contain the correct prize for each row. This exercise also tests the score function; score appears to work correctly for every possible slot combination: head(combos, 3) ## Var1 Var2 Var3 prob1 prob2 prob3 prob prize ## DD DD DD 0.03 0.03 0.03 0.000027 800 ## 7 DD DD 0.03 0.03 0.03 0.000027 0 ## BBB DD DD 0.06 0.03 0.03 0.000054 0 We’re now ready to calculate the expected value of the prize. The expected value is the sum of combos$prize weighted by combos$prob. This is also the payout rate of the slot machine: sum(combos$prize * combos$prob) ## 0.538014 Uh oh. The expected prize is about 0.54, which means our slot machine only pays 54 cents on the dollar over the long run. Does this mean that the manufacturer of the Manitoba slot machines was lying? No, because we ignored an important feature of the slot machine when we wrote score: a diamond is wild. You can treat a DD as any other symbol if it increases your prize, with one exception. You cannot make a DD a C unless you already have another C in your symbols (it’d be too easy if every DD automatically earned you $2). The best thing about DDs is that their effects are cumulative. For example, consider the combination B, DD, B. Not only does the DD count as a B, which would earn a prize of $10; the DD also doubles the prize to $20. Adding this behavior to our code is a little tougher than what we have done so far, but it involves all of the same principles. You can decide that your slot machine doesn’t use wilds and keep the code that we have. In that case, your slot machine will have a payout rate of about 54 percent. Or, you could rewrite your code to use wilds. If you do, you will find that your slot machine has a payout rate of 93 percent, one percent higher than the manufacturer’s claim. You can calculate this rate with the same method that we used in this section. Exercise 12.6 (Challenge) There are many ways to modify score that would count DDs as wild. If you would like to test your skill as an R programmer, try to write your own version of score that correctly handles diamonds. If you would like a more modest challenge, study the following score code. It accounts for wild diamonds in a way that I find elegant and succinct. See if you can understand each step in the code and how it achieves its result. Solution. Here is a version of score that handles wild diamonds: score &lt;- function(symbols) { diamonds &lt;- sum(symbols == &quot;DD&quot;) cherries &lt;- sum(symbols == &quot;C&quot;) # identify case # since diamonds are wild, only nondiamonds # matter for three of a kind and all bars slots &lt;- symbols[symbols != &quot;DD&quot;] same &lt;- length(unique(slots)) == 1 bars &lt;- slots %in% c(&quot;B&quot;, &quot;BB&quot;, &quot;BBB&quot;) # assign prize if (diamonds == 3) { prize &lt;- 100 } else if (same) { payouts &lt;- c(&quot;7&quot; = 80, &quot;BBB&quot; = 40, &quot;BB&quot; = 25, &quot;B&quot; = 10, &quot;C&quot; = 10, &quot;0&quot; = 0) prize &lt;- unname(payouts[slots[1]]) } else if (all(bars)) { prize &lt;- 5 } else if (cherries &gt; 0) { # diamonds count as cherries # so long as there is one real cherry prize &lt;- c(0, 2, 5)[cherries + diamonds + 1] } else { prize &lt;- 0 } # double for each diamond prize * 2^diamonds } Exercise 12.7 (Calculate the Expected Value) Calculate the expected value of the slot machine when it uses the new score function. You can use the existing combos data frame, but you will need to build a for loop to recalculate combos$prize. To update the expected value, just update combos$prize: for (i in 1:nrow(combos)) { symbols &lt;- c(combos[i, 1], combos[i, 2], combos[i, 3]) combos$prize[i] &lt;- score(symbols) } Then recompute the expected value: sum(combos$prize * combos$prob) ## 0.934356 This result vindicates the manufacturer’s claim. If anything, the slot machines seem more generous than the manufacturer stated. 12.4 while Loops R has two companions to the for loop: the while loop and the repeat loop. A while loop reruns a chunk while a certain condition remains TRUE. To create a while loop, follow while by a condition and a chunk of code, like this: while (condition) { code } while will rerun condition, which should be a logical test, at the start of each loop. If condition evaluates to TRUE, while will run the code between its braces. If condition evaluates to FALSE, while will finish the loop. Why might condition change from TRUE to FALSE? Presumably because the code inside your loop has changed whether the condition is still TRUE. If the code has no relationship to the condition, a while loop will run until you stop it. So be careful. You can stop a while loop by hitting Escape or by clicking on the stop-sign icon at the top of the RStudio console pane. The icon will appear once the loop begins to run. Like for loops, while loops do not return a result, so you must think about what you want the loop to return and save it to an object during the loop. You can use while loops to do things that take a varying number of iterations, like calculating how long it takes to go broke playing slots (as follows). However, in practice, while loops are much less common than for loops in R: plays_till_broke &lt;- function(start_with) { cash &lt;- start_with n &lt;- 0 while (cash &gt; 0) { cash &lt;- cash - 1 + play() n &lt;- n + 1 } n } plays_till_broke(100) ## 260 12.5 repeat Loops repeat loops are even more basic than while loops. They will repeat a chunk of code until you tell them to stop (by hitting Escape) or until they encounter the command break, which will stop the loop. You can use a repeat loop to recreate plays_till_broke, my function that simulates how long it takes to lose money while playing slots: plays_till_broke &lt;- function(start_with) { cash &lt;- start_with n &lt;- 0 repeat { cash &lt;- cash - 1 + play() n &lt;- n + 1 if (cash &lt;= 0) { break } } n } plays_till_broke(100) ## 237 12.6 Summary You can repeat tasks in R with for, while, and repeat loops. To use for, give it a chunk of code to run and a set of objects to loop through. for will run the code chunk once for each object. If you wish to save the output of your loop, you can assign it to an object that exists outside of the loop. Repetition plays an important role in data science. It is the basis for simulation, as well as for estimates of variance and probability. Loops are not the only way to create repetition in R (consider replicate for example), but they are one of the most popular ways. Unfortunately, loops in R can sometimes be slower than loops in other languages. As a result, R’s loops get a bad rap. This reputation is not entirely deserved, but it does highlight an important issue. Speed is essential to data analysis. When your code runs fast, you can work with bigger data and do more to it before you run out of time or computational power. Speed will teach you how to write fast for loops and fast code in general with R. There, you will learn to write vectorized code, a style of lightning-fast code that takes advantage of all of R’s strengths. "],["speed.html", "13 Speed 13.1 Vectorized Code 13.2 How to Write Vectorized Code 13.3 How to Write Fast for Loops in R 13.4 Vectorized Code in Practice 13.5 Summary 13.6 Project 3 Wrap-up", " 13 Speed As a data scientist, you need speed. You can work with bigger data and do more ambitious tasks when your code runs fast. This chapter will show you a specific way to write fast code in R. You will then use the method to simulate 10 million plays of your slot machine. 13.1 Vectorized Code You can write a piece of code in many different ways, but the fastest R code will usually take advantage of three things: logical tests, subsetting, and element-wise execution. These are the things that R does best. Code that uses these things usually has a certain quality: it is vectorized; the code can take a vector of values as input and manipulate each value in the vector at the same time. To see what vectorized code looks like, compare these two examples of an absolute value function. Each takes a vector of numbers and transforms it into a vector of absolute values (e.g., positive numbers). The first example is not vectorized; abs_loop uses a for loop to manipulate each element of the vector one at a time: abs_loop &lt;- function(vec){ for (i in 1:length(vec)) { if (vec[i] &lt; 0) { vec[i] &lt;- -vec[i] } } vec } The second example, abs_set, is a vectorized version of abs_loop. It uses logical subsetting to manipulate every negative number in the vector at the same time: abs_sets &lt;- function(vec){ negs &lt;- vec &lt; 0 vec[negs] &lt;- vec[negs] * -1 vec } abs_set is much faster than abs_loop because it relies on operations that R does quickly: logical tests, subsetting, and element-wise execution. You can use the system.time function to see just how fast abs_set is. system.time takes an R expression, runs it, and then displays how much time elapsed while the expression ran. To compare abs_loop and abs_set, first make a long vector of positive and negative numbers. long will contain 10 million values: long &lt;- rep(c(-1, 1), 5000000) rep repeats a value, or vector of values, many times. To use rep, give it a vector of values and then the number of times to repeat the vector. R will return the results as a new, longer vector. You can then use system.time to measure how much time it takes each function to evaluate long: system.time(abs_loop(long)) ## user system elapsed ## 15.982 0.032 16.018 system.time(abs_sets(long)) ## user system elapsed ## 0.529 0.063 0.592 Don’t confuse system.time with Sys.time, which returns the current time. The first two columns of the output of system.time report how many seconds your computer spent executing the call on the user side and system sides of your process, a dichotomy that will vary from OS to OS. The last column displays how many seconds elapsed while R ran the expression. The results show that abs_set calculated the absolute value 30 times faster than abs_loop when applied to a vector of 10 million numbers. You can expect similar speed-ups whenever you write vectorized code. Exercise 13.1 (How fast is abs?) Many preexisting R functions are already vectorized and have been optimized to perform quickly. You can make your code faster by relying on these functions whenever possible. For example, R comes with a built-in absolute value function, abs. Check to see how much faster abs computes the absolute value of long than abs_loop and abs_set do. Solution. You can measure the speed of abs with system.time. It takes abs a lightning-fast 0.05 seconds to calculate the absolute value of 10 million numbers. This is 0.592 / 0.054 = 10.96 times faster than abs_set and nearly 300 times faster than abs_loop: system.time(abs(long)) ## user system elapsed ## 0.037 0.018 0.054 13.2 How to Write Vectorized Code Vectorized code is easy to write in R because most R functions are already vectorized. Code based on these functions can easily be made vectorized and therefore fast. To create vectorized code: Use vectorized functions to complete the sequential steps in your program. Use logical subsetting to handle parallel cases. Try to manipulate every element in a case at once. abs_loop and abs_set illustrate these rules. The functions both handle two cases and perform one sequential step, Figure 13.1. If a number is positive, the functions leave it alone. If a number is negative, the functions multiply it by negative one. Figure 13.1: abs_loop uses a for loop to sift data into one of two cases: negative numbers and nonnegative numbers. You can identify all of the elements of a vector that fall into a case with a logical test. R will execute the test in element-wise fashion and return a TRUE for every element that belongs in the case. For example, vec &lt; 0 identifies every value of vec that belongs to the negative case. You can use the same logical test to extract the set of negative values with logical subsetting: vec &lt;- c(1, -2, 3, -4, 5, -6, 7, -8, 9, -10) vec &lt; 0 ## FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE vec[vec &lt; 0] ## -2 -4 -6 -8 -10 The plan in Figure 13.1 now requires a sequential step: you must multiply each of the negative values by negative one. All of R’s arithmetic operators are vectorized, so you can use * to complete this step in vectorized fashion. * will multiply each number in vec[vec &lt; 0] by negative one at the same time: vec[vec &lt; 0] * -1 ## 2 4 6 8 10 Finally, you can use R’s assignment operator, which is also vectorized, to save the new set over the old set in the original vec object. Since &lt;- is vectorized, the elements of the new set will be paired up to the elements of the old set, in order, and then element-wise assignment will occur. As a result, each negative value will be replaced by its positive partner, as in Figure 13.2. Figure 13.2: Use logical subsetting to modify groups of values in place. R’s arithmetic and assignment operators are vectorized, which lets you manipulate and update multiple values at once. Exercise 13.2 (Vectorize a Function) The following function converts a vector of slot symbols to a vector of new slot symbols. Can you vectorize it? How much faster does the vectorized version work? change_symbols &lt;- function(vec){ for (i in 1:length(vec)){ if (vec[i] == &quot;DD&quot;) { vec[i] &lt;- &quot;joker&quot; } else if (vec[i] == &quot;C&quot;) { vec[i] &lt;- &quot;ace&quot; } else if (vec[i] == &quot;7&quot;) { vec[i] &lt;- &quot;king&quot; }else if (vec[i] == &quot;B&quot;) { vec[i] &lt;- &quot;queen&quot; } else if (vec[i] == &quot;BB&quot;) { vec[i] &lt;- &quot;jack&quot; } else if (vec[i] == &quot;BBB&quot;) { vec[i] &lt;- &quot;ten&quot; } else { vec[i] &lt;- &quot;nine&quot; } } vec } vec &lt;- c(&quot;DD&quot;, &quot;C&quot;, &quot;7&quot;, &quot;B&quot;, &quot;BB&quot;, &quot;BBB&quot;, &quot;0&quot;) change_symbols(vec) ## &quot;joker&quot; &quot;ace&quot; &quot;king&quot; &quot;queen&quot; &quot;jack&quot; &quot;ten&quot; &quot;nine&quot; many &lt;- rep(vec, 1000000) system.time(change_symbols(many)) ## user system elapsed ## 30.057 0.031 30.079 Solution. change_symbols uses a for loop to sort values into seven different cases, as demonstrated in Figure 13.3. To vectorize change_symbols, create a logical test that can identify each case: vec[vec == &quot;DD&quot;] ## &quot;DD&quot; vec[vec == &quot;C&quot;] ## &quot;C&quot; vec[vec == &quot;7&quot;] ## &quot;7&quot; vec[vec == &quot;B&quot;] ## &quot;B&quot; vec[vec == &quot;BB&quot;] ## &quot;BB&quot; vec[vec == &quot;BBB&quot;] ## &quot;BBB&quot; vec[vec == &quot;0&quot;] ## &quot;0&quot; Figure 13.3: change_many does something different for each of seven cases. Then write code that can change the symbols for each case: vec[vec == &quot;DD&quot;] &lt;- &quot;joker&quot; vec[vec == &quot;C&quot;] &lt;- &quot;ace&quot; vec[vec == &quot;7&quot;] &lt;- &quot;king&quot; vec[vec == &quot;B&quot;] &lt;- &quot;queen&quot; vec[vec == &quot;BB&quot;] &lt;- &quot;jack&quot; vec[vec == &quot;BBB&quot;] &lt;- &quot;ten&quot; vec[vec == &quot;0&quot;] &lt;- &quot;nine&quot; When you combine this into a function, you have a vectorized version of change_symbols that runs about 14 times faster: change_vec &lt;- function (vec) { vec[vec == &quot;DD&quot;] &lt;- &quot;joker&quot; vec[vec == &quot;C&quot;] &lt;- &quot;ace&quot; vec[vec == &quot;7&quot;] &lt;- &quot;king&quot; vec[vec == &quot;B&quot;] &lt;- &quot;queen&quot; vec[vec == &quot;BB&quot;] &lt;- &quot;jack&quot; vec[vec == &quot;BBB&quot;] &lt;- &quot;ten&quot; vec[vec == &quot;0&quot;] &lt;- &quot;nine&quot; vec } system.time(change_vec(many)) ## user system elapsed ## 1.994 0.059 2.051 Or, even better, use a lookup table. Lookup tables are a vectorized method because they rely on R’s vectorized selection operations: change_vec2 &lt;- function(vec){ tb &lt;- c(&quot;DD&quot; = &quot;joker&quot;, &quot;C&quot; = &quot;ace&quot;, &quot;7&quot; = &quot;king&quot;, &quot;B&quot; = &quot;queen&quot;, &quot;BB&quot; = &quot;jack&quot;, &quot;BBB&quot; = &quot;ten&quot;, &quot;0&quot; = &quot;nine&quot;) unname(tb[vec]) } system.time(change_vec(many)) ## user system elapsed ## 0.687 0.059 0.746 Here, a lookup table is 40 times faster than the original function. abs_loop and change_many illustrate a characteristic of vectorized code: programmers often write slower, nonvectorized code by relying on unnecessary for loops, like the one in change_many. I think this is the result of a general misunderstanding about R. for loops do not behave the same way in R as they do in other languages, which means you should write code differently in R than you would in other languages. When you write in languages like C and Fortran, you must compile your code before your computer can run it. This compilation step optimizes how the for loops in the code use your computer’s memory, which makes the for loops very fast. As a result, many programmers use for loops frequently when they write in C and Fortran. When you write in R, however, you do not compile your code. You skip this step, which makes programming in R a more user-friendly experience. Unfortunately, this also means you do not give your loops the speed boost they would receive in C or Fortran. As a result, your loops will run slower than the other operations we have studied: logical tests, subsetting, and element-wise execution. If you can write your code with the faster operations instead of a for loop, you should do so. No matter which language you write in, you should try to use the features of the language that run the fastest. if and for A good way to spot for loops that could be vectorized is to look for combinations of if and for. if can only be applied to one value at a time, which means it is often used in conjunction with a for loop. The for loop helps apply if to an entire vector of values. This combination can usually be replaced with logical subsetting, which will do the same thing but run much faster. This doesn’t mean that you should never use for loops in R. There are still many places in R where for loops make sense. for loops perform a basic task that you cannot always recreate with vectorized code. for loops are also easy to understand and run reasonably fast in R, so long as you take a few precautions. 13.3 How to Write Fast for Loops in R You can dramatically increase the speed of your for loops by doing two things to optimize each loop. First, do as much as you can outside of the for loop. Every line of code that you place inside of the for loop will be run many, many times. If a line of code only needs to be run once, place it outside of the loop to avoid repetition. Second, make sure that any storage objects that you use with the loop are large enough to contain all of the results of the loop. For example, both loops below will need to store one million values. The first loop stores its values in an object named output that begins with a length of one million: system.time({ output &lt;- rep(NA, 1000000) for (i in 1:1000000) { output[i] &lt;- i + 1 } }) ## user system elapsed ## 1.709 0.015 1.724 The second loop stores its values in an object named output that begins with a length of one. R will expand the object to a length of one million as it runs the loop. The code in this loop is very similar to the code in the first loop, but the loop takes 37 minutes longer to run than the first loop: system.time({ output &lt;- NA for (i in 1:1000000) { output[i] &lt;- i + 1 } }) ## user system elapsed ## 1689.537 560.951 2249.927 The two loops do the same thing, so what accounts for the difference? In the second loop, R has to increase the length of output by one for each run of the loop. To do this, R needs to find a new place in your computer’s memory that can contain the larger object. R must then copy the output vector over and erase the old version of output before moving on to the next run of the loop. By the end of the loop, R has rewritten output in your computer’s memory one million times. In the first case, the size of output never changes; R can define one output object in memory and use it for each run of the for loop. The authors of R use low-level languages like C and Fortran to write basic R functions, many of which use for loops. These functions are compiled and optimized before they become a part of R, which makes them quite fast. Whenever you see .Primitive, .Internal, or .Call written in a function’s definition, you can be confident the function is calling code from another language. You’ll get all of the speed advantages of that language by using the function. 13.4 Vectorized Code in Practice To see how vectorized code can help you as a data scientist, consider our slot machine project. In Loops, you calculated the exact payout rate for your slot machine, but you could have estimated this payout rate with a simulation. If you played the slot machine many, many times, the average prize over all of the plays would be a good estimate of the true payout rate. This method of estimation is based on the law of large numbers and is similar to many statistical simulations. To run this simulation, you could use a for loop: winnings &lt;- vector(length = 1000000) for (i in 1:1000000) { winnings[i] &lt;- play() } mean(winnings) ## 0.9366984 The estimated payout rate after 10 million runs is 0.937, which is very close to the true payout rate of 0.934. Note that I’m using the modified score function that treats diamonds as wilds. If you run this simulation, you will notice that it takes a while to run. In fact, the simulation takes 342,308 seconds to run, which is about 5.7 minutes. This is not particularly impressive, and you can do better by using vectorized code: system.time(for (i in 1:1000000) { winnings[i] &lt;- play() }) ## user system elapsed ## 342.041 0.355 342.308 The current score function is not vectorized. It takes a single slot combination and uses an if tree to assign a prize to it. This combination of an if tree with a for loop suggests that you could write a piece of vectorized code that takes many slot combinations and then uses logical subsetting to operate on them all at once. For example, you could rewrite get_symbols to generate n slot combinations and return them as an n x 3 matrix, like the one that follows. Each row of the matrix will contain one slot combination to be scored: get_many_symbols &lt;- function(n) { wheel &lt;- c(&quot;DD&quot;, &quot;7&quot;, &quot;BBB&quot;, &quot;BB&quot;, &quot;B&quot;, &quot;C&quot;, &quot;0&quot;) vec &lt;- sample(wheel, size = 3 * n, replace = TRUE, prob = c(0.03, 0.03, 0.06, 0.1, 0.25, 0.01, 0.52)) matrix(vec, ncol = 3) } get_many_symbols(5) ## [,1] [,2] [,3] ## [1,] &quot;B&quot; &quot;0&quot; &quot;B&quot; ## [2,] &quot;0&quot; &quot;BB&quot; &quot;7&quot; ## [3,] &quot;0&quot; &quot;0&quot; &quot;BBB&quot; ## [4,] &quot;0&quot; &quot;0&quot; &quot;B&quot; ## [5,] &quot;BBB&quot; &quot;0&quot; &quot;0&quot; You could also rewrite play to take a parameter, n, and return n prizes, in a data frame: play_many &lt;- function(n) { symb_mat &lt;- get_many_symbols(n = n) data.frame(w1 = symb_mat[,1], w2 = symb_mat[,2], w3 = symb_mat[,3], prize = score_many(symb_mat)) } This new function would make it easy to simulate a million, or even 10 million plays of the slot machine, which will be our goal. When we’re finished, you will be able to estimate the payout rate with: # plays &lt;- play_many(10000000)) # mean(plays$prize) Now you just need to write score_many, a vectorized (matix-ized?) version of score that takes an n x 3 matrix and returns n prizes. It will be difficult to write this function because score is already quite complicated. I would not expect you to feel confident doing this on your own until you have more practice and experience than we’ve been able to develop here. Should you like to test your skills and write a version of score_many, I recommend that you use the function rowSums within your code. It calculates the sum of each row of numbers (or logicals) in a matrix. If you would like to test yourself in a more modest way, I recommend that you study the following model score_many function until you understand how each part works and how the parts work together to create a vectorized function. To do this, it will be helpful to create a concrete example, like this: symbols &lt;- matrix( c(&quot;DD&quot;, &quot;DD&quot;, &quot;DD&quot;, &quot;C&quot;, &quot;DD&quot;, &quot;0&quot;, &quot;B&quot;, &quot;B&quot;, &quot;B&quot;, &quot;B&quot;, &quot;BB&quot;, &quot;BBB&quot;, &quot;C&quot;, &quot;C&quot;, &quot;0&quot;, &quot;7&quot;, &quot;DD&quot;, &quot;DD&quot;), nrow = 6, byrow = TRUE) symbols ## [,1] [,2] [,3] ## [1,] &quot;DD&quot; &quot;DD&quot; &quot;DD&quot; ## [2,] &quot;C&quot; &quot;DD&quot; &quot;0&quot; ## [3,] &quot;B&quot; &quot;B&quot; &quot;B&quot; ## [4,] &quot;B&quot; &quot;BB&quot; &quot;BBB&quot; ## [5,] &quot;C&quot; &quot;C&quot; &quot;0&quot; ## [6,] &quot;7&quot; &quot;DD&quot; &quot;DD&quot; Then you can run each line of score_many against the example and examine the results as you go. Exercise 13.3 (Test Your Understanding) Study the model score_many function until you are satisfied that you understand how it works and could write a similar function yourself. Exercise 13.4 (Advanced Challenge) Instead of examining the model answer, write your own vectorized version of score. Assume that the data is stored in an n × 3 matrix where each row of the matrix contains one combination of slots to be scored. You can use the version of score that treats diamonds as wild or the version of score that doesn’t. However, the model answer will use the version treating diamonds as wild. Solution. score_many is a vectorized version of score. You can use it to run the simulation at the start of this section in a little over 20 seconds. This is 17 times faster than using a for loop: # symbols should be a matrix with a column for each slot machine window score_many &lt;- function(symbols) { # Step 1: Assign base prize based on cherries and diamonds --------- ## Count the number of cherries and diamonds in each combination cherries &lt;- rowSums(symbols == &quot;C&quot;) diamonds &lt;- rowSums(symbols == &quot;DD&quot;) ## Wild diamonds count as cherries prize &lt;- c(0, 2, 5)[cherries + diamonds + 1] ## ...but not if there are zero real cherries ### (cherries is coerced to FALSE where cherries == 0) prize[!cherries] &lt;- 0 # Step 2: Change prize for combinations that contain three of a kind same &lt;- symbols[, 1] == symbols[, 2] &amp; symbols[, 2] == symbols[, 3] payoffs &lt;- c(&quot;DD&quot; = 100, &quot;7&quot; = 80, &quot;BBB&quot; = 40, &quot;BB&quot; = 25, &quot;B&quot; = 10, &quot;C&quot; = 10, &quot;0&quot; = 0) prize[same] &lt;- payoffs[symbols[same, 1]] # Step 3: Change prize for combinations that contain all bars ------ bars &lt;- symbols == &quot;B&quot; | symbols == &quot;BB&quot; | symbols == &quot;BBB&quot; all_bars &lt;- bars[, 1] &amp; bars[, 2] &amp; bars[, 3] &amp; !same prize[all_bars] &lt;- 5 # Step 4: Handle wilds --------------------------------------------- ## combos with two diamonds two_wilds &lt;- diamonds == 2 ### Identify the nonwild symbol one &lt;- two_wilds &amp; symbols[, 1] != symbols[, 2] &amp; symbols[, 2] == symbols[, 3] two &lt;- two_wilds &amp; symbols[, 1] != symbols[, 2] &amp; symbols[, 1] == symbols[, 3] three &lt;- two_wilds &amp; symbols[, 1] == symbols[, 2] &amp; symbols[, 2] != symbols[, 3] ### Treat as three of a kind prize[one] &lt;- payoffs[symbols[one, 1]] prize[two] &lt;- payoffs[symbols[two, 2]] prize[three] &lt;- payoffs[symbols[three, 3]] ## combos with one wild one_wild &lt;- diamonds == 1 ### Treat as all bars (if appropriate) wild_bars &lt;- one_wild &amp; (rowSums(bars) == 2) prize[wild_bars] &lt;- 5 ### Treat as three of a kind (if appropriate) one &lt;- one_wild &amp; symbols[, 1] == symbols[, 2] two &lt;- one_wild &amp; symbols[, 2] == symbols[, 3] three &lt;- one_wild &amp; symbols[, 3] == symbols[, 1] prize[one] &lt;- payoffs[symbols[one, 1]] prize[two] &lt;- payoffs[symbols[two, 2]] prize[three] &lt;- payoffs[symbols[three, 3]] # Step 5: Double prize for every diamond in combo ------------------ unname(prize * 2^diamonds) } system.time(play_many(10000000)) ## user system elapsed ## 20.942 1.433 22.367 13.4.1 Loops Versus Vectorized Code In many languages, for loops run very fast. As a result, programmers learn to use for loops whenever possible when they code. Often these programmers continue to rely on for loops when they begin to program in R, usually without taking the simple steps needed to optimize R’s for loops. These programmers may become disillusioned with R when their code does not work as fast as they would like. If you think that this may be happening to you, examine how often you are using for loops and what you are using them to do. If you find yourself using for loops for every task, there is a good chance that you are “speaking R with a C accent.” The cure is to learn to write and use vectorized code. This doesn’t mean that for loops have no place in R. for loops are a very useful feature; they can do many things that vectorized code cannot do. You also should not become a slave to vectorized code. Sometimes it would take more time to rewrite code in vectorized format than to let a for loop run. For example, would it be faster to let the slot simulation run for 5.7 minutes or to rewrite score? 13.5 Summary Fast code is an important component of data science because you can do more with fast code than you can do with slow code. You can work with larger data sets before computational constraints intervene, and you can do more computation before time constraints intervene. The fastest code in R will rely on the things that R does best: logical tests, subsetting, and element-wise execution. I’ve called this type of code vectorized code because code written with these operations will take a vector of values as input and operate on each element of the vector at the same time. The majority of the code written in R is already vectorized. If you use these operations, but your code does not appear vectorized, analyze the sequential steps and parallel cases in your program. Ensure that you’ve used vectorized functions to handle the steps and logical subsetting to handle the cases. Be aware, however, that some tasks cannot be vectorized. 13.6 Project 3 Wrap-up You have now written your first program in R, and it is a program that you should be proud of. play is not a simple hello world exercise, but a real program that does a real task in a complicated way. Writing new programs in R will always be challenging because programming depends so much on your own creativity, problem-solving ability, and experience writing similar types of programs. However, you can use the suggestions in this chapter to make even the most complicated program manageable: divide tasks into simple steps and cases, work with concrete examples, and describe possible solutions in English. This project completes the education you began in [The Very Basics]. You can now use R to handle data, which has augmented your ability to analyze data. You can: Load and store data in your computer—not on paper or in your mind Accurately recall and change individual values without relying on your memory Instruct your computer to do tedious, or complex, tasks on your behalf These skills solve an important logistical problem faced by every data scientist: how can you store and manipulate data without making errors? However, this is not the only problem that you will face as a data scientist. The next problem will appear when you try to understand the information contained in your data. It is nearly impossible to spot insights or to discover patterns in raw data. A third problem will appear when you try to use your data set to reason about reality, which includes things not contained in your data set. What exactly does your data imply about things outside of the data set? How certain can you be? I refer to these problems as the logistical, tactical, and strategic problems of data science, as shown in Figure 13.4. You’ll face them whenever you try to learn from data: A logistical problem: - How can you store and manipulate data without making errors? A tactical problem - How can you discover the information contained in your data? A strategic problem - How can you use the data to draw conclusions about the world at large? Figure 13.4: The three core skill sets of data science: computer programming, data comprehension, and scientific reasoning. A well-rounded data scientist will need to be able to solve each of these problems in many different situations. By learning to program in R, you have mastered the logistical problem, which is a prerequisite for solving the tactical and strategic problems. If you would like to learn how to reason with data, or how to transform, visualize, and explore your data sets with R tools, I recommend the book R for Data Science, the companion volume to this book. R for Data Science teaches a simple workflow for transforming, visualizing, and modeling data in R, as well as how to report results with the R Markdown package. "],["starting.html", "A Instalación de R y RStudio A.1 Cómo descargar e instalar R A.2 Usando R A.3 RStudio A.4 Abriendo R", " A Instalación de R y RStudio Para comenzar con R, debe adquirir su propia copia. Este apéndice le mostrará cómo descargar R así como RStudio, una aplicación de software que facilita el uso de R. Pasará de descargar R a abrir su primera sesión de R. Tanto R como RStudio son gratuitos y fáciles de descargar. A.1 Cómo descargar e instalar R R es mantenido por un equipo internacional de desarrolladores que hacen que el lenguaje esté disponible a través de la página web de The Comprehensive R Archive Network. La parte superior de la página web proporciona tres enlaces para descargar R. Siga el enlace que describe su sistema operativo: Windows, Mac o Linux. A.1.1 Windows Para instalar R en Windows, haga clic en el enlace “Download R for Windows”. Luego haga clic en el enlace “base”. A continuación, haga clic en el primer enlace en la parte superior de la nueva página. Este enlace debería decir algo como “Descargar R 3.0.3 para Windows”, excepto que la 3.0.3 será reemplazada por la versión más reciente de R. El enlace descarga un programa de instalación, que instala la versión más actualizada de R para Windows. Ejecute este programa y siga los pasos del asistente de instalación que aparece. El asistente instalará R en sus carpetas de archivos de programa y colocará un acceso directo en su menú Inicio. Tenga en cuenta que deberá tener todos los privilegios de administración apropiados para instalar software nuevo en su máquina. A.1.2 Mac Para instalar R en una Mac, haga clic en el enlace “Download R for Mac”. A continuación, haga clic en el enlace del paquete R-3.0.3 (o en el enlace del paquete para la versión más reciente de R). Se descargará un instalador para guiarlo a través del proceso de instalación, que es muy fácil. El instalador le permite personalizar su instalación, pero los valores predeterminados serán adecuados para la mayoría de los usuarios. Nunca he encontrado una razón para cambiarlos. Si su computadora requiere una contraseña antes de instalar nuevos programas, la necesitará aquí. Binarios versus Fuente R se puede instalar a partir de archivos binarios precompilados o compilarse desde el origen en cualquier sistema operativo. Para máquinas Windows y Mac, instalar R desde binarios es extremadamente fácil. El binario viene precargado en su propio instalador. Aunque puede compilar R desde el origen en estas plataformas, el proceso es mucho más complicado y no brindará muchos beneficios a la mayoría de los usuarios. Para los sistemas Linux, ocurre lo contrario. Se pueden encontrar binarios precompilados para algunos sistemas, pero es mucho más común compilar R a partir de archivos fuente cuando se instala en Linux. Las páginas de descarga en el sitio web de CRAN brindan información sobre la creación de R desde el origen para las plataformas Windows, Mac y Linux. A.1.3 Linux R viene preinstalado en muchos sistemas Linux, pero querrá la versión más reciente de R si la suya no está actualizada. El sitio web de CRAN proporciona archivos para compilar R desde la fuente en los sistemas Debian, Redhat, SUSE y Ubuntu en el enlace “Descargar R para Linux”. Haga clic en el enlace y luego siga el rastro del directorio hasta la versión de Linux en la que desea instalar. El procedimiento de instalación exacto variará según el sistema Linux que utilice. CRAN guía el proceso agrupando cada conjunto de archivos fuente con documentación o archivos README que explican cómo instalar en su sistema. 32-bit Versus 64-bit R viene en versiones de 32 y 64 bits. ¿Cuál deberías usar? En la mayoría de los casos, no importará. Ambas versiones usan números enteros de 32 bits, lo que significa que calculan números con la misma precisión numérica. La diferencia ocurre en la forma en que cada versión administra la memoria. R de 64 bits usa punteros de memoria de 64 bits y R de 32 bits usa punteros de memoria de 32 bits. Esto significa que R de 64 bits tiene un espacio de memoria más grande para usar (y buscar). Como regla general, las compilaciones de R de 32 bits son más rápidas que las compilaciones de 64 bits, aunque no siempre. Por otro lado, las compilaciones de 64 bits pueden manejar archivos y conjuntos de datos más grandes con menos problemas de administración de memoria. En cualquiera de las versiones, el tamaño de vector máximo permitido alcanza un máximo de alrededor de 2 mil millones de elementos. Si su sistema operativo no es compatible con programas de 64 bits, o su memoria RAM es inferior a 4 GB, la versión R de 32 bits es para usted. Los instaladores de Windows y Mac instalarán automáticamente ambas versiones si su sistema es compatible con R de 64 bits. A.2 Usando R R no es un programa que pueda abrir y comenzar a usar, como Microsoft Word o Internet Explorer. En cambio, R es un lenguaje de programación, como C, C++ o UNIX. Usas R escribiendo comandos en el lenguaje R y pidiéndole a tu computadora que los interprete. En los viejos tiempos, la gente ejecutaba código R en una ventana de terminal UNIX, como si fueran piratas informáticos en una película de los años ochenta. Ahora casi todo el mundo usa R con una aplicación llamada RStudio, y te recomiendo que tú también lo hagas. R y UNIX Todavía puede ejecutar R en una ventana de UNIX o BASH escribiendo el comando: R que abre un intérprete de R. Luego puede hacer su trabajo y cerrar el intérprete ejecutando q() cuando haya terminado. A.3 RStudio RStudio es una applicación como Microsoft Word—excepto que en lugar de ayudarlo a escribir texto convencional, RStudio lo ayuda a escribir en R. Uso RStudio en todo el libro porque hace que usar R sea mucho más fácil. Además, la interfaz de RStudio tiene el mismo aspecto para Windows, Mac OS y Linux. Eso me ayudará a relacionar el libro con su experiencia personal. Puede descargar RStudio de fomra gratuita. Simplemente haga clic en el botón “Download RStudio” y siga las instrucciones. Una vez que haya instalado RStudio, puede abrirlo como cualquier otro programa en su computadora—generalmente haciendo clic en un ícono en su escritorio. Las interfaces gráficas de usuario de R Los usuarios de Windows y Mac generalmente no programan desde una ventana de terminal, por lo que las descargas de Windows y Mac para R vienen con un programa simple que abre una ventana similar a una terminal para que pueda ejecutar el código R. Esto es lo que se abre cuando hace clic en el icono de R en su computadora con Windows o Mac. Estos programas hacen un poco más que la ventana de terminal básica, pero no mucho. Es posible que escuche que las personas se refieren a ellos como las interfarces gráficas de usuarios de R para Windows o Mac. Cuando abre RStudio, aparece una ventana con tres paneles, como en la Figura @ref(fig:layout). El panel más grande es una ventana de consola. Aquí es donde ejecutará su código R y verá los resultados. La ventana de la consola es exactamente lo que vería si ejecutara R desde una consola UNIX o las IGU de Windows o Mac. Todo lo demás que ve es exclusivo de RStudio. Ocultos en los otros paneles hay un editor de texto, una ventana de gráficos, un depurador, un administrador de archivos y mucho más. Aprenderá acerca de estos paneles a medida que se vuelvan útiles a lo largo de este libro. Figure A.1: El Entorno de Desarrollo Integrado de RStudio para R. ¿Todavía necesito descargar R? Incluso si usa RStudio, aún necesitará descargar R a su computadora. RStudio lo ayuda a usar la versión de R que vive en su computadora, pero no viene con una versión de R propia. A.4 Abriendo R Ahora que tiene R y RStudio en su computadora, puede comenzar a usar R abriendo el programa RStudio. Abra RStudio como lo haría con cualquier programa, haciendo clic en su icono o escribiendo “RStudio” en el indicador de ejecución de Windows. "],["packages2.html", "B Paquetes de R B.1 Instalando Paquetes B.2 Cargando Paquetes", " B Paquetes de R Muchas de las funciones más útiles de R no vienen precargadas cuando inicia R, sino que residen en paquetes que se pueden instalar encima de R. Los paquetes de R son similares a las bibliotecas en C, C++ y Javascript, los paquetes en Python y las gemas en Ruby. Un paquete de R agrupa funciones útiles, archivos de ayuda y conjuntos de datos. Puede usar estas funciones dentro de su propio código de R una vez que cargue el paquete en el que se encuentran. Por lo general, el contenido de un paquete de R está relacionado con un solo tipo de tarea, que el paquete ayuda a resolver. Los paquetes R le permitirán aprovechar las características más útiles de R: su gran comunidad de creadores de paquetes (muchos de los cuales son científicos de datos activos) y sus rutinas preescritas para manejar muchas tareas comunes (y exóticas) de ciencia de datos. R Básico Es posible que escuche a los usuarios de R (o a mí) referirse a “R básico” (o base R, en inglés). ¿Qué es R básico? Es solo la colección de funciones de R que se carga cada vez que inicia R. Estas funciones proporcionan los conceptos básicos del lenguaje, y no tiene que cargar un paquete antes de poder usarlas.. B.1 Instalando Paquetes Para usar un paquete de R, primero debe instalarlo en su computadora y luego cargarlo en su sesión de R actual. La forma más fácil de instalar un paquete de R es con la función de R install.packages. Abra R y escriba lo siguiente en la línea de comando: install.packages(&quot;&lt;nombre del paquete&gt;&quot;) Esto buscará el paquete especificado en la colección de paquetes alojados en el sitio CRAN. Cuando R encuentre el paquete, lo descargará en una carpeta de bibliotecas en su computadora. R puede acceder al paquete aquí en futuras sesiones de R sin reinstalarlo. Cualquiera puede escribir un paquete R y distribuirlo como quiera; sin embargo, casi todos los paquetes de R se publican a través del sitio web de CRAN. CRAN prueba cada paquete R antes de publicarlo. Esto no elimina todos los errores dentro de un paquete, pero significa que puede confiar en que un paquete en CRAN se ejecutará en la versión actual de R en su sistema operativo. Puede instalar varios paquetes a la vez vinculando sus nombres con la función de concatenación de R, c. Por ejemplo, para instalar los paquetes ggplot2, reshape2 y dplyr, ejecute: install.packages(c(&quot;ggplot2&quot;, &quot;reshape2&quot;, &quot;dplyr&quot;)) Si es la primera vez que instala un paquete, R le pedirá que elija un espejo en línea para instalarlo. Los espejos se enumeran por ubicación. Sus descargas deberían ser más rápidas si selecciona un espejo que esté cerca de usted. Si desea descargar un nuevo paquete, pruebe primero el espejo de Austria. Este es el repositorio principal de CRAN y, a veces, los nuevos paquetes pueden tardar un par de días en llegar a todos los demás espejos. B.2 Cargando Paquetes La instalación de un paquete no pone inmediatamente sus funciones al alcance de su mano. Simplemente los coloca en su computadora. Para usar un paquete de R, luego debe cargarlo en su sesión de R con el comando: library(&lt;nombre del paquete&gt;) Observe que las comillas han desaparecido. Puede usarlos si lo desea, pero las comillas son opcionales para el comando library. (Esto no es cierto para el comando install.packages). library pondrá a su disposición todas las funciones, conjuntos de datos y archivos de ayuda del paquete hasta que cierre su sesión de R actual. La próxima vez que inicie una sesión de R, deberá volver a cargar el paquete con library si desea utilizarlo, pero no tendrá que volver a instalarlo. Solo tiene que instalar cada paquete una vez. Después de eso, una copia del paquete vivirá en su biblioteca de R. Para ver qué paquetes tiene actualmente en su biblioteca de R, ejecute: library() library() también muestra la ruta a su biblioteca de R actual, que es la carpeta que contiene sus paquetes de R. Puede notar muchos paquetes que no recuerda haber instalado. Esto se debe a que R descarga automáticamente un conjunto de paquetes útiles cuando instala R por primera vez. Instalar paquetes desde (casi) cualquier sitio El paquete devtools de R facilita la instalación de paquetes desde ubicaciones distintas al sitio web de CRAN. devtools proporciona funciones como install_github, install_gitorious, install_bitbucket e install_url. Estos funcionan de manera similar a install.packages, pero buscan nuevas ubicaciones para paquetes de R. install_github es especialmente útil porque muchos desarrolladores de R proporcionan versiones de desarrollo de sus paquetes en GitHub. La versión de desarrollo de un paquete contendrá un adelanto de nuevas funciones y parches, pero puede que no sea tan estable o libre de errores como la versión CRAN. ¿Por qué R hace que te molestes en instalar y cargar paquetes? Puede imaginar una versión de R en la que todos los paquetes vengan precargados, pero este sería un programa muy grande y lento. A fecha del 6 de mayo de 2014, el sitio web de CRAN albergaba 5511 paquetes. Es más simple instalar y cargar solo los paquetes que desea usar cuando desea usarlos. Esto mantiene su copia de R rápida porque tiene menos funciones y páginas de ayuda para buscar en cualquier momento. Esto también tiene otros beneficios, por ejemplo, es posible actualizar su copia de un paquete de R sin actualizar toda su copia de R. ¿Cuál es la mejor manera de aprender sobre los paquetes de R? Es difícil usar un paquete de R si no sabe que existe. Puede ir al sitio web de CRAN y hacer clic en el enlace Paquetes para ver una lista de paquetes disponibles, pero tendrá que leer miles de ellos. Además, muchos paquetes de R hacen lo mismo. ¿Cómo sabe qué paquete los hace mejor? Los paquetes de R lista de correo es un lugar para comenzar. Envía anuncios de nuevos paquetes y mantiene un archivo de anuncios antiguos.Los blogs que agregan publicaciones sobre R también pueden proporcionar pistas valiosas, recomiendo R-bloggers. Posit mantiene una lista de algunos de los paquetes R más útiles en la sección de Getting Started de https://support.posit.co/. Finalmente, CRAN agrupa algunos de los paquetes más útiles y más respetados por área temática. Este es un excelente lugar para conocer los paquetes diseñados para su área de trabajo. "],["updating.html", "C Updating R and Its Packages C.1 R Packages", " C Updating R and Its Packages The R Core Development Team continuously hones the R language by catching bugs, improving performance, and updating R to work with new technologies. As a result, new versions of R are released several times a year. The easiest way to stay current with R is to periodically check the CRAN website. The website is updated for each new release and makes the release available for download. You’ll have to install the new release. The process is the same as when you first installed R. Don’t worry if you’re not interested in staying up-to-date on R Core’s doings. R changes only slightly between releases, and you’re not likely to notice the differences. However, updating to the current version of R is a good place to start if you ever encounter a bug that you can’t explain. RStudio also constantly improves its product. You can acquire the newest updates just by downloading them from RStudio. C.1 R Packages Package authors occasionally release new versions of their packages to add functions, fix bugs, or improve performance. The update.packages command checks whether you have the most current version of a package and installs the most current version if you do not. The syntax for update.packages follows that of install.packages. If you already have ggplot2, reshape2, and dplyr on your computer, it’d be a good idea to check for updates before you use them: update.packages(c(&quot;ggplot2&quot;, &quot;reshape2&quot;, &quot;dplyr&quot;)) You should start a new R session after updating packages. If you have a package loaded when you update it, you’ll have to close your R session and open a new one to begin using the updated version of the package. "],["dataio.html", "D Cargar y Guardar Datos en R D.1 Conjuntos de Datos en R Base D.2 Directorio de Trabajo D.3 Archivos de Texto Sin Formato D.4 Archivos de R D.5 Hojas de Cálculo de Excel D.6 Cargar Archivos desde Otros Programas D.7 Actualización", " D Cargar y Guardar Datos en R Este apéndice le mostrará cómo cargar y guardar datos en R desde archivos de texto sin formato, archivos de R y hojas de cálculo de Excel. También le mostrará los paquetes R que puede usar para cargar datos de bases de datos y otros programas comunes, como SAS y MATLAB. D.1 Conjuntos de Datos en R Base R viene con muchos conjuntos de datos precargados en el paquete datasets, que viene con la base de R. Estos conjuntos de datos no son muy interesantes, pero le brindan la oportunidad de probar el código o hacer un punto sin tener que cargar un conjunto de datos desde el exterior de R. Puede ver una lista de los conjuntos de datos de R, así como una breve descripción de cada uno, ejecutando: help(package = &quot;datasets&quot;) Para utilizar un conjunto de datos, simplemente escriba su nombre. Cada conjunto de datos ya está preguardado como un objeto R. Por ejemplo: iris ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa Sin embargo, los conjuntos de datos de R no reemplazan sus propios datos, que puede cargar en R desde una amplia variedad de formatos de archivo. Pero antes de cargar cualquier archivo de datos en R, deberá determinar dónde está su directorio de trabajo. D.2 Directorio de Trabajo Cada vez que abre R, se vincula a sí mismo a un directorio en su computadora, que R llama el directorio de trabajo. Aquí es donde R buscará los archivos cuando intente cargarlos, y es donde R guardará los archivos cuando los guarde. La ubicación de su directorio de trabajo variará en diferentes computadoras. Para determinar qué directorio está usando R como su directorio de trabajo, ejecute: getwd() ## &quot;/Users/garrettgrolemund&quot; Puede colocar archivos de datos directamente en la carpeta que es su directorio de trabajo, o puede mover su directorio de trabajo a donde están sus archivos de datos. Puede mover su directorio de trabajo a cualquier carpeta de su computadora con la función setwd. Simplemente proporcione a setwd la ruta del archivo a su nuevo directorio de trabajo. Prefiero configurar mi directorio de trabajo en una carpeta dedicada a cualquier proyecto en el que esté trabajando actualmente. De esa manera puedo mantener todos mis datos, secuencias de comandos, gráficos e informes en el mismo lugar. Por ejemplo: setwd(&quot;~/Users/garrettgrolemund/Documents/Book_Project&quot;) Si la ruta del archivo no comienza con su directorio raíz, R asumirá que comienza en su directorio de trabajo actual. También puede cambiar su directorio de trabajo haciendo clic en Session &gt; Set Working Directory &gt; Choose Directory en la barra de menu de RStudio. Las GUI de Windows y Mac tienen opciones similares. Si inicia R desde una línea de comandos de UNIX (como en las máquinas Linux), el directorio de trabajo será el directorio en el que se encontraba cuando llamó a R. Puede ver qué archivos hay en su directorio de trabajo con list.files(). Si ve el archivo que le gustaría abrir en su directorio de trabajo, entonces está listo para continuar. La forma en que abra los archivos en su directorio de trabajo dependerá del tipo de archivo que desee abrir. D.3 Archivos de Texto Sin Formato Los archivos de texto sin formato son una de las formas más comunes de guardar datos. Son muy simples y pueden ser leídos por muchos programas de computadora diferentes, incluso los editores de texto más básicos. Por esta razón, los datos públicos suelen presentarse como archivos de texto sin formato. Por ejemplo, la Oficina del Censo, la Administración del Seguro Social y la Oficina de Estadísticas Laborales ponen a disposición sus datos como archivos de texto sin formato. Así es como el conjunto de datos de la escalera real de Objetos de R aparecería como un archivo de texto sin formato (he agregado una columna de valor): &quot;carta&quot;, &quot;palo&quot;, &quot;valor&quot; &quot;as&quot;, &quot;picas&quot;, 14 &quot;rey&quot;, &quot;picas&quot;, 13 &quot;reina&quot;, &quot;picas&quot;, 12 &quot;jota&quot;, &quot;picas&quot;, 11 &quot;diez&quot;, &quot;picas&quot;, 10 Un archivo de texto sin formato almacena una tabla de datos en un documento de texto. Cada fila de la tabla se guarda en su propia línea y se usa una convención simple para separar las celdas dentro de una fila. A menudo, las celdas están separadas por una coma, pero también pueden estar separadas por una tabulación, un delimitador de barra vertical (es decir, | ) o cualquier otro carácter. Cada archivo solo utiliza un método de separación de celdas, lo que minimiza la confusión. Dentro de cada celda, los datos aparecen como esperarías verlos, como palabras y números. Todos los archivos de texto sin formato se pueden guardar con la extensión .txt (para texto), pero a veces un archivo recibirá una extensión especial que anuncia cómo separa las entradas de las celdas de datos. Dado que las entradas en el conjunto de datos mencionado anteriormente están separadas por una coma, este archivo sería un archivo de valores separados por comas y normalmente se guardaría con la extensión .csv. D.3.1 read.table Para cargar un archivo de texto sin formato, use read.table. El primer argumento de read.table debe ser el nombre de su archivo (si está en su directorio de trabajo), o la ruta del archivo a su archivo (si no está en su directorio de trabajo). Si la ruta del archivo no comienza con su directorio raíz, R lo agregará al final de la ruta del archivo que conduce a su directorio de trabajo. También puede darle a read.table otros argumentos. Los dos más importantes son sep y header. Si el conjunto de datos de la escalera real se guardó como un archivo llamado poquer.csv en su directorio de trabajo, podría cargarlo con: poquer &lt;- read.table(&quot;poquer.csv&quot;, sep = &quot;,&quot;, header = TRUE) D.3.1.1 sep Use sep para decirle a read.table qué carácter usa su archivo para separar las entradas de datos. Para averiguarlo, es posible que deba abrir su archivo en un editor de texto y mirarlo. Si no especifica un argumento sep, read.table intentará separar las celdas siempre que haya espacios en blanco, como una pestaña o un espacio. R no podrá decirle si read.table hace esto correctamente o no, así que confíe en él bajo su propio riesgo. D.3.1.2 header Use header para decirle a read.table si la primera línea del archivo contiene nombres de variables en lugar de valores. Si la primera línea del archivo es un conjunto de nombres de variables, debe establecer header = TRUE. D.3.1.3 na.strings A menudo, los conjuntos de datos utilizan símbolos especiales para representar la información que falta. Si sabe que sus datos utilizan un determinado símbolo para representar las entradas que faltan, puede decirle a read.table (y a las funciones anteriores) cuál es el símbolo con el argumento na.strings. read.table convertirá todas las instancias del símbolo de información faltante en NA, que es el símbolo de información faltante de R (consulte Información faltante). Por ejemplo, su conjunto de datos de póquer contenía valores faltantes almacenados como ., como este: ## &quot;carta&quot;,&quot;palo&quot;,&quot;valor&quot; ## &quot;as&quot;,&quot;picas&quot;,&quot; 14&quot; ## &quot;rey&quot;,&quot;picas&quot;,&quot; 13&quot; ## &quot;reina&quot;,&quot;.&quot;,&quot;.&quot; ## &quot;jota&quot;,&quot;.&quot;,&quot;.&quot; ## &quot;diez&quot;,&quot;.&quot;,&quot;.&quot; Puede leer el conjunto de datos en R y convertir los valores faltantes en NA a medida que avanza con el comando: poquer &lt;- read.table(&quot;poquer.csv&quot;, sep = &quot;,&quot;, header = TRUE, na.string = &quot;.&quot;) R guardaría una versión de poquer que se ve así: ## carta palo valor ## as picas 14 ## rey picas 13 ## reina &lt;NA&gt; NA ## jota &lt;NA&gt; NA ## diez &lt;NA&gt; NA D.3.1.4 skip and nrow A veces, un archivo de texto sin formato vendrá con un texto introductorio que no forma parte del conjunto de datos. O bien, puede decidir que solo desea leer una parte de un conjunto de datos. Puede hacer estas cosas con los argumentos skip y nrow. Use skip para decirle a R que salte un número específico de líneas antes de que comience a leer valores del archivo. Use nrow para decirle a R que deje de leer valores después de haber leído un cierto número de líneas. Por ejemplo, imagine que el archivo de escalera real completo se ve así: Estos datos fueron recopilados por el Instituto Nacional de Póquer. Accidentalmente repetimos la última fila de datos. &quot;cata&quot;, &quot;palo&quot;, &quot;valor&quot; &quot;as&quot;, &quot;picas&quot;, 14 &quot;rey&quot;, &quot;picas&quot;, 13 &quot;reina&quot;, &quot;picas&quot;, 12 &quot;jota&quot;, &quot;picas&quot;, 11 &quot;diez&quot;, &quot;picas&quot;, 10 &quot;diez&quot;, &quot;picas&quot;, 10 Puede leer solo las seis líneas que desee (cinco filas más un encabezado) con: read.table(&quot;poquer.csv&quot;, sep = &quot;,&quot;, header = TRUE, skip = 3, nrow = 5) ## carta palo valor ## 1 as picas 14 ## 2 rey picas 13 ## 3 reina picas 12 ## 4 jota picas 11 ## 5 diez picas 10 Tenga en cuenta que la fila del encabezado no cuenta para el total de filas permitidas por nrow. D.3.1.5 stringsAsFactors R lee números tal como cabría esperar, pero cuando R encuentra cadenas de caracteres (por ejemplo, letras y palabras), comienza a actuar de manera extraña. R quiere convertir cada cadena de caracteres en un factor. Este es el comportamiento predeterminado de R, pero creo que es un error. A veces los factores son útiles. En otras ocasiones, son claramente el tipo de datos incorrecto para el trabajo. Además, los factores provocan un comportamiento extraño, especialmente cuando desea mostrar datos. Este comportamiento puede ser sorprendente si no se dio cuenta de que R convirtió sus datos en factores. En general, tendrá una experiencia R más fluida si no permite que R genere factores hasta que los solicite. Afortunadamente, es fácil hacer esto. Establecer el argumento stringsAsFactors en FALSE asegurará que R guarde cualquier cadena de caracteres en su conjunto de datos como cadenas de caracteres, no como factores. Para usar stringsAsFactors, escribirías: read.table(&quot;poquer.csv&quot;, sep = &quot;,&quot;, header = TRUE, stringsAsFactors = FALSE) Si va a cargar más de un archivo de datos, puede cambiar el comportamiento de factorización predeterminado a nivel global con: options(stringsAsFactors = FALSE) Esto garantizará que todas las cadenas se lean como cadenas, no como factores, hasta que finalice su sesión de R o vuelva a cambiar el valor predeterminado global ejecutando: options(stringsAsFactors = TRUE) D.3.2 La Familia read R también viene con algunos atajos preempaquetados para read.table, que se muestran en la Tabla D.1. Table D.1: Funciones read de R. Puede sobrescribir cualquiera de los argumentos predeterminados según sea necesario. Función Por Defecto Uso read.table sep = ” “, header = FALSE Función de lectura de uso general read.csv sep = “,”, header = TRUE Archivos de variables separadas por comas (CSV) read.delim sep = “, header = TRUE Archivos delimitados por tabuladores read.csv2 sep = “;”, header = TRUE, dec = “,” Archivos CSV con formato decimal europeo read.delim2 sep = “, header = TRUE, dec =”,” Archivos delimitados por tabuladores con formato decimal europeo El primer atajo, read.csv, se comporta como read.table pero establece automáticamente sep = \",\" y header = TRUE, lo que puede ahorrarte algo de escritura: poquer &lt;- read.csv(&quot;poquer.csv&quot;) read.delim establece automáticamente sep en el carácter de tabulación, lo cual es muy útil para leer archivos delimitados por tabulaciones. Estos son archivos donde cada celda está separada por una pestaña. read.delim también establece header = TRUE por defecto. read.delim2 y read.csv2 existen para los usuarios europeos de R. Estas funciones le dicen a R que los datos usan una coma en lugar de un punto para indicar lugares decimales. (Si se pregunta cómo funciona esto con los archivos CSV, los archivos CSV2 generalmente separan las celdas con un punto y coma, no con una coma). Import Dataset También puede cargar archivos de texto sin formato con el botón Importar conjunto de datos de RStudio, como se describe en Cargando Datos. Importar conjunto de datos proporciona una versión GUI de read.table. D.3.3 read.fwf Un tipo de archivo de texto sin formato desafía el patrón al utilizar su diseño para separar las celdas de datos. Cada fila se coloca en su propia línea (al igual que con otros archivos de texto sin formato), y luego cada columna comienza en un número específico de caracteres desde el lado izquierdo del documento. Para lograr esto, se agrega un número arbitrario de espacios de caracteres al final de cada entrada para ubicar correctamente la siguiente entrada. Estos documentos se conocen como archivos de ancho fijo y normalmente terminan con la extensión .fwf. Esta es una forma en que el conjunto de datos de la escalera real podría verse como un archivo de ancho fijo. En cada fila, la entrada del palo comienza exactamente 10 caracteres desde el inicio de la línea. No importa cuántos caracteres aparecieron en la primera celda de cada fila: carta palo valor as picas 14 rey picas 13 reina picas 12 jota picas 11 diez picas 10 Los archivos de ancho fijo se ven bien a los ojos humanos (pero no mejor que un archivo delimitado por tabulaciones); sin embargo, puede ser difícil trabajar con ellos. Quizás debido a esto, R viene con una función para leer archivos de ancho fijo, pero no para guardarlos. Desafortunadamente, a las agencias del gobierno de EE. UU. parece gustarles los archivos de ancho fijo, y es probable que encuentre uno o más durante su carrera. Puede leer archivos de ancho fijo en R con la función read.fwf. La función toma los mismos argumentos que read.table pero requiere un argumento adicional, widths, que debería ser un vector de números. Cada entrada i del vector widths debe indicar el ancho (en caracteres) de la columna i del conjunto de datos. Si los datos de escalera real de ancho fijo antes mencionados se guardaron como poquer.fwf en su directorio de trabajo, podría leerlos con: poquer &lt;- read.fwf(&quot;poquer.fwf&quot;, widths = c(10, 7, 6), header = TRUE) D.3.4 Links HTML Muchos archivos de datos están disponibles en Internet en su propia dirección web. Si está conectado a Internet, puede abrir estos archivos directamente en R con read.table, read.csv, etc. Puede pasar una dirección web al argumento del nombre del archivo para cualquiera de las funciones de lectura de datos de R. . Como resultado, podría leer el conjunto de datos de póquer desde una dirección web como http://…/poquer.csv con: poquer &lt;- read.csv(&quot;http://.../poquer.csv&quot;) Obviamente, esa no es una dirección real, pero aquí hay algo que funcionaría, ¡si puede escribirlo! mazo &lt;- read.csv(&quot;https://gist.github.com/davidrsch/e59a71c228f5632634ebba08c7c7beaa/raw/mazo.csv&quot;) Solo asegúrese de que la dirección web se vincule directamente al archivo y no a una página web que se vincule al archivo. Por lo general, cuando visita la dirección web de un archivo de datos, el archivo comenzará a descargarse o los datos sin procesar aparecerán en la ventana de su navegador. Tenga en cuenta que los sitios web que comienzan con _https://_ son sitios web seguros, lo que significa que es posible que R no pueda acceder a los datos proporcionados en estos enlaces. D.3.5 Guardar Archivos de Texto Sin Formato Una vez que sus datos estén en R, puede guardarlos en cualquier formato de archivo compatible con R. Si desea guardarlo como un archivo de texto sin formato, puede utilizar la familia de funciones +write+. Las tres funciones básicas de write aparecen en Table D.2. Use write.csv para guardar sus datos como un archivo .csv y write.table para guardar sus datos como un documento delimitado por tabulaciones o un documento con separadores más exóticos. Table D.2: R guarda conjuntos de datos en archivos de texto sin formato con la familia de funciones write. Formato de archivo Función y sintaxis .csv write.csv(r_object, file = filepath, row.names = FALSE) .csv (con notación decimal europea) write.csv2(r_object, file = filepath, row.names = FALSE) Delimitado por tabulaciones write.table(r_object, file = filepath, sep = \"\\t\", row.names=FALSE) El primer argumento de cada función es el objeto de R que contiene su conjunto de datos. El argumento file es el nombre del archivo (incluida la extensión) que desea dar a los datos guardados. De forma predeterminada, cada función guardará sus datos en su directorio de trabajo. Sin embargo, puede proporcionar una ruta de archivo al argumento del archivo. R lo complacerá guardando el archivo al final de la ruta del archivo. Si la ruta del archivo no comienza con su directorio raíz, R lo agregará al final de la ruta del archivo que conduce a su directorio de trabajo. Por ejemplo, puede guardar el data frame (hipotético) póquer en un subdirectorio llamado data dentro de su directorio de trabajo con el comando: write.csv(poquer, &quot;data/poquer.csv&quot;, row.names = FALSE) Tenga en cuenta que write.csv y write.table no pueden crear nuevos directorios en su computadora. Cada carpeta en la ruta del archivo debe existir antes de intentar guardar un archivo con ella. El argumento row.names evita que R guarde los nombres de las filas del data frame como una columna en el archivo de texto sin formato. Es posible que haya notado que R nombra automáticamente cada fila en un data frame con un número. Por ejemplo, cada fila en nuestro data frame de póquer aparece con un número al lado: poquer ## carta palo valor ## 1 as picas 14 ## 2 rey picas 13 ## 3 reina picas 12 ## 4 jota picas 11 ## 5 diez picas 10 Estos números de fila son útiles, pero pueden acumularse rápidamente si comienza a guardarlos. R agregará un nuevo conjunto de números de forma predeterminada cada vez que vuelva a leer el archivo. Evite esto configurando siempre row.names = FALSE cuando use una función de la familia write. D.3.6 Comprimiendo Archivos Para comprimir un archivo de texto sin formato, rodee el nombre del archivo o la ruta del archivo con la función bzfile, gzfile o xzfile. Por ejemplo: write.csv(poquer, file = bzfile(&quot;data/poquer.csv.bz2&quot;), row.names = FALSE) Cada una de estas funciones comprimirá la salida con un tipo diferente de formato de compresión, que se muestra en la Tabla D.3. Table D.3: R viene con tres funciones auxiliares para comprimir archivos Función Tipo de compresión bzfile bzip2 gzfile gnu zip (gzip) xzfile compresión xz Es una buena idea ajustar la extensión de su archivo para reflejar la compresión. Las funciones `read`` de R abrirán archivos de texto sin formato comprimidos en cualquiera de estos formatos. Por ejemplo, podría leer un archivo comprimido llamado poquer.csv.bz2 con: read.csv(&quot;poquer.csv.bz2&quot;) o: read.csv(&quot;data/poquer.csv.bz2&quot;) dependiendo de dónde se encuentre el archivo. D.4 Archivos de R R proporciona dos formatos de archivo propios para almacenar datos, .RDS y .RData. Los archivos RDS pueden almacenar un único objeto R y los archivos RData pueden almacenar varios objetos R. Puede abrir un archivo RDS con readRDS. Por ejemplo, si los datos de la escalera real se guardaron como poquer.RDS, podría abrirlos con: poquer &lt;- readRDS(&quot;poquer.RDS&quot;) Abrir archivos RData es aún más fácil. Simplemente ejecute la función load con el archivo: load(&quot;archivo.RData&quot;) No hay necesidad de asignar la salida a un objeto. Los objetos de R en su archivo RData se cargarán en su sesión de R con sus nombres originales. Los archivos RData pueden contener varios objetos de R, por lo que cargar uno puede leer varios objetos. load no le dice cuántos objetos está leyendo, ni cuáles son sus nombres, por lo que vale la pena saber un poco sobre el archivo RData antes de cargarlo. En el peor de los casos, puede vigilar el panel de environment en RStudio mientras carga un archivo RData. Muestra todos los objetos que ha creado o cargado durante su sesión de R. Otro truco útil es poner paréntesis alrededor de tu comando de carga como (load(\"poquer.RData\")). Esto hará que R imprima los nombres de cada objeto que carga desde el archivo. Tanto readRDS como load toman una ruta de archivo como su primer argumento, al igual que las otras funciones de lectura y escritura de R. Si su archivo está en su directorio de trabajo, la ruta del archivo será el nombre del archivo. D.4.1 Guardar archivos de R Puede guardar un objeto de R como un data frame como un archivo RData o un archivo RDS. Los archivos RData pueden almacenar varios objetos de R a la vez, pero los archivos RDS son la mejor opción porque fomentan el código reproducible. Para guardar datos como un objeto RData, utilice la función save. Para guardar datos como un objeto RDS, use la función saveRDS. En cada caso, el primer argumento debe ser el nombre del objeto de R que desea guardar. Luego debe incluir un argumento de archivo que tenga el nombre del archivo o la ruta del archivo en el que desea guardar el conjunto de datos. Por ejemplo, si tiene tres objetos R, a, b y c, puede guardarlos todos en el mismo archivo RData y luego volver a cargarlos en otra sesión de R: a &lt;- 1 b &lt;- 2 c &lt;- 3 save(a, b, c, file = &quot;objetos.RData&quot;) load(&quot;objetos.RData&quot;) Sin embargo, si olvida los nombres de sus objetos o le da su archivo a otra persona para que lo use, será difícil determinar qué había en el archivo, incluso después de que usted (o ellos) lo carguen. La interfaz de usuario para archivos RDS es mucho más clara. Puede guardar solo un objeto por archivo, y quien lo cargue puede decidir cómo quiere llamar a sus nuevos datos. Como beneficio adicional, no tiene que preocuparse de que load sobrescriba cualquier objeto de R que tenga el mismo nombre que los objetos que está cargando: saveRDS(a, file = &quot;objeto.RDS&quot;) a &lt;- readRDS(&quot;objeto.RDS&quot;) Guardar sus datos como un archivo R ofrece algunas ventajas sobre guardar sus datos como un archivo de texto sin formato. R comprime automáticamente el archivo y también guardará los metadatos relacionados con R asociados con su objeto. Esto puede ser útil si sus datos contienen factores, fechas y horas o atributos de clase. No tendrá que volver a analizar esta información en R como lo haría si convirtiera todo en un archivo de texto. Por otro lado, muchos otros programas no pueden leer los archivos de R, lo que los hace ineficientes para compartir. También pueden crear un problema para el almacenamiento a largo plazo si no cree que tendrá una copia de R cuando vuelva a abrir los archivos. D.5 Hojas de Cálculo de Excel Microsoft Excel es un popular programa de hoja de cálculo que se ha convertido casi en el estándar de la industria en el mundo de los negocios. Es muy probable que necesite trabajar con una hoja de cálculo de Excel en R al menos una vez en su carrera. Puede leer hojas de cálculo en R y también guardar datos de R como una hoja de cálculo de varias maneras. D.5.1 Exportar desde Excel El mejor método para mover datos de Excel a R es exportar la hoja de cálculo de Excel como un archivo .csv o .txt. R no solo podrá leer el archivo de texto, también lo hará cualquier otro software de análisis de datos. Los archivos de texto son la lengua franca del almacenamiento de datos. Exportar los datos también resuelve otra dificultad. Excel usa formatos y metadatos patentados que no se transferirán fácilmente a R. Por ejemplo, un solo archivo de Excel puede incluir varias hojas de cálculo, cada una con sus propias columnas y macros. Cuando Excel exporta el archivo como .csv o .txt, se asegura de que este formato se transfiera a un archivo de texto sin formato de la forma más adecuada. Es posible que R no pueda administrar la conversión de manera tan eficiente. Para exportar datos desde Excel, abra la hoja de cálculo de Excel y luego vaya a Guardar como. Luego elija CSV en el cuadro Guardar como tipo que aparece y guarde los archivos. Luego puede leer el archivo en R con la función read.csv. D.5.2 Copiar y pegar También puede copiar partes de una hoja de cálculo de Excel y pegarlas en R. Para hacer esto, abra la hoja de cálculo y seleccione las celdas que desea leer en R. Luego seleccione Editar &gt; Copiar en la barra de menú, o use un atajo de teclado, para copia las celdas a tu portapapeles. En la mayoría de los sistemas operativos, puede leer los datos almacenados en su portapapeles en R con: read.table(&quot;clipboard&quot;) En Mac necesitarás usar: read.table(pipe(&quot;pbpaste&quot;)) Si las celdas contienen valores con espacios en ellos, esto interrumpirá read.table. Puede probar otra función `read`` (o simplemente exportar formalmente los datos de Excel) antes de leerlos en R. D.5.3 XLConnect Se han escrito muchos paquetes para ayudarlo a leer archivos de Excel directamente en R. Desafortunadamente, muchos de estos paquetes no funcionan en todos los sistemas operativos. Otros se han vuelto obsoletos debido al formato de archivo .xlsx. Un paquete que funciona en todos los sistemas de archivos (y recibe buenas críticas) es el paquete XLConnect. Para usarlo, deberá instalar y cargar el paquete: install.packages(&quot;XLConnect&quot;) library(XLConnect) XLConnect se basa en Java para ser independiente de la plataforma. Entonces, cuando abra XLConnect por primera vez, RStudio puede solicitarle que descargue un Java Runtime Environment si aún no tiene uno. D.5.4 Lectura de Hojas de Cálculo Puede usar XLConnect para leer en una hoja de cálculo de Excel con un proceso de uno o dos pasos. Comenzaré con el proceso de dos pasos. Primero, cargue un libro de trabajo de Excel con loadWorkbook. loadWorkbook puede cargar archivos .xls y .xlsx. Toma un argumento: la ruta del archivo a su libro de Excel (este será el nombre del libro de trabajo si está guardado en su directorio de trabajo): lt &lt;- loadWorkbook(&quot;archivo.xlsx&quot;) A continuación, lea una hoja de cálculo del libro de trabajo con readWorksheet, que toma varios argumentos. El primer argumento debe ser un objeto de libro de trabajo creado con loadWorkbook. El siguiente argumento, sheet, debe ser el nombre de la hoja de cálculo en el libro de trabajo que le gustaría leer en R. Este será el nombre que aparece en la pestaña inferior de la hoja de cálculo. También puede darle a sheet un número, que especifica la hoja en la que desea leer (uno para la primera hoja, dos para la segunda, y así sucesivamente). readWorksheet luego toma cuatro argumentos que especifican un cuadro delimitador de celdas para leer: startRow, startCol, endRow y endCol. Use startRow y startCol para describir la celda en la esquina superior izquierda del cuadro delimitador de celdas que desea leer. Use endRow y endCol para especificar la celda en la esquina inferior derecha de el cuadro delimitador. Cada uno de estos argumentos toma un número. Si no proporciona argumentos delimitadores, readWorksheet leerá en la región rectangular de celdas en la hoja de cálculo que parece contener datos. readWorksheet supondrá que esta región contiene una fila de encabezado, pero puede decir lo contrario con header = FALSE. Entonces, para leer en la primera hoja de trabajo de lt, podría usar: hoja1 &lt;- readWorksheet(lt, sheet = 1, startRow = 0, startCol = 0, endRow = 100, endCol = 3) R guardará la salida como un data frame. Todos los argumentos en readWorkbook excepto el primero están vectorizados, por lo que puede usarlo para leer varias hojas del mismo libro de trabajo a la vez (o varias regiones de celdas de una sola hoja de trabajo). En este caso, readWorksheet devolverá una lista de data frames. Puede combinar estos dos pasos con readWorksheetFromFile. Toma el argumento del archivo de loadWorkbook y lo combina con los argumentos de readWorksheet. Puede usarlo para leer una o más hojas directamente desde un archivo de Excel: hoja1 &lt;- readWorksheetFromFile(&quot;archivo.xlsx&quot;, sheet = 1, startRow = 0, startCol = 0, endRow = 100, endCol = 3) D.5.5 Escribir Hojas de Cálculo Escribir en una hoja de cálculo de Excel es un proceso de cuatro pasos. Primero, debe configurar un objeto de libro de trabajo con loadWorkbook. Esto funciona igual que antes, excepto que si no está utilizando un archivo de Excel existente, debe agregar el argumento create = TRUE. XLConnect creará un libro de trabajo en blanco. Cuando lo guarde, XLConnect lo escribirá en la ubicación del archivo que especificó aquí con loadWorkbook: lt &lt;- loadWorkbook(&quot;archivo.xlsx&quot;, create = TRUE) A continuación, debe crear una hoja de trabajo dentro de su objeto de libro de trabajo con createSheet. Dile a createSheet en qué libro colocar la hoja y cuál usar para la hoja. createSheet(lt, &quot;Hoja 1&quot;) Luego puede guardar su data frame o matriz en la hoja con writeWorksheet. El primer argumento de writeWorksheet, object, es el libro de trabajo para escribir los datos. El segundo argumento, data, son los datos a escribir. El tercer argumento, sheet, es el nombre de la hoja en la que escribirlo. Los siguientes dos argumentos, startRow y startCol, le indican a R en qué parte de la hoja de cálculo colocar la celda superior izquierda de los nuevos datos. Cada uno de estos argumentos tiene un valor predeterminado de 1. Finalmente, puede usar header para decirle a R si los nombres de sus columnas deben escribirse con los datos: writeWorksheet(lt, data = poquer, sheet = &quot;Hoja 1&quot;) Una vez que haya terminado de agregar hojas y datos a su libro de trabajo, puede guardarlo ejecutando saveWorkbook en el objeto del libro de trabajo. R guardará el libro de trabajo con el nombre de archivo o la ruta que proporcionó en loadWorkbook. Si esto conduce a un archivo de Excel existente, R lo sobrescribirá. Si conduce a un nuevo archivo, R lo creará. También puede colapsar estos pasos en una sola llamada con writeWorksheetToFile, así: writeWorksheetToFile(&quot;archivo.xlsx&quot;, data = poquer, sheet = &quot;Hoja 1&quot;, startRow = 1, startCol = 1) El paquete XLConnect también le permite hacer cosas más avanzadas con las hojas de cálculo de Excel, como escribir en una región con nombre en una hoja de cálculo, trabajar con fórmulas y asignar estilos a las celdas. Puede leer acerca de estas funciones en la viñeta de XLConnect, a la que se puede acceder cargando XLConnect y luego ejecutando: vignette(&quot;XLConnect&quot;) D.6 Cargar Archivos desde Otros Programas Debe seguir el mismo consejo que le di para los archivos de Excel siempre que desee trabajar con formatos de archivo nativos de otros programas: abra el archivo en el programa original y exporte los datos como un archivo de texto sin formato, generalmente un CSV. Esto garantizará la transcripción más fiel de los datos en el archivo y, por lo general, le brindará la mayor cantidad de opciones para personalizar la forma en que se transcriben los datos. A veces, sin embargo, puede adquirir un archivo pero no el programa del que procede. Como resultado, no podrá abrir el archivo en su programa nativo y exportarlo como un archivo de texto. En este caso, puede usar una de las funciones en Tabla D.4 para abrir el archivo. La mayoría de estas funciones vienen en el paquete foreign de R. Cada uno intenta leer en un formato de archivo diferente con la menor cantidad de contratiempos posible. Table D.4: Varias funciones intentarán leer los tipos de archivo de otros programas de análisis de datos Formato de archivo Función Paquete ERSI ArcGIS read.shapefile shapefiles Matlab readMat R.matlab minitab read.mtp foreign SAS (conjunto de datos permanente) read.ssd foreign SAS (formato XPORT) read.xport foreign SPSS read.spss foreign Stata read.dta foreign Systat read.systat foreign D.6.1 Conexión a bases de datos También puede usar R para conectarse a una base de datos y leer datos. Utilice el paquete RODBC para conectarse a bases de datos a través de una conexión ODBC. Utilice el paquete DBI para conectarse a bases de datos a través de controladores individuales. El paquete DBI proporciona una sintaxis común para trabajar con diferentes bases de datos. Tendrá que descargar un paquete específico de base de datos para usarlo junto con DBI. Estos paquetes proporcionan la API para los controladores nativos de diferentes programas de bases de datos. Para MySQL use RMySQL, para SQLite use RSQLite, para Oracle use ROracle, para PostgreSQL use RPostgreSQL y para las bases de datos que usan controladores basados en la API Java Database Connectivity (JDBC) use RJDBC. Una vez que haya cargado el paquete de controladores adecuado, puede utilizar los comandos proporcionados por DBI para acceder a su base de datos. D.7 Actualización En versiones modernas de RStudio es simple cargar archivos de Excel, SPSS, SAS y Stata usando el asistente de importación de RStudio. Para poder accerder a estas opciones se debe instalar el paquete readxl para los archivos de Excel y el paquete haven para el resto. Para realizar la operación es tan simple como dar click en el botón Import Dataset &gt; “Opción desead”(“From Excel”, “From SPSS”, “From SAS” o “From Stata”). Esto abrirá el asistente de importación de RStudio que permite visualizar el archivo a importar. Con el uso de los paquetes xlsx y haven se facilita también la forma de escribir y exportar archivos con dichas extenciones como se ve en la Tabla D.5. Table D.5: Varias funciones para escribir y guardar archivos en distintos formatos Formato de archivo Función Paquete Excel xlsx shapefiles SPSS write_sav haven SAS (conjunto de datos permanente) write_sas haven SAS (formato XPORT) write_xpt haven Stata write_dta haven "],["debug.html", "E Depuración de Código de R E.1 traceback E.2 browser E.3 Break Points E.4 debug E.5 trace E.6 recover", " E Depuración de Código de R This appendix refers to environments, the topic of [Environments], and uses examples from [Programs] and S3. You should read through these chapters first to get the most out of this appendix. R comes with a simple set of debugging tools that RStudio amplifies. You can use these tools to better understand code that produces an error or returns an unexpected result. Usually this will be your own code, but you can also examine the functions in R or one of its packages. Debugging code can take as much creativity and insight as writing code. There is no guarantee that you will find a bug or be able to fix it when you do. However, you can help yourself by using R’s debugging tools. These include the traceback, browser, debug, debugonce, trace, and recover functions. Using these tools is usually a two-step process. First, you locate where an error occurred. Then you try to determine why it occurred. You can do the first step with R’s traceback function. E.1 traceback The traceback tool pinpoints the location of an error. Many R functions call other R functions, which call other functions, and so on. When an error occurs, it may not be clear which of these functions went wrong. Let’s consider an example. The following functions call one another, and the last function creates an error (you’ll see why in a second): first &lt;- function() second() second &lt;- function() third() third &lt;- function() fourth() fourth &lt;- function() fifth() fifth &lt;- function() bug() When you run first, it will call second, which will call third, which will call fourth, which will call fifth, which will call bug, a function that does not exist. Here’s what that will look like at the command line: first() ## Error in fifth() : could not find function &quot;bug&quot; The error report tells us that the error occurred when R tried to run fifth. It also tells us the nature of the error (there is no function called bug). Here, it is obvious why R calls fifth, but it might not be so obvious why R calls a function when an error occurs in the wild. You can see the path of functions that R called before it hit an error by typing traceback() at the command line. traceback will return a call stack, a list of the functions that R called in the order that it called them. The bottom function will be the command that you entered in the command line. The top function will be the function that caused the error: traceback() ## 5: fifth() at #1 ## 4: fourth() at #1 ## 3: third() at #1 ## 2: second() at #1 ## 1: first() traceback will always refer to the last error you encountered. If you would like to look at a less recent error, you will need to recreate it before running traceback. How can this help you? First, traceback returns a list of suspects. One of these functions caused the error, and each function is more suspicious than the ones below it. Chances are that our bug came from fifth (it did), but it is also possible that an earlier function did something odd—like call fifth when it shouldn’t have. Second, traceback can show you if R stepped off the path that you expected it to take. If this happened, look at the last function before things went wrong. Third, traceback can reveal the frightening extent of infinite recursion errors. For example, if you change fifth so that it calls second, the functions will make a loop: second will call third, which will call fourth, which will call fifth, which will call second and start the loop over again. It is easier to do this sort of thing in practice than you might think: fifth &lt;- function() second() When you call first(), R will start to run the functions. After awhile, it will notice that it is repeating itself and will return an error. traceback will show just what R was doing: first() ## Error: evaluation nested too deeply: infinite recursion/options(expressions=)? traceback() ## 5000: fourth() at #1 ## 4999: third() at #1 ## 4998: second() at #1 ## 4997: fifth() at #1 ## 4996: fourth() at #1 ## 4995: third() at #1 ## 4994: second() at #1 ## 4993: fifth() at #1 ## ... Notice that there are 5,000 lines of output in this traceback. If you are using RStudio, you will not get to see the traceback of an infinite recursion error (I used the Mac GUI to get this output). RStudio represses the traceback for infinite recursion errors to prevent the large call stacks from pushing your console history out of R’s memory buffer. With RStudio, you will have to recognize the infinite recursion error by its error message. However, you can still see the imposing traceback by running things in a UNIX shell or the Windows or Mac GUIs. RStudio makes it very easy to use traceback. You do not even need to type in the function name. Whenever an error occurs, RStudio will display it in a gray box with two options. The first is Show Traceback, shown in Figure E.1. Figure E.1: RStudio’s Show Traceback option. If you click Show Traceback, RStudio will expand the gray box and display the traceback call stack, as in Figure E.2. The Show Traceback option will persist beside an error message in your console, even as you write new commands. This means that you can go back and look at the call stacks for all errors—not just the most recent error. Imagine that you’ve used traceback to pinpoint a function that you think might cause a bug. Now what should you do? You should try to figure out what the function did to cause an error while it ran (if it did anything). You can examine how the function runs with browser. Figure E.2: RStudio’s Traceback display. E.2 browser You can ask R to pause in the middle of running a function and give control back to you with browser. This will let you enter new commands at the command line. The active environment for these commands will not be the global environment (as usual); it will be the runtime environment of the function that you have paused. As a result, you can look at the objects that the function is using, look up their values with the same scoping rules that the function would use, and run code under the same conditions that the function would run it in. This arrangement provides the best chance for spotting the source of bugs in a function. To use browser, add the call browser() to the body of a function and then resave the function. For example, if I wanted to pause in the middle of the score function from [Programs], I could add browser() to the body of score and then rerun the following code, which defines score: score &lt;- function (symbols) { # identify case same &lt;- symbols[1] == symbols[2] &amp;&amp; symbols[2] == symbols[3] bars &lt;- symbols %in% c(&quot;B&quot;, &quot;BB&quot;, &quot;BBB&quot;) # get prize if (same) { payouts &lt;- c(&quot;DD&quot; = 100, &quot;7&quot; = 80, &quot;BBB&quot; = 40, &quot;BB&quot; = 25, &quot;B&quot; = 10, &quot;C&quot; = 10, &quot;0&quot; = 0) prize &lt;- unname(payouts[symbols[1]]) } else if (all(bars)) { prize &lt;- 5 } else { cherries &lt;- sum(symbols == &quot;C&quot;) prize &lt;- c(0, 2, 5)[cherries + 1] } browser() # adjust for diamonds diamonds &lt;- sum(symbols == &quot;DD&quot;) prize * 2 ^ diamonds } Now whenever R runs score, it will come to the call browser(). You can see this with the play function from [Programs]. If you don’t have play handy, you can access it by running this code: get_symbols &lt;- function() { wheel &lt;- c(&quot;DD&quot;, &quot;7&quot;, &quot;BBB&quot;, &quot;BB&quot;, &quot;B&quot;, &quot;C&quot;, &quot;0&quot;) sample(wheel, size = 3, replace = TRUE, prob = c(0.03, 0.03, 0.06, 0.1, 0.25, 0.01, 0.52)) } play &lt;- function() { symbols &lt;- get_symbols() structure(score(symbols), symbols = symbols, class = &quot;slots&quot;) } When you run play, play will call get_symbols and then score. As R works through score, it will come across the call to browser and run it. When R runs this call, several things will happen, as in Figure E.3. First, R will stop running score. Second, the command prompt will change to browser[1]&gt; and R will give me back control; I can now type new commands in at the new command prompt. Third, three buttons will appear above the console pane: Next, Continue, and Stop. Fourth, RStudio will display the source code for score in the scripts pane, and it will highlight the line that contains browser(). Fifth, the environments tab will change. Instead of revealing the objects that are saved in the global environment, it will reveal the objects that are saved in the runtime environment of score (see [Environments] for an explanation of R’s environment system). Sixth, RStudio will open a new Traceback pane, which shows the call stack RStudio took to get to browser. The most recent function, score, will be highlighted. I’m now in a new R mode, called browser mode. Browser mode is designed to help you uncover bugs, and the new display in RStudio is designed to help you navigate this mode. Any command that you run in browser mode will be evaluated in the context of the runtime environment of the function that called browser. This will be the function that is highlighted in the new Traceback pane. Here, that function is score. So while we are in browser mode, the active environment will be score’s runtime environment. This lets you do two things. Figure E.3: RStudio updates its display whenever you enter browser mode to help you navigate the mode. First, you can inspect the objects that score uses. The updated Environments pane shows you which objects score has saved in its local environment. You can inspect any of them by typing their name at the browser prompt. This gives you a way to see the values of runtime variables that you normally would not be able to access. If a value looks clearly wrong, you may be close to finding a bug: Browse[1]&gt; symbols ## [1] &quot;B&quot; &quot;B&quot; &quot;0&quot; Browse[1]&gt; same ## [1] FALSE Second, you can run code and see the same results that score would see. For example, you could run the remaining lines of the score function and see if they do anything unusual. You could run these lines by typing them into the command prompt, or you could use the three navigation buttons that now appear above the prompt, as in Figure E.4. The first button, Next, will run the next line of code in score. The highlighted line in the scripts pane will advance by one line to show you your new location in the score function. If the next line begins a code chunk, like a for loop or an if tree, R will run the whole chunk and will highlight the whole chunk in the script window. The second button, Continue, will run all of the remaining lines of score and then exit the browser mode. The third button, Stop, will exit browser mode without running any more lines of score. Figure E.4: You can navigate browser mode with the three buttons at the top of the console pane. You can do the same things by typing the commands n, c, and Q into the browser prompt. This creates an annoyance: what if you want to look up an object named n, c, or Q? Typing in the object name will not work, R will either advance, continue, or quit the browser mode. Instead you will have to look these objects up with the commands get(\"n\"), get(\"c\"), and get(\"Q\"). cont is a synonym for c in browser mode and where prints the call stack, so you’ll have to look up these objects with get as well. Browser mode can help you see things from the perspective of your functions, but it cannot show you where the bug lies. However, browser mode can help you test hypotheses and investigate function behavior. This is usually all you need to spot and fix a bug. The browser mode is the basic debugging tool of R. Each of the following functions just provides an alternate way to enter the browser mode. Once you fix the bug, you should resave your function a third time—this time without the browser() call. As long as the browser call is in there, R will pause each time you, or another function, calls score. E.3 Break Points RStudio’s break points provide a graphical way to add a browser statement to a function. To use them, open the script where you’ve defined a function. Then click to the left of the line number of the line of code in the function body where you’d like to add the browser statement. A hollow red dot will appear to show you where the break point will occur. Then run the script by clicking the Source button at the top of the Scripts pane. The hollow dot will turn into a solid red dot to show that the function has a break point (see Figure E.5). R will treat the break point like a browser statement, going into browser mode when it encounters it. You can remove a break point by clicking on the red dot. The dot will disappear, and the break point will be removed. Figure E.5: Break points provide the graphical equivalent of a browser statement. Break points and browser provide a great way to debug functions that you have defined. But what if you want to debug a function that already exists in R? You can do that with the debug function. E.4 debug You can “add” a browser call to the very start of a preexisting function with debug. To do this, run debug on the function. For example, you can run debug on sample with: debug(sample) Afterward, R will act as if there is a browser() statement in the first line of the function. Whenever R runs the function, it will immediately enter browser mode, allowing you to step through the function one line at a time. R will continue to behave this way until you “remove” the browser statement with undebug: undebug(sample) You can check whether a function is in “debugging” mode with isdebugged. This will return TRUE if you’ve ran debug on the function but have yet to run undebug: isdebugged(sample) ## FALSE If this is all too much of a hassle, you can do what I do and use debugonce instead of debug. R will enter browser mode the very next time it runs the function but will automatically undebug the function afterward. If you need to browse through the function again, you can just run debugonce on it a second time. You can recreate debugonce in RStudio whenever an error occurs. “Rerun with debug” will appear in the grey error box beneath Show Traceback (Figure E.1). If you click this option, RStudio will rerun the command as if you had first run debugonce on it. R will immediately go into browser mode, allowing you to step through the code. The browser behavior will only occur on this run of the code. You do not need to worry about calling undebug when you are done. E.5 trace You can add the browser statement further into the function, and not at the very start, with trace. trace takes the name of a function as a character string and then an R expression to insert into the function. You can also provide an at argument that tells trace at which line of the function to place the expression. So to insert a browser call at the fourth line of sample, you would run: trace(&quot;sample&quot;, browser, at = 4) You can use trace to insert other R functions (not just browser) into a function, but you may need to think of a clever reason for doing so. You can also run trace on a function without inserting any new code. R will prints trace:&lt;the function&gt; at the command line every time R runs the function. This is a great way to test a claim I made in S3, that R calls print every time it displays something at the command line: trace(print) first ## trace: print(function () second()) ## function() second() head(deck) ## trace: print ## face suit value ## 1 king spades 13 ## 2 queen spades 12 ## 3 jack spades 11 ## 4 ten spades 10 ## 5 nine spades 9 ## 6 eight spades 8 You can revert a function to normal after calling trace on it with untrace: untrace(sample) untrace(print) E.6 recover The recover function provides one final option for debugging. It combines the call stack of traceback with the browser mode of browser. You can use recover just like browser, by inserting it directly into a function’s body. Let’s demonstrate recover with the fifth function: fifth &lt;- function() recover() When R runs recover, it will pause and display the call stack, but that’s not all. R gives you the option of opening a browser mode in any of the functions that appear in the call stack. Annoyingly, the call stack will be displayed upside down compared to traceback. The most recent function will be on the bottom, and the original function will be on the top: first() ## ## Enter a frame number, or 0 to exit ## ## 1: first() ## 2: #1: second() ## 3: #1: third() ## 4: #1: fourth() ## 5: #1: fifth() To enter a browser mode, type in the number next to the function in whose runtime environment you would like to browse. If you do not wish to browse any of the functions, type 0: 3 ## Selection: 3 ## Called from: fourth() ## Browse[1]&gt; You can then proceed as normal. recover gives you a chance to inspect variables up and down your call stack and is a powerful tool for uncovering bugs. However, adding recover to the body of an R function can be cumbersome. Most R users use it as a global option for handling errors. If you run the following code, R will automatically call recover() whenever an error occurs: options(error = recover) This behavior will last until you close your R session, or reverse the behavior by calling: options(error = NULL) "]]
