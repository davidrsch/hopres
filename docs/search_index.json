[["index.html", "Programación práctica con R Bienvenido Sobre la traducción Sobre la versión original en inglés", " Programación práctica con R Garrett Grolemund Bienvenido Este es el sitio web para la versión en español de “Hands-On Programming with R” (en lo adelante “Programación Práctica con R”) de Garrett Grolemund. Este libro le enseñará cómo programar en R, con ejemplos prácticos. Fue escrito para personas que no son programadores con el objetivo de proporcionar una introducción amigable al lenguaje R. Aprenderá a cargar datos, ensamblar y desensamblar objetos de datos, navegar por el sistema de entorno de R, escribir sus propias funciones y utilizar todas las herramientas de programación de R. A lo largo del libro, utilizará sus nuevas habilidades para resolver problemas prácticos de ciencia de datos. Si ya se siente cómodo con R y le gustaría enfocarse en cómo analizar datos usando los paquetes Tidyverse de R, se recomienda R para la Ciencia de Datos, un libro de Garrett Grolemund y Hadley Wickham. Sobre la traducción Esta traducción de “Programación práctica con R” es un proyecto personal de David Díaz Rodríguez con el objetivo de facilitar el estudio del lenguje de programación R, tanto al propio traductor como a todas aquellas personas de habla hispana que deseen aprender a programar con R. Señalar que esta es una traducción textual del libro por lo que en lo adelante cuando el autor se refiere así mismo en primera persona, será Garrett Grolemund y no el traductor, a excepción del prefacio que fue escrito por Hadley Wickham. Sobre la versión original en inglés Puede consultar la versión original del libro en Hands-On Programming with R. Si desea una copia física del libro, puede solicitarla en amazon; fue publicado por O’Reilly en julio de 2014. Si desea retribuir, considere informar un error tipográfico o realizar un pull request en github.com/rstudio-education/hopr para la versión original y en github.com/davidrsch/hopres para esta traducción. Este sitio web es (y siempre será) de uso gratuito y está licenciado bajo la licencia Creative Commons Attribution-NonCommercial-NoDerivs 4.0. El libro está escrito en RMarkdown con bookdown. "],["prefacio.html", "Prefacio Convenciones Usadas en Este Libro Reconocimientos", " Prefacio Este libro le enseñará cómo programar en R. Pasará de cargar datos a escribir sus propias funciones (que superarán las funciones de otros usuarios de R). Pero esta no es una introducción típica a R. Quiero ayudarlo a convertirse en científico de datos, así como en informático, por lo que este libro se centrará en las habilidades de programación que están más relacionadas con la ciencia de datos. Los capítulos del libro están ordenados de acuerdo con tres proyectos prácticos; dado que son proyectos bastante sustanciales, abarcan varios capítulos. Elegí estos proyectos por dos razones. Primero, cubren la amplitud del lenguaje R. Aprenderá a cargar datos, ensamblar y desensamblar objetos de datos, navegar por el sistema de entorno de R, escribir sus propias funciones y utilizar todas las herramientas de programación de R, como declaraciones if else, bucles, clases S3, sistema de paquetes de R, y las herramientas de depuración de R. Los proyectos también le enseñarán cómo escribir código R vectorizado, un estilo de código ultrarrápido que aprovecha todas las cosas que R hace mejor. Pero, lo que es más importante, los proyectos le enseñarán cómo resolver los problemas logísticos de la ciencia de datos—y hay muchos problemas logísticos. Cuando trabaje con datos, deberá almacenar, recuperar y manipular grandes conjuntos de valores sin introducir errores. A medida que avance en el libro, le enseñaré no solo cómo programar con R, sino también cómo usar las habilidades de programación para respaldar su trabajo como científico de datos. No todos los programadores necesitan ser científicos de datos, por lo que no todos los programadores encontrarán útil este libro. Encontrará este libro útil si se encuentra en una de las siguientes categorías: Ya usas R como herramienta estadística, pero te gustaría aprender a escribir tus propias funciones y simulaciones con R. Te gustaría aprender a programar por tu cuenta y ves el sentido de aprender un lenguaje relacionado con la ciencia de datos. Una de las mayores sorpresas de este libro es que no cubro las aplicaciones tradicionales de R, como modelos y gráficos; en cambio, trato a R puramente como un lenguaje de programación. ¿Por qué este enfoque estrecho? R está diseñado para ser una herramienta que ayude a los científicos a analizar datos. Tiene muchas funciones excelentes que hacen gráficos y ajustan modelos a los datos. Como resultado, muchos estadísticos aprenden a usar R como si fuera una pieza de software: aprenden qué funciones hacen lo que quieren e ignoran el resto. Este es un enfoque comprensible para aprender R. La visualización y el modelado de datos son habilidades complicadas que requieren toda la atención de un científico. Se necesita experiencia, juicio y enfoque para extraer información confiable de un conjunto de datos. No recomendaría que ningún científico de datos se distraiga con la programación de computadoras hasta que se sienta cómodo con la teoría y la práctica básicas de su oficio. Si desea aprender el oficio de la ciencia de datos, le recomiendo el libro R para la Ciencia de Datos, mi volumen complementario a este libro, coescrito con Hadley Wickham. Sin embargo, aprender a programar debería estar en la lista de tareas de todos los científicos de datos. Saber programar lo convertirá en un analista más flexible y aumentará su dominio de la ciencia de datos en todos los sentidos. Mi metáfora favorita para describir esto fue presentada por Greg Snow en la lista de correo de ayuda de R en mayo de 2006. Usar funciones en R es como viajar en autobús. Escribir funciones en R es como conducir un coche. Los autobuses son muy fáciles de usar, solo necesita saber a qué autobús subir, dónde subir y dónde bajarse (y debe pagar su tarifa). Los autos, por otro lado, requieren mucho más trabajo: necesitas tener algún tipo de mapa o direcciones (incluso si el mapa está en tu cabeza), necesitas poner gasolina de vez en cuando, necesitas saber las reglas de la vía (tener algún tipo de licencia de conducir). La gran ventaja del automóvil es que puede llevarlo a muchos lugares a los que el autobús no llega y es más rápido para algunos viajes que requieren transbordo entre autobuses. Usando esta analogía, los programas como SPSS son buses, fáciles de usar para cosas estándar, pero muy frustrantes si quieres hacer algo que no está preprogramado. R es un todoterreno con tracción en las cuatro ruedas (aunque respetuoso con el medio ambiente) con una bicicleta en la parte trasera, un kayak en la parte superior, buenos zapatos para caminar y correr en el asiento del pasajero y equipo para escalar montañas y espeleología en la parte trasera. R puede llevarlo a donde quiera ir si se toma el tiempo para aprender a usar el equipo, pero eso llevará más tiempo que aprender dónde están las paradas de autobús en SPSS. - Greg Snow Greg compara R con SPSS, pero asume que usa todos los poderes de R; es decir, que aprendas a programar en R. Si solo usas funciones que ya existen en R, estás usando R como SPSS: es un bus que solo te puede llevar a ciertos lugares. Esta flexibilidad es importante para los científicos de datos. Los detalles exactos de un método o simulación cambiarán de un problema a otro. Si no puede crear un método adaptado a su situación, puede verse tentado a hacer suposiciones poco realistas solo para poder utilizar un método inadecuado que ya existe. Este libro te ayudará a dar el salto del autobús al automóvil. Lo he escrito para programadores principiantes. No hablo de la teoría de las ciencias de la computación—no hay discusiones sobre la gran O() y la pequeña o() en estas páginas. Tampoco entro en detalles avanzados como el funcionamiento de la evaluación concisa. Estas aspectos son interesantes si piensas en informática a nivel teórico, pero son una distracción cuando aprendes a programar por primera vez. En su lugar, te enseño a programar en R con tres ejemplos concretos. Estos ejemplos son cortos, fáciles de entender y cubren todo lo que necesita saber. He enseñado este material muchas veces en mi trabajo como Master Instructor en RStudio. Como docente, he descubierto que los estudiantes aprenden conceptos abstractos mucho más rápido cuando se ilustran con ejemplos concretos. Los ejemplos también tienen una segunda ventaja: proporcionan una práctica inmediata. Aprender a programar es como aprender a hablar otro idioma—yprogresas más rápido cuando practicas. De hecho, aprender a programar es aprender a hablar otro idioma. Obtendrá los mejores resultados si sigue los ejemplos del libro y experimenta cada vez que se le ocurre una idea. El libro es un complemento de R para la Ciencia de Datos. En ese libro, Hadley Wickham y yo explicamos cómo usar R para hacer diagramas, modelar datos y escribir informes. Ese libro enseña estas tareas como habilidades de ciencia de datos, que requieren juicio y experiencia—no como ejercicios de programación, que también lo son. Este libro le enseñará a programar en R. No se supone que haya dominado las habilidades de ciencia de datos que se enseñan en R para la Ciencia de Datos (ni que tenga la intención de hacerlo). Sin embargo, este conjunto de habilidades amplifica ese. Y si domina ambos, será un científico de datos con conocimientos de informática, apto para obtener un salario alto e influir en el diálogo científico. Convenciones Usadas en Este Libro En este libro se utilizan las siguientes convenciones tipográficas: Cursiva:: Indica nuevos términos, URL, direcciones de correo electrónico, nombres de archivo y extensiones de archivo. Ancho contante:: se utiliza para listas de programas, así como dentro de párrafos para referirse a elementos de programas como nombres de variables o funciones, bases de datos, tipos de datos, variables de entorno, declaraciones y palabras clave. `Negrita de ancho constante:: Smuestra comandos u otro texto que el usuario debe escribir literalmente. Cursiva de ancho constante:: muestra texto que debe reemplazarse con valores proporcionados por el usuario o por valores determinados por el contexto. Para comentar o hacer preguntas técnicas sobre este libro, presente un issue en github.com/rstudio-education/hopr. Reconocimientos Muchas personas excelentes me han ayudado a escribir este libro, desde mis dos editoras, Courtney Nash y Julie Steele, hasta el resto del equipo de O’Reilly, quienes diseñaron, corrigieron e indexaron el libro. Además, Greg Snow me permitió generosamente citarlo en este prefacio. Les ofrezco todo mi más sincero agradecimiento. También me gustaría agradecer a Hadley Wickham, quien ha moldeado la forma en que pienso y enseño R. Muchas de las ideas de este libro provienen de Estadística 405, un curso que ayudé a enseñar a Hadley cuando era estudiante de doctorado en la Universidad de Rice. Más ideas provinieron de los estudiantes y profesores de Introducción a la ciencia de datos con R, un taller que enseño en nombre de RStudio. Gracias a todos ustedes. Me gustaría agradecer especialmente a mis asistentes de enseñanza Josh Paulson, Winston Chang, Jaime Ramos, Jay Emerson y Vivian Zhang. Gracias también a JJ Allaire y al resto de mis colegas de RStudio que proporcionan el IDE de RStudio, una herramienta que hace que sea mucho más fácil usar, enseñar y escribir sobre R. Finalmente, quisiera agradecer a mi esposa, Kristin, por su apoyo y comprensión mientras escribía este libro. "],["proyecto-1-dados-ponderados.html", "1 Proyecto 1: Dados Ponderados", " 1 Proyecto 1: Dados Ponderados Las computadoras le permiten ensamblar, manipular y visualizar conjuntos de datos, todo a velocidades que habrían asombrado a los científicos de ayer. En resumen, ¡las computadoras te dan superpoderes científicos! Pero si desea usarlos, deberá adquirir algunas habilidades de programación. Como científico de datos que sabe programar, mejorará su capacidad para: Memorizar (almacenar) conjuntos de datos completos Recuperar valores de datos demandados Realizar cálculos complejos con grandes cantidades de datos Realizar tareas repetitivas sin descuidarse ni aburrirse Las computadoras pueden hacer todas estas cosas rápidamente y sin errores, lo que le permite a su mente hacer lo que mejor hace bien: tomar decisiones y asignar significado. ¿Suena emocionante? ¡Estupendo! Vamos a empezar. Cuando era estudiante universitario, a veces soñaba despierto con ir a Las Vegas. Pensé que saber estadísticas podría ayudarme a ganar a lo grande. Si eso es lo que te llevó a la ciencia de datos, será mejor que te sientes; tengo algunas malas noticias. Incluso un estadístico perderá dinero en un casino a largo plazo. Esto se debe a que las probabilidades de cada juego siempre están a favor del casino, sin embargo, hay una laguna en esta regla. Puede ganar dinero–y también de manera confiable. Todo lo que tienes que hacer es ser el casino. Lo creas o no, R puede ayudarte a hacerlo. A lo largo del libro, usará R para construir tres objetos virtuales: un par de dados que puede lanzar para generar números aleatorios, una baraja de cartas que puede barajar y repartir, y una máquina tragamonedas inspirada en máquinas reales. Después de eso, solo necesitará agregar algunos gráficos de video y una cuenta bancaria (y tal vez obtener algunas licencias gubernamentales), y estará en el negocio. Te dejo esos detalles a ti. Estos proyectos son ligeros, pero también profundos. A medida que los complete, se convertirá en un experto en las habilidades que necesita para trabajar con datos como científico de datos. Aprenderá cómo almacenar datos en la memoria de su computadora, cómo acceder a los datos que ya están allí y cómo transformar los valores de los datos en la memoria cuando sea necesario. También aprenderá a escribir sus propios programas en R que puede usar para analizar datos y ejecutar simulaciones. Si simular una máquina tragamonedas (o dados o cartas) parece frívolo, piénselo de esta manera: jugar en una máquina tragamonedas es un proceso. Una vez que pueda simularlo, podrá simular otros procesos, como el muestreo de arranque, la cadena de Markov Monte Carlo y otros procedimientos de análisis de datos. Además, estos proyectos brindan ejemplos concretos para aprender todos los componentes de la programación R: objetos, tipos de datos, clases, notación, funciones, entornos, árboles if, bucles y vectorización. Este primer proyecto facilitará el estudio de estas cosas al enseñarle los conceptos básicos de R. Su primera misión es simple: ensamblar código R que simulará lanzar un par de dados, como en una mesa de dados. Una vez que haya hecho eso, ponderaremos un poco los dados a su favor, solo para mantener las cosas interesantes. En este proyecto, aprenderá cómo: Utilizar las interfaces R y RStudio Ejecutar comandos R Crear objetos R Escribir sus propias funciones y scripts de R Cargar y usar paquetes R Generar muestras aleatorias Crear gráficos de manera rápida Obtener ayuda cuando la necesite No se preocupe si parece que cubrimos mucho terreno de manera rápido. Este proyecto está diseñado para brindarle una descripción general concisa del lenguaje R. Regresará a muchos de los conceptos que aprederá en los proyectos 2 y 3, donde examinará los conceptos en profundidad. Deberá tener R y RStudio instalados en su computadora antes de poder usarlos. Ambos son gratuitos y fáciles de descargar. Consulte el Apéndice A para obtener instrucciones completas. Si está listo para comenzar, abra RStudio en su computadora y siga leyendo. "],["Básico.html", "2 Lo Más Básico 2.1 La Interfaz de Usuario de R 2.2 Objetos 2.3 Funciones 2.4 Escribiendo Sus Propias Funciones 2.5 Argumentos 2.6 Scripts 2.7 Resumen", " 2 Lo Más Básico Este capítulo proporciona una descripción general amplia del lenguaje R que lo ayudará a programar de inmediato. En él, construirás un par de dados virtuales que puedes usar para generar números aleatorios. No se preocupe si nunca ha programado antes; el capítulo le enseñará todo lo que necesita saber. Para simular un par de dados, tendrás que destilar cada dado en sus características esenciales. No puede colocar un objeto físico, como un dado, en una computadora (bueno, no sin destornillar algunos tornillos), pero puede guardar información sobre el objeto en la memoria de su computadora. ¿Qué información debe guardar? En general, un dado tiene seis piezas importantes de información: cuando tiras un dado, solo puede dar como resultado uno de los seis números: 1, 2, 3, 4, 5 y 6. Puedes capturar las características esenciales de un dado guardando los números 1, 2, 3, 4, 5 y 6 como un grupo de valores en la memoria de su computadora. Trabajemos primero en guardar estos números y luego consideremos un método para “lanzar” nuestro dado. 2.1 La Interfaz de Usuario de R Antes de que pueda pedirle a su computadora que guarde algunos números, necesitará saber cómo hablarle. Ahí es donde entran R y RStudio. RStudio le brinda una manera de comunicarse con su computadora. R le brinda un idioma para hablar. Para comenzar, abra RStudio tal como abriría cualquier otra aplicación en su computadora. Cuando lo haga, debería aparecer una ventana en su pantalla como la que se muestra en la Figura 2.1. Figure 2.1: Su computadora cumple con sus órdenes cuando escribe comandos R en el indicador en la línea inferior del panel de la consola. No olvides presionar la tecla Enter. Cuando abre RStudio por primera vez, la consola aparece en el panel de su izquierda, pero puede cambiar esto con File &gt; Preferences en la barra de menú. Si aún no tiene R y RStudio instalados en su computadora–o no sabe de lo que estoy hablando– visite el [Apéndice A] (#starting). El apéndice le dará una descripción general de las dos herramientas gratuitas y le indicará cómo descargarlas. La interfaz de RStudio es simple. Escriba el código R en la línea inferior del panel de la consola de RStudio y luego haga clic en Entrar para ejecutarlo. El código que escribe se llama comando, porque ordenará a su computadora que haga algo por usted. La línea en la que lo escribe se llama línea de comando. Cuando escribe un comando en la consola y presiona Enter, su computadora ejecuta el comando y le muestra los resultados. Luego, RStudio muestra un mensaje nuevo para su próximo comando. Por ejemplo, si escribe 1 + 1 y pulsa Enter, RStudio mostrará: &gt; 1 + 1 [1] 2 &gt; Notarás que aparece un [1] al lado de tu resultado. R solo le informa que esta línea comienza con el primer valor en su resultado. Algunos comandos devuelven más de un valor y sus resultados pueden llenar varias líneas. Por ejemplo, el comando 100:130 devuelve 31 valores; crea una secuencia de números enteros del 100 al 130. Observe que aparecen nuevos números entre corchetes al comienzo de la segunda y tercera líneas de salida. Estos números solo significan que la segunda línea comienza con el valor 14 en el resultado y la tercera línea comienza con el valor 25. En su mayoría, puede ignorar los números que aparecen entre corchetes: &gt; 100:130 [1] 100 101 102 103 104 105 106 107 108 109 110 111 112 [14] 113 114 115 116 117 118 119 120 121 122 123 124 125 [25] 126 127 128 129 130 El operador de dos puntos (:) devuelve todos los números enteros entre los dos números enteros especificados antes y después de los dos puntos. Es una manera fácil de crear una secuencia de números. ¿R no es un idioma? Es posible que me escuche hablar de R en tercera persona. Por ejemplo, podría decir: “Dígale a R que haga esto” o “Dígale a R que haga aquello”, pero, por supuesto, R no puede hacer nada; es solo un idioma. Esta forma de hablar es una forma abreviada de decir: “Dígale a su computadora que haga esto escribiendo un comando en el lenguaje R en su consola RStudio”. Su computadora, y no R, hace el trabajo real. ¿Es esta abreviatura confusa y un poco perezosa de usar? Sí. ¿Lo usa mucha gente? Todos los que conozco, probablemente porque es muy conveniente. ¿Cuándo compilamos? En algunos lenguajes, como C, Java y FORTRAN, debe compilar su código legible por humanos en un código legible por máquina (a menudo 1 y 0) antes de poder ejecutarlo. Si ha programado en un lenguaje de este tipo antes, puede preguntarse si tiene que compilar su código R antes de poder usarlo. La respuesta es no. R es un lenguaje de programación dinámico, lo que significa que R interpreta automáticamente su código a medida que lo ejecuta. Si escribe un comando incompleto y presiona Enter, R mostrará un + en la consola, lo que significa que R está esperando que escriba el resto de su comando. Termina el comando o presiona Escape para comenzar de nuevo: &gt; 5 - + + 1 [1] 4 Si escribe un comando que R no reconoce, R devolverá un mensaje de error. Si alguna vez ve un mensaje de error, no entre en pánico. R solo le está diciendo que su computadora no pudo entender o hacer lo que le pidió que hiciera. Luego puede probar un comando diferente en la siguiente línea: &gt; 3 % 5 Error: unexpected input in &quot;3 % 5&quot; &gt; Una vez que domines la línea de comando, puedes hacer fácilmente cualquier cosa en R que harías con una calculadora. Por ejemplo, podrías hacer algo de aritmética básica: 2 * 3 ## 6 4 - 1 ## 3 6 / (4 - 1) ## 2 ¿Notaste algo diferente en este código? He dejado fuera los &gt; y [1]. Esto hará que el código sea más fácil de copiar y pegar si desea colocarlo en su propia consola. R trata el carácter del hashtag, #, de una manera especial; R no ejecutará nada que siga a un hashtag en una línea. Esto hace que los hashtags sean muy útiles para agregar comentarios y anotaciones a su código. Los humanos podrán leer los comentarios, pero su computadora los pasará por alto. El hashtag se conoce como símbolo de comentario en R. En el resto del libro, usaré hashtags para mostrar los resultados de las lineas de código R. Usaré un solo hashtag para agregar mis propios comentarios y un hashtag doble, ##, para mostrar los resultados del código. Evitaré mostrar &gt; y [1] a menos que quiera que los mires. Cancelar comandos Algunos comandos de R pueden tardar mucho tiempo en ejecutarse. Puede cancelar un comando una vez que ha comenzado presionando ctrl + c. Tenga en cuenta que R también puede tardar mucho tiempo en cancelar el comando. Ejercicio 2.1 (Magia con Numeros) Esa es la interfaz básica para ejecutar código R en RStudio. ¿Crees que lo tienes? Si es así, intente realizar estas sencillas tareas. Si ejecuta todo correctamente, debería terminar con el mismo número con el que comenzó: Elige cualquier número y súmale 2. Multiplica el resultado por 3. Resta 6 de la respuesta. Divide lo que obtienes por 3. A lo largo del libro, pondré ejercicios en partes, como el de arriba. Seguiré cada ejercicio con una respuesta modelo, como la siguiente. Solution. Puede comenzar con el número 10 y luego seguir los siguientes pasos: 10 + 2 ## 12 12 * 3 ## 36 36 - 6 ## 30 30 / 3 ## 10 2.2 Objetos Ahora que sabes cómo usar R, usémoslo para hacer un dado virtual. El operador : de hace un par de páginas le brinda una buena manera de crear un grupo de números del uno al seis. El operador : devuelve sus resultados como un vector, un conjunto unidimensional de números: 1:6 ## 1 2 3 4 5 6 ¡Eso es todo lo que hay sobre el aspecto de un dado virtual! Pero aún no has terminado. Ejecutar 1:6 generó un vector de números para que lo veas, pero no guardó ese vector en ninguna parte de la memoria de tu computadora. Lo que está viendo son básicamente las huellas de seis números que existieron brevemente y luego se fundieron de nuevo en la memoria RAM de tu computadora. Si desea volver a usar esos números, tendrá que pedirle a su computadora que los guarde en algún lugar. Puede hacerlo creando un objeto de R. R le permite guardar datos almacenándolos dentro de un objeto R. ¿Qué es un objeto? Solo un nombre que puede usar para recuperar datos almacenados. Por ejemplo, puede guardar datos en un objeto como a o b. Siempre que R encuentre el objeto, lo reemplazará con los datos guardados en su interior, así: a &lt;- 1 a ## 1 a + 2 ## 3 ¿Qué acaba de suceder? Para crear un objeto R, elija un nombre y luego use el símbolo menor que, &lt;, seguido de un signo menos, -, para guardar datos en él. Esta combinación parece una flecha, &lt;-. R creará un objeto, le dará su nombre y almacenará en él lo que siga a la flecha. Entonces a &lt;- 1 almacena 1 en un objeto llamado a. Cuando le preguntas a R qué hay en a, R te dice en la siguiente línea. También puede usar su objeto en nuevos comandos R. Dado que a almacenó previamente el valor de 1, ahora está agregando 1 a 2. Entonces, para otro ejemplo, el siguiente código crearía un objeto llamado dado que contiene los números del uno al seis. Para ver lo que está almacenado en un objeto, simplemente escriba el nombre del objeto por sí mismo: dado &lt;- 1:6 dado ## 1 2 3 4 5 6 Cuando crea un objeto, el objeto aparecerá en el panel de Environment de RStudio, como se muestra en la Figura 2.2. Este panel le mostrará todos los objetos que ha creado desde que abrió RStudio. Figure 2.2: El panel de Environment de RStudio realiza un seguimiento de los objetos R que crea. Puedes nombrar un objeto en R casi como quieras, pero hay algunas reglas. Primero, un nombre no puede comenzar con un número. Segundo, un nombre no puede usar algunos símbolos especiales, como ^, !, $, @, +, -, /, or *: Buenos nombres Nombres que causan error a 1trial b $ FOO ^mean my_var 2nd .day !bad Mayúsculas R distingue entre mayúsculas y minúsculas, por lo que nombre y Nombre se referirán a diferentes objetos: Nombre &lt;- 1 nombre &lt;- 0 Nombre + 1 ## 2 Finalmente, R sobrescribirá cualquier información anterior almacenada en un objeto sin pedirle permiso. Por lo tanto, es una buena idea no usar nombres que ya están en uso: my_number &lt;- 1 my_number ## 1 my_number &lt;- 999 my_number ## 999 Puedes ver qué nombres de objetos ya has usado con la función ls: ls() ## &quot;a&quot; &quot;dado&quot; &quot;my_number&quot; &quot;nombre&quot; &quot;Nombre&quot; También puede ver qué nombres ha utilizado examinando el panel de environment de RStudio. Ahora tiene un dado virtual que está almacenado en la memoria de su computadora. Puedes acceder a él cuando quieras escribiendo la palabra dado. Entonces, ¿qué puedes hacer con este dado? Bastante. R reemplazará un objeto con su contenido siempre que el nombre del objeto aparezca en un comando. Entonces, por ejemplo, puedes hacer todo tipo de operaciones matemáticas con el dado. Las matemáticas no son tan útiles para lanzar dados, pero la manipulación de conjuntos de números será su día a día como científico de datos. Así que echemos un vistazo a cómo hacer eso: dado - 1 ## 0 1 2 3 4 5 dado / 2 ## 0.5 1.0 1.5 2.0 2.5 3.0 dado * dado ## 1 4 9 16 25 36 Si eres un gran fanático del álgebra lineal (¿y quién no lo es?), puedes notar que R no siempre sigue las reglas de la multiplicación de matrices. En su lugar, R utiliza ejecución por elementos. Cuando manipulas un conjunto de números, R aplicará la misma operación a cada elemento del conjunto. Entonces, por ejemplo, cuando ejecuta dado - 1, R resta uno de cada elemento de dado. Cuando usa dos o más vectores en una operación, R alineará los vectores y realizará una secuencia de operaciones individuales. Por ejemplo, cuando ejecuta dado * dado, R alinea los dos vectores dado y luego multiplica el primer elemento del vector 1 por el primer elemento del vector 2. R luego multiplica el segundo elemento del vector 1 por el segundo elemento del vector 2, y así sucesivamente, hasta que se hayan multiplicado todos los elementos. El resultado será un nuevo vector de la misma longitud que los dos primeros, como se muestra en la Figura 2.3. Figure 2.3: Cuando R realiza una ejecución por elementos, hace coincidir los vectores y luego manipula cada par de elementos de forma independiente. Si le da a R dos vectores de longitudes desiguales, R repetirá el vector más corto hasta que sea tan largo como el vector más largo y luego hará los cálculos, como se muestra en la Figura 2.4. Este no es un cambio permanente: el vector más corto tendrá su tamaño original después de que R haga los cálculos. Si la longitud del vector largo no es divisible equitativamente por el vctor corto, R devolverá un mensaje de advertencia. Este comportamiento se conoce como reciclado de vectores y ayuda a R a realizar operaciones por elementos: 1:2 ## 1 2 1:4 ## 1 2 3 4 dado ## 1 2 3 4 5 6 dado + 1:2 ## 2 4 4 6 6 8 dado + 1:4 ## 2 4 6 8 6 8 Warning message: In dado + 1:4 : longer object length is not a multiple of shorter object length Figure 2.4: R repetirá un vector corto para realizar operaciones por elementos con dos vectores de longitud desigual. Las operaciones basadas en elementos son una característica muy útil en R porque manipulan grupos de valores de forma ordenada. Cuando comience a trabajar con conjuntos de datos, las operaciones por elementos garantizarán que los valores de una observación o caso solo se emparejen con valores de la misma observación o caso. Las operaciones basadas en elementos también facilitan la escritura de sus propios programas y funciones en R. Pero no creas que R ha renunciado a la multiplicación de matrices tradicional. Solo tienes que pedirlo cuando quieras. Puedes hacer multiplicaciones internas con el operador %*% y multiplicaciones externas con el operador %o%: dado %*% dado ## 91 dado %o% dado ## [,1] [,2] [,3] [,4] [,5] [,6] ## [1,] 1 2 3 4 5 6 ## [2,] 2 4 6 8 10 12 ## [3,] 3 6 9 12 15 18 ## [4,] 4 8 12 16 20 24 ## [5,] 5 10 15 20 25 30 ## [6,] 6 12 18 24 30 36 También puedes hacer cosas como transponer una matriz con t y tomar su determinante con det. No se preocupe si no está familiarizado con estas operaciones. Son fáciles de buscar y no los necesitará para este libro. Ahora que puede hacer operaciones matemáticas con su objeto dado, veamos cómo podría “tirarlo”. Lanzar el dado requerirá algo más sofisticado que la aritmética básica; deberá seleccionar aleatoriamente uno de los valores del dado. Y para eso, necesitarás una función. 2.3 Funciones R viene con muchas funciones que puede usar para realizar tareas sofisticadas como el muestreo aleatorio. Por ejemplo, puede redondear un número con la función round o calcular su factorial con la función factorial. Usar una función es bastante simple. Simplemente escriba el nombre de la función y luego los datos sobre los que desea que opere la función entre paréntesis:: round(3.1415) ## 3 factorial(3) ## 6 Los datos que pasa a la función se denominan argumento de la función. El argumento puede ser datos sin procesar, un objeto R o incluso los resultados de otra función R. En este último caso, R trabajará desde la función más interna hacia la más externa, como en la Figura 2.5. mean(1:6) ## 3.5 mean(dado) ## 3.5 round(mean(dado)) ## 4 Figure 2.5: Cuando vincula funciones, R las resolverá desde la operación más interna hasta la más externa. Aquí R primero busca el dado, luego calcula la media de uno a seis y luego redondea la media. Por suerte para nosotros, hay una función R que puede ayudar a “tirar” el dado. Puede simular una tirada del dado con la función sample de R. sample toma dos argumentos: un vector llamado x y un número llamado size. sample devolverá elementos de size del vector: sample(x = 1:4, size = 2) ## 3 2 Para tirar el dado y obtener un número de vuelta, establezca x en dado y muestree un elemento de él. Obtendrá un número nuevo (quizás diferente) cada vez que lo haga rodar: sample(x = dado, size = 1) ## 2 sample(x = dado, size = 1) ## 1 sample(x = dado, size = 1) ## 6 Muchas funciones de R toman múltiples argumentos que las ayudan a hacer su trabajo. Puede dar a una función tantos argumentos como desee siempre que separe cada argumento con una coma. Es posible que hayas notado que establecí dado y 1 iguales a los nombres de los argumentos en sample, x y size. Cada argumento en cada función de R tiene un nombre. Puede especificar qué datos deben asignarse a qué argumento estableciendo un nombre igual a data, como en el código anterior. Esto se vuelve importante a medida que comienza a pasar múltiples argumentos a la misma función; los nombres lo ayudan a evitar pasar los datos incorrectos al argumento incorrecto. Sin embargo, el uso de nombres es opcional. Notará que los usuarios de R no suelen usar el nombre del primer argumento en una función. Por lo tanto, es posible que vea el código anterior escrito como: sample(dado, size = 1) ## 2 A menudo, el nombre del primer argumento no es muy descriptivo y, de todos modos, suele ser obvio a qué se refiere el primer dato. Pero, ¿cómo saber qué nombres de argumento usar? Si intenta usar un nombre que una función no espera, es probable que obtenga un error: round(3.1415, corners = 2) ## Error in round(3.1415, corners = 2) : unused argument(s) (corners = 2) Si no está seguro de qué nombres usar con una función, puede buscar los argumentos de la función con args. Para hacer esto, coloque el nombre de la función entre paréntesis detrás de args. Por ejemplo, puede ver que la función round toma dos argumentos, uno llamado x y otro llamado digits: args(round) ## function (x, digits = 0) ## NULL ¿Notaste que args muestra que el argumento digits de round ya está establecido en 0? Con frecuencia, una función R tomará argumentos opcionales como digits. Estos argumentos se consideran opcionales porque vienen con un valor predeterminado. Puede pasar un nuevo valor a un argumento opcional si así lo desea, y R utilizará el valor predeterminado si no proporciona uno nuevo. Por ejemplo, “round” redondeará su número a 0 dígitos más allá del punto decimal de forma predeterminada. Para anular el valor predeterminado, proporcione su propio valor para digits: round(3.1415) ## 3 round(3.1415, digits = 2) ## 3.14 Debe escribir los nombres de cada argumento después del primero o dos cuando llame a una función con múltiples argumentos. ¿Por qué? Primero, esto lo ayudará a usted y a otros a comprender su código. Por lo general, es obvio a qué argumento se refiere su primera entrada (y, a veces, también la segunda entrada). Sin embargo, necesitaría una memoria grande para recordar los argumentos tercero y cuarto de cada función R. En segundo lugar, y más importante, escribir los nombres de los argumentos evita errores. Si no escribe los nombres de sus argumentos, R hará coincidir sus valores con los argumentos de su función por orden. Por ejemplo, en el siguiente código, el primer valor, dado, coincidirá con el primer argumento de sample, que se llama x. El siguiente valor, 1, coincidirá con el siguiente argumento, size: sample(dado, 1) ## 2 A medida que proporciona más argumentos, es más probable que su orden y el orden de R no coincidan. Como resultado, los valores pueden pasarse al argumento incorrecto. Los nombres de los argumentos evitan esto. R siempre hará coincidir un valor con el nombre de su argumento, sin importar dónde aparezca en el orden de los argumentos: sample(size = 1, x = dado) ## 2 2.3.1 Muestra con reemplazo Si configura size = 2, puede casi simular un par de dados. Antes de ejecutar ese código, piense por un minuto por qué ese podría ser el caso. sample devolverá dos números, uno para cada dado: sample(dado, size = 2) ## 3 4 Dije que esto “casi” funciona porque este método hace algo divertido. Si lo usa muchas veces, notará que el segundo dado nunca tiene el mismo valor que el primero, lo que significa que nunca obtendrá algo como un par de tres o un par de unos. ¿Qué esta pasando? Por defecto, sample construye una muestra sin reemplazo. Para ver lo que esto significa, imagina que sample coloca todos los valores de dado en un frasco o urna. Luego imagine que sample alcanza el frasco y extrae valores uno por uno para construir su muestra. Una vez que se ha extraído un valor del frasco, sample lo deja a un lado. El valor no vuelve al frasco, por lo que no se puede volver a extraer. Entonces, si sample selecciona un seis en su primer sorteo, no podrá seleccionar un seis en el segundo sorteo; seis ya no está en el frasco para ser seleccionado. Aunque sample crea su muestra electrónicamente, sigue este comportamiento aparentemente físico. Un efecto secundario de este comportamiento es que cada sorteo depende de los sorteos anteriores. Sin embargo, en el mundo real, cuando lanzas un par de dados, cada dado es independiente del otro. Si el primer dado sale seis, no impide que el segundo dado salga seis. De hecho, no influye en el segundo dado de ninguna manera. Puede recrear este comportamiento en sample agregando el argumento replace = TRUE: sample(dado, size = 2, replace = TRUE) ## 5 5 El argumento replace = TRUE hace que sample muestree con reemplazo. Nuestro ejemplo de frasco proporciona una buena manera de comprender la diferencia entre el muestreo con reemplazo y sin reemplazo. Cuando sample usa reemplazo, extrae un valor del frasco y registra el valor. Luego vuelve a poner el valor en el frasco. En otras palabras, sample reemplaza cada valor después de cada sorteo. Como resultado, sample puede seleccionar el mismo valor en el segundo sorteo. Cada valor tiene la posibilidad de ser seleccionado cada vez. Es como si cada sorteo fuera el primer sorteo. El muestreo con reemplazo es una manera fácil de crear muestras aleatorias independientes. Cada valor en su muestra será una muestra de tamaño uno que es independiente de los otros valores. Esta es la forma correcta de simular un par de dados. sample(dado, size = 2, replace = TRUE) ## 2 4 Felicítate a ti mismo; ¡Acabas de ejecutar tu primera simulación en R! Ahora tiene un método para simular el resultado de lanzar un par de dados. Si desea sumar los dados, puede ingresar su resultado directamente en la función sum: dados &lt;- sample(dado, size = 2, replace = TRUE) dados ## 2 4 sum(dados) ## 6 ¿Qué pasaría si llamas dados varias veces? ¿Generaría R un nuevo par de valores de dados cada vez? Probemos: dados ## 2 4 dados ## 2 4 dados ## 2 4 No. Cada vez que llame a dados, R le mostrará el resultado de esa vez que llamó a sample y guardó la salida en dados. R no volverá a ejecutar sample(dado, 2, replace = TRUE) para crear una nueva tirada de dados. Esto es un alivio en cierto modo. Una vez que guarda un conjunto de resultados en un objeto de R, esos resultados no cambian. La programación sería bastante difícil si los valores de sus objetos cambiaran cada vez que los llama. Sin embargo, sería conveniente tener un objeto que pueda volver a tirar los dados cada vez que lo llames. Puede hacer tal objeto escribiendo su propia función de R. 2.4 Escribiendo Sus Propias Funciones Para recapitular, ya tiene un código de R en funcionamiento que simula lanzar un par de dados: dado &lt;- 1:6 dados &lt;- sample(dado, size = 2, replace = TRUE) sum(dados) Puede volver a escribir este código en la consola en cualquier momento que desee volver a tirar los dados. Sin embargo, esta es una forma incómoda de trabajar con el código. Sería más fácil usar su código si lo envolviera en su propia función, que es exactamente lo que haremos ahora. Vamos a escribir una función llamada tirar que puedes usar para lanzar tus dados virtuales. Cuando hayas terminado, la función funcionará así: cada vez que llames a tirar(), R devolverá la suma de tirar dos dados: tirar() ## 8 tirar() ## 3 tirar() ## 7 Las funciones pueden parecer misteriosas o sofisticadas, pero son solo otro tipo de objeto de R. En lugar de contener datos, contienen código. Este código se almacena en un formato especial que facilita su reutilización en situaciones nuevas. Puede escribir sus propias funciones recreando este formato. 2.4.1 El Constructor de Funciones Cada función en R tiene tres partes básicas: un nombre, un cuerpo de código y un conjunto de argumentos. Para crear su propia función, debe replicar estas partes y almacenarlas en un objeto de R, esto lo puede hacer con la función function. Para hacer esto, llama a function() y sigue con un par de llaves, {}: mi_funcion &lt;- function() {} function construirá una función a partir de cualquier código R que coloque entre las llaves. Por ejemplo, puede convertir su código de dados en una función llamando: tirar &lt;- function() { dado &lt;- 1:6 dados &lt;- sample(dado, size = 2, replace = TRUE) sum(dados) } Observe que he aplicado sangría a cada línea de código entre las llaves. Esto hace que el código sea más fácil de leer para usted y para mí, pero no tiene impacto en cómo se ejecuta el código. R ignora los espacios y los saltos de línea y ejecuta una expresión completa a la vez. Simplemente presione la tecla Enter entre cada línea después de la primera llave, {. R esperará a que escribas la última llave, }, antes de responder. No olvide guardar la salida de function en un objeto de R. Este objeto se convertirá en su nueva función. Para usarlo, escriba el nombre del objeto seguido de un paréntesis de apertura y cierre: tirar() ## 9 Puede pensar en los paréntesis como el “disparador” que hace que R ejecute la función. Si escribe el nombre de una función sin los paréntesis, R le mostrará el código que está almacenado dentro de la función. Si escribe el nombre con los paréntesis, R ejecutará ese código: tirar ## function() { ## dado &lt;- 1:6 ## dados &lt;- sample(dado, size = 2, replace = TRUE) ## sum(dados) ## } tirar() ## 6 El código que coloca dentro de su función se conoce como el cuerpo de la función. Cuando ejecuta una función en R, R ejecutará todo el código en el cuerpo y luego devolverá el resultado de la última línea de código. Si la última línea de código no devuelve un valor, tampoco lo hará su función, por lo que debe asegurarse de que su última línea de código devuelva un valor. Una forma de verificar esto es pensar en lo que sucedería si ejecutara el cuerpo del código línea por línea en la consola. ¿Mostraría R un resultado después de la última línea, o no? Aquí hay un código que mostraría un resultado: dados 1 + 1 sqrt(2) Y aquí hay un código que no: dados &lt;- sample(dado, size = 2, replace = TRUE) dos &lt;- 1 + 1 a &lt;- sqrt(2) ¿Notas el patrón? Estas líneas de código no devuelven un valor a la línea de comando; guardan un valor a un objeto. 2.5 Argumentos ¿Qué pasa si eliminamos una línea de código de nuestra función y cambiamos el nombre dado a bones, así? tirar2 &lt;- function() { dados &lt;- sample(bones, size = 2, replace = TRUE) sum(dados) } Ahora obtendré un error cuando ejecute la función. La función necesita el objeto bones para hacer su trabajo, pero no se puede encontrar ningún objeto llamado bones: tirar2() ## Error in sample(bones, size = 2, replace = TRUE) : ## object &#39;bones&#39; not found Puedes proporcionar bones cuando llamas a tirar2 si conviertes a bones en un argumento de la función. Para hacer esto, pon el nombre bones entre los paréntesis que siguen a function cuando definas tirar2: tirar2 &lt;- function(bones) { dados &lt;- sample(bones, size = 2, replace = TRUE) sum(dados) } Ahora tirar2 funcionará siempre y cuando proporciones bones cuando llames a la función. Puede aprovechar esto para lanzar diferentes tipos de dados cada vez que llamas tirar2. ¡Calabozos y Dragones, aquí vamos! Recuerda, estamos lanzando pares de dados: tirar2(bones = 1:4) ## 3 tirar2(bones = 1:6) ## 10 tirar2(1:20) ## 31 Tenga en cuenta que tirar2 seguirá dando un error si no proporciona un valor para el argumento bones cuando llame a tirar2: tirar2() ## Error in sample(bones, size = 2, replace = TRUE) : ## argument &quot;bones&quot; is missing, with no default Puede evitar este error dando al argumento bones un valor predeterminado. Para hacer esto, establece bones igual a un valor cuando definas tirar2: tirar2 &lt;- function(bones = 1:6) { dados &lt;- sample(bones, size = 2, replace = TRUE) sum(dados) } Ahora puede proporcionar un nuevo valor para bones si lo desea, y tirar2 usará el valor predeterminado si no lo desea: tirar2() ## 9 Puede dar a sus funciones tantos argumentos como desee. Simplemente enumere sus nombres, separados por comas, entre los paréntesis que siguen a function.Cuando se ejecuta la función, R reemplazará cada nombre de argumento en el cuerpo de la función con el valor que el usuario proporciona para el argumento. Si el usuario no proporciona un valor, R reemplazará el nombre del argumento con el valor predeterminado del argumento (si definió uno). Para resumir, function te ayuda a construir tus propias funciones de R. Usted crea un cuerpo de código para que su función se ejecute escribiendo código entre las llaves que siguen a function. Usted crea argumentos para que su función los use proporcionando sus nombres entre los paréntesis que siguen a function. Finalmente, le da un nombre a su función guardando su salida en un objeto de R, como se muestra en la Figura 2.6. Una vez que haya creado su función, R la tratará como cualquier otra función en R. Piense en lo útil que es. ¿Alguna vez ha intentado crear una nueva opción de Excel y agregarla a la barra de menú de Microsoft? ¿O una nueva animación de diapositivas y agregarla a las opciones de Powerpoint? Cuando trabajas con un lenguaje de programación, puedes hacer este tipo de cosas. A medida que aprenda a programar en R, podrá crear herramientas nuevas, personalizadas y reproducibles para usted cuando lo desee. Proyecto 3: Máquina Tragamonedas te enseñará mucho más sobre escribir funciones en R. Figure 2.6: Cada función en R tiene las mismas partes y puede usar function para crear estas partes. Asigne el resultado a un nombre, para que pueda llamar a la función más tarde. 2.6 Scripts ¿Qué pasa si quieres editar tirar2 de nuevo? Podría regresar y volver a escribir cada línea de código en tirar2, pero sería mucho más fácil si tuviera un borrador del código para empezar. Puede crear un borrador de su código a medida que avanza utilizando un script de R. Un script de R es solo un archivo de texto sin formato en el que guarda el código R. Puede abrir un script de R en RStudio yendo a File&gt; New File&gt; R script en la barra de menú. RStudio luego abrirá un script nuevo sobre el panel de su consola, como se muestra en la Figura 2.7. Le recomiendo encarecidamente que escriba y edite todo su código de R en un script antes de ejecutarlo en la consola. ¿Por qué? Este hábito crea un registro reproducible de su trabajo. Cuando termine el día, puede guardar su secuencia de comandos y luego usarla para volver a ejecutar todo el análisis al día siguiente. Los scripts también son muy útiles para editar y corregir su código, y hacen una buena copia de su trabajo para compartir con otros. Para guardar un script, haga clic en el panel de scripts y luego vaya a File &gt; Save as en la barra de menú. Figure 2.7: Cuando abre un R Script (File &gt; New File &gt; R Script in the menu bar), RStudio crea un cuarto panel encima de la consola donde puede escribir y editar su código. RStudio viene con muchas funciones integradas que facilitan el trabajo con scripts. Primero, puede ejecutar automáticamente una línea de código en un script haciendo clic en el botón Run, como se muestra en la Figura 2.8. R ejecutará cualquier línea de código en la que esté el cursor. Si tiene una sección completa resaltada, R ejecutará el código resaltado. Como alternativa, puede ejecutar todo el script haciendo clic en el botón Source. ¿No te gusta hacer clic en los botones? Puede usar Control + Enter como acceso directo para el botón Ejecutar. En Mac, eso sería Comando + Enter. Figure 2.8: Puede ejecutar una parte resaltada del código en su secuencia de comandos si hace clic en el botón Run en la parte superior del panel de Scripts. Puede ejecutar todo el script haciendo clic en el botón Source. Si no está convencido acerca de los scripts, pronto lo estará. Se convierte en una molestia escribir código de varias líneas en la línea de comando de una sola línea de la consola. Evitemos ese dolor de cabeza y abramos su primer script ahora antes de pasar al siguiente capítulo. Extraer función RStudio viene con una herramienta que puede ayudarlo a crear funciones. Para usarlo, resalte las líneas de código en su secuencia de comandos R que desea convertir en una función. Luego haga clic en Code &gt; Extract Function en la barra de menú. RStudio le pedirá un nombre de función para usar y luego envolverá su código en una llamada de function. Escaneará el código en busca de variables indefinidas y las usará como argumentos. Es posible que desee volver a comprobar el trabajo de RStudio. Asume que su código es correcto, por lo que si hace algo sorprendente, es posible que tenga un problema en su código. 2.7 Resumen Ya has cubierto mucho terreno. Ahora tiene un dado virtual almacenado en la memoria de su computadora, así como su propia función de R que lanza un par de dados. También ha comenzado a hablar el lenguaje R. Como has visto, R es un lenguaje que puedes usar para hablar con tu computadora. Escribes comandos en R y los ejecutas en la línea de comandos para que tu computadora los lea. Su computadora a veces responderá–por ejemplo, cuando cometa un error–pero generalmente solo hace lo que le pide y luego muestra el resultado. Los dos componentes más importantes del lenguaje R son los objetos, que almacenan datos, y las funciones, que manipulan datos. R también usa una gran cantidad de operadores como +, -, *, / y &lt;- para realizar tareas básicas. Como científico de datos, usará objetos de R para almacenar datos en la memoria de su computadora y usará funciones para automatizar tareas y realizar cálculos complicados. Examinaremos los objetos con más profundidad más adelante en Proyecto 2: Baraja de Cartas y profundizaremos en las funciones en [Proyecto 3: Máquina Tragamonedas]. El vocabulario que ha desarrollado aquí hará que cada uno de esos proyectos sea más fácil de entender. Sin embargo, aún no hemos terminado con tus dados. En Paquetes y páginas de ayuda, , ejecutará algunas simulaciones con sus dados y construirá sus primeros gráficos en R. También verá dos de los componentes más útiles del lenguaje R: Paquetes de R, que son colecciones de funciones escritas por la talentosa comunidad de desarrolladores de R, y documentación de R, que es una colección de páginas de ayuda integradas en R que explica cada función y conjunto de datos en el lenguaje. "],["packages.html", "3 Paquetes y páginas de ayuda 3.1 Paquetes 3.2 Obteniendo Ayuda con las Páginas de Ayuda 3.3 Resumen 3.4 Resumen del Proyecto 1", " 3 Paquetes y páginas de ayuda Ahora tiene una función que simula lanzar un par de dados. Hagamos las cosas un poco más interesantes ponderando los dados a tu favor. La casa siempre gana, ¿verdad? Hagamos que los dados arrojen números altos un poco más a menudo que los números bajos. Antes de ponderar los dados, debemos asegurarnos de que sean justos para empezar. Dos herramientas te ayudarán a hacer esto: repetición y visualización. Por coincidencia, estas herramientas también son dos de los superpoderes más útiles en el mundo de la ciencia de datos. Repetiremos nuestras tiradas de dados con una función llamada replicate y visualizaremos nuestras tiradas con una función llamada qplot. qplot no viene con R cuando lo descargas; qplot viene en un paquete de R independiente. Muchas de las herramientas de R más útiles vienen en paquetes de R, así que tomemos un momento para ver qué son los paquetes de R y cómo puede usarlos. 3.1 Paquetes No es la única persona que escribe sus propias funciones con R. Muchos profesores, programadores y estadísticos usan R para diseñar herramientas que pueden ayudar a las personas a analizar datos. Luego hacen que estas herramientas sean gratuitas para que cualquiera las use. Para usar estas herramientas, solo tienes que descargarlas. Vienen como colecciones preensambladas de funciones y objetos llamados paquetes. Apéndice 2: Paquetes de R contiene instrucciones detalladas para descargar y actualizar paquetes R, pero aquí veremos los conceptos básicos. Vamos a usar la función qplot para hacer algunos gráficos rápidos. qplot viene en el paquete ggplot2, un paquete popular para hacer gráficos. Antes de que pueda usar qplot, o cualquier otra cosa en el paquete ggplot2, debe descargarlo e instalarlo. 3.1.1 install.packages Cada paquete R está alojado en http://cran.r-project.org, el mismo sitio web que aloja R. Sin embargo, no necesita visitar el sitio web para descargar un paquete R; puede descargar paquetes directamente desde la línea de comandos de R. Así es cómo: Abre RStudio. Asegúrate de estar conectado a Internet. Ejecute install.packages(\"ggplot2\") en la línea de comando. Eso es. R hará que su computadora visite el sitio web, descargue ggplot2 e instale el paquete en su disco duro justo donde R quiere encontrarlo. Ahora tiene el paquete ggplot2. Si desea instalar otro paquete, reemplace ggplot2 con el nombre de su paquete en el código. 3.1.2 library La instalación de un paquete no pone sus funciones al alcance de su mano todavía: simplemente las coloca en su disco duro. Para usar un paquete de R, luego debe cargarlo en su sesión de R con el comando library(\"ggplot2\"). Si desea cargar un paquete diferente, reemplace ggplot2 con el nombre de su paquete en el código. Para ver lo que esto hace, intente un experimento. Primero, pide a R que te muestre la función qplot. R no podrá encontrar qplot porque qplot vive en el paquete ggplot2, que no ha cargado: qplot ## Error: object &#39;qplot&#39; not found Ahora cargue el paquete ggplot2: library(&quot;ggplot2&quot;) Si instaló el paquete con install.packages según las instrucciones, todo debería ir bien. No se preocupe si no ve ningún resultado o mensaje. No tener noticias es una buena noticia a la hora de cargar un paquete. No se preocupe si ve un mensaje tampoco; ggplot2 a veces muestra mensajes de inicio útiles. Mientras no vea nada que diga “Error”, lo está haciendo bien. Ahora, si pide ver qplot, R le mostrará bastante código (qplot es una función larga): qplot ## (quite a bit of code) Apéndice 2: Paquetes de R contiene muchos más detalles sobre la adquisición y el uso de paquetes. Le recomiendo que lo lea si no está familiarizado con el sistema de paquetes de R. Lo más importante que debe recordar es que solo necesita instalar un paquete una vez, pero debe cargarlo con library cada vez que desee usarlo en una nueva sesión de R. R descargará todos sus paquetes cada vez que cierre RStudio. Ahora que ha cargado qplot, vamos a probarlo. qplot hace “gráficos rápidos”. Si le das a qplot dos vectores de igual longitud, qplot dibujará un diagrama de dispersión por ti. qplot usará el primer vector como un conjunto de valores x y el segundo vector como un conjunto de valores y. Busque el gráfico que aparecerá en la pestaña Gráficos del panel inferior derecho de la ventana de RStudio. El siguiente código creará el gráfico que aparece en la Figura 3.1. Hasta ahora, hemos estado creando secuencias de números con el operador :; pero también puedes crear vectores de números con la función c. Proporcione a c todos los números que desea que aparezcan en el vector, separados por una coma. c significa concatenar, pero puedes pensar en ello como “recolectar” o “combinar”: x &lt;- c(-1, -0.8, -0.6, -0.4, -0.2, 0, 0.2, 0.4, 0.6, 0.8, 1) x ## -1.0 -0.8 -0.6 -0.4 -0.2 0.0 0.2 0.4 0.6 0.8 1.0 y &lt;- x^3 y ## -1.000 -0.512 -0.216 -0.064 -0.008 0.000 0.008 ## 0.064 0.216 0.512 1.000 qplot(x, y) Figure 3.1: qplot hace un diagrama de dispersión cuando le das dos vectores. No necesitas nombrar tus vectores x e y. Solo hice eso para aclarar el ejemplo. Como puede ver en la figura 3.1, un diagrama de dispersión es un conjunto de puntos, cada uno representado de acuerdo con sus valores x e y. Juntos, los vectores x e y describen un conjunto de 10 puntos. ¿Cómo hizo coincidir R los valores en x e y para hacer estos puntos? Con ejecución por elementos, como vimos en la Figura 2.3. Los diagramas de dispersión son útiles para visualizar la relación entre dos variables. Sin embargo, vamos a utilizar un tipo diferente de gráfico, un histograma. Un histograma visualiza la distribución de una sola variable; muestra cuántos puntos de datos aparecen en cada valor de x. Echemos un vistazo a un histograma para ver si esto tiene sentido. qplot hará un histograma cada vez que le des solo un vector para graficar. El siguiente código crea el gráfico de la izquierda en la Figura 3.2 (nos preocuparemos del gráfico de la derecha en un segundo). Para asegurarse de que nuestros gráficos tengan el mismo aspecto, utilice el argumento extra binwidth = 1: x &lt;- c(1, 2, 2, 2, 3, 3) qplot(x, binwidth = 1) Figure 3.2: qplot hace un histograma cuando le das un solo vector. Este gráfico muestra que nuestro vector contiene un valor en el intervalo [1, 2) colocando una barra de altura 1 sobre ese intervalo. De manera similar, la gráfica muestra que el vector contiene tres valores en el intervalo [2, 3) colocando una barra de altura 3 en ese intervalo. Muestra que el vector contiene dos valores en el intervalo [3, 4) colocando una barra de altura 2 en ese intervalo. En estos intervalos, el corchete, [, significa que el primer número está incluido en el intervalo. El paréntesis, ), significa que el último número no está incluido. Probemos con otro histograma. Este código crea el gráfico de la derecha en la Figura 3.2. Observe que hay cinco puntos con un valor de 1 en x2. El histograma muestra esto trazando una barra de altura 5 sobre el intervalo x2 = [1, 2): x2 &lt;- c(1, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 4) qplot(x2, binwidth = 1) Ejercicio 3.1 (Visualizar un Histograma) Sea x3 el siguiente vector: x3 &lt;- c(0, 1, 1, 2, 2, 2, 3, 3, 4) Imagina cómo se vería un histograma de x3. Suponga que el histograma tiene un ancho de intervalo de 1. ¿Cuántas barras tendrá el histograma? ¿Dónde aparecerán? ¿Qué altura tendrá cada uno? Cuando haya terminado, trace un histograma de x3 con binwidth = 1, y vea si tiene razón. Solution. Puedes hacer un histograma de x3 con qplot(x3, binwidth = 1). El histograma se verá como una pirámide simétrica. La barra del medio tendrá una altura de 3 y aparecerá encima de [2, 3), pero asegúrese de probarlo y verlo por sí mismo. Puede usar un histograma para mostrar visualmente qué tan comunes son los diferentes valores de x. Los números cubiertos por una barra alta son más comunes que los números cubiertos por una barra corta. ¿Cómo puedes usar un histograma para verificar la precisión de tus dados? Bueno, si tiras los dados muchas veces y haces un seguimiento de los resultados, esperarás que algunos números ocurran más que otros. Esto se debe a que hay más formas de obtener algunos números sumando dos dados que de obtener otros números, como se muestra en la Figura 3.3. Si tira los dados muchas veces y grafica los resultados con qplot, el histograma le mostrará con qué frecuencia apareció cada suma. Las sumas que ocurrieron con mayor frecuencia tendrán las barras más altas. El histograma debería parecerse al patrón de la Figura 3.3 si los dados tienen un peso justo. Aquí es donde entra replicate. replicate proporciona una manera fácil de repetir un comando de R muchas veces. Para usarlo, primero dale a replicate el número de veces que deseas repetir un comando de R, y luego dale el comando que deseas repetir. replicate ejecutará el comando varias veces y almacenará los resultados como un vector: replicate(3, 1 + 1) ## 2 2 2 replicate(10, tirar()) ## 3 7 5 3 6 2 3 8 11 7 Figure 3.3: Cada combinación individual de dados debe ocurrir con la misma frecuencia. Como resultado, algunas sumas ocurrirán con más frecuencia que otras. Con dados justos, cada suma debe aparecer en proporción al número de combinaciones que la forman. Un histograma de sus las primeras 10 tiradas de los dados probablemente no se verá como el patrón que se muestra en la Figura 3.3. ¿Por qué no? Hay demasiada aleatoriedad involucrada. Recuerda que usamos dados en la vida real porque son generadores efectivos de números aleatorios. Los patrones de frecuencias de largo plazo solo aparecerán en el largo plazo. Así que simulemos 10.000 lanzamientos de dados y representemos los resultados. No te preocupes; qplot y replicate pueden manejarlo. Los resultados aparecen en la Figura 3.4: lanzamientos &lt;- replicate(10000, tirar()) qplot(lanzamientos, binwidth = 1) Los resultados sugieren que los dados son justos. A la larga, cada número aparece en proporción al número de combinaciones que lo generan. Ahora, ¿cómo puedes sesgar estos resultados? El patrón anterior ocurre porque cada combinación subyacente de dados (por ejemplo, (3,4)) ocurre con la misma frecuencia. Si pudieras aumentar la probabilidad de que salga un 6 en cualquiera de los dados, entonces cualquier combinación con un seis ocurrirá con más frecuencia que cualquier combinación sin un seis. La combinación (6, 6) ocurriría más frequente que todas las demás. Esto no hará que los dados sumen 12 con más frecuencia que siete, pero sesgará los resultados hacia los números más altos Figure 3.4: El comportamiento de nuestros dados sugiere que son justos. Siete ocurre con más frecuencia que cualquier otro número, y las frecuencias disminuyen en proporción al número de combinaciones de dados que crean cada número. Para decirlo de otra manera, la probabilidad de sacar cualquier número en un dado justo es 1/6. Me gustaría que cambiara la probabilidad a 1/8 para cada número por debajo de seis y luego aumentara la probabilidad de sacar un seis a 3/8: Número Probabilidad justa Probabilidad sesgada 1 1/6 1/8 2 1/6 1/8 3 1/6 1/8 4 1/6 1/8 5 1/6 1/8 6 1/6 3/8 Puede cambiar las probabilidades agregando un nuevo argumento a la función sample. No te voy a decir cuál es el argumento; en su lugar, le indicaré la página de ayuda para la función sample. ¿Que es eso? ¿Las funciones de R vienen con páginas de ayuda? Sí, así que aprendamos a leer una. 3.2 Obteniendo Ayuda con las Páginas de Ayuda Hay más de 1000 funciones en el núcleo de R, y se crean nuevas funciones todo el tiempo. ¡Esto puede ser mucho material para memorizar y aprender! Afortunadamente, cada función de R viene con su propia página de ayuda, a la que puede acceder escribiendo el nombre de la función después de un signo de interrogación. Por ejemplo, cada uno de estos comandos abrirá una página de ayuda. Busque las páginas que aparecerán en la pestaña Ayuda del panel inferior derecho de RStudio: ?sqrt ?log10 ?sample Las páginas de ayuda contienen información útil sobre lo que hace cada función. Estas páginas de ayuda también sirven como documentación del código, por lo que leerlas puede resultar agridulce. A menudo parecen estar escritas para personas que ya entienden la función y no necesitan ayuda. No deje que esto le moleste: puede obtener mucho de una página de ayuda si la escanea buscando información que tenga sentido y pasa por alto el resto. Esta técnica inevitablemente lo llevará a la parte más útil de cada página de ayuda: la parte inferior. Aquí, casi todas las páginas de ayuda incluyen algún código de ejemplo que pone la función en acción. Ejecutar este código es una excelente manera de aprender con el ejemplo. Si una función viene en un paquete R, R no podrá encontrar su página de ayuda a menos que se cargue el paquete. 3.2.1 Partes de una Página de Ayuda Cada página de ayuda está dividida en secciones. Las secciones que aparecen pueden variar de una página de ayuda a otra, pero normalmente puede esperar encontrar estos temas útiles Descripción - Un breve resumen de lo que hace la función. Uso - Un ejemplo de cómo escribiría la función. Cada argumento de la función aparecerá en el orden en que R espera que lo proporciones (si no usas nombres de argumentos). Argumentos - Una lista de cada argumento que toma la función, qué tipo de información R espera que proporcione para el argumento y qué hará la función con la información. Detalles - Una descripción más detallada de la función y cómo opera. La sección de detalles también le da al autor de la función la oportunidad de alertarlo sobre cualquier cosa que desee saber al usar la función. Valor - Una descripción de lo que devuelve la función cuando la ejecuta. Vea También - Una breve lista de funciones de R relacionadas. Ejemplos - Código de ejemplo que usa la función y se garantiza que funcionará. La sección de ejemplos de una página de ayuda generalmente demuestra un par de formas diferentes de usar una función. Esto ayuda a darle una idea de lo que la función es capaz de hacer. Si desea buscar una función en la página de ayuda pero ha olvidado el nombre de la función, puede buscar por palabra clave. Para ello, escriba dos signos de interrogación seguidos de una palabra clave en la línea de comandos de R. R mostrará una lista de enlaces a páginas de ayuda relacionadas con la palabra clave. Puede pensar en esto como la página de ayuda para la página de ayuda: ??log Demos un paseo por la página de ayuda de sample. Recuerde: estamos buscando cualquier cosa que pueda ayudarlo a cambiar las probabilidades involucradas en el proceso de muestreo. No voy a reproducir toda la página de ayuda aquí (solo las partes más jugosas), por lo que debe seguirla en su computadora. Primero, abra la página de ayuda. Aparecerá en el mismo panel en RStudio que sus gráficos (pero en la pestaña Help, no en la pestaña Plots): ?sample Como verá a continuación y en su panel Help de la ventana inferior derecha de RStudio las páginas de ayuda de R solo se encuntran en idioma inglés. Por lo que las secciones, de la página de ayuda de la función sample, que se exponen a continuación se mostrarán en inglés. Si no posee un nivel de inglés que le permita leer y entender las páginas de ayuda de R, el traductor le recomienda traducir las mismas usando algún traductor de documentos online, aunque estos pueden ser muy textuales en ocasiones. ¿Que ves? Comenzando desde arriba: Random Samples and Permutations Description sample takes a sample of the specified size from the elements of x using either with or without replacement. Hasta ahora todo bien. Ya sabías todo eso. La siguiente sección, Uso, tiene una posible pista. Menciona un argumento llamado prob: Usage sample(x, size, replace = FALSE, prob = NULL) Si se desplaza hacia abajo hasta la sección de argumentos, la descripción de +prob+ suena muy prometedora: A vector of probability weights for obtaining the elements of the vector being sampled. La sección Detalles confirma nuestras sospechas. En este caso, también te indica cómo proceder: The optional prob argument can be used to give a vector of weights for obtaining the elements of the vector being sampled. They need not sum to one, but they should be nonnegative and not all zero. Aunque la página de ayuda no lo dice aquí, estos pesos se emparejaran de manera individual con los elementos que se muestrean.El primer peso describirá el primer elemento, el segundo peso el segundo elemento, y así sucesivamente. Esta es una práctica común en R. Leer: If replace is true, Walker&#39;s alias method (Ripley, 1987) is used... Vale, parece que es hora de empezar a hojear. Deberíamos tener suficiente información ahora para descubrir cómo manipular nuestros dados. Ejercicio 3.2 (Lanzar un par de Dados) Vuelva a escribir la función tirar a continuación para lanzar un par de dados ponderados: tirar &lt;- function() { dado &lt;- 1:6 dados &lt;- sample(dado, size = 2, replace = TRUE) sum(dados) } Deberá agregar un argumento prob a la función sample dentro de tirar. Este argumento debería decirle a sample que muestree los números del uno al cinco con una probabilidad de 1/8 y el número 6 con una probabilidad de 3/8. Cuando haya terminado, siga leyendo para ver un ejemplo de respuesta. Solution. Para ponderar sus dados, debe agregar un argumento prob con un vector de pesos a sample, como este: tirar &lt;- function() { dado &lt;- 1:6 dados &lt;- sample(dado, size = 2, replace = TRUE, prob = c(1/8, 1/8, 1/8, 1/8, 1/8, 3/8)) sum(dados) } Esto hará que tirar elija del 1 al 5 con una probabilidad de 1/8 y 6 con una probabilidad de 3/8. Sobrescriba su versión anterior de tirar con la nueva función (ejecutando el fragmento de código anterior en su línea de comando). Luego visualiza el nuevo comportamiento a largo plazo de tus dados. He puesto los resultados en la Figura 3.5 junto a nuestros resultados originales: lanzamientos &lt;- replicate(10000, tirar()) qplot(lanzamientos, binwidth = 1) Esto confirma que efectivamente hemos ponderado los dados. Los números altos ocurren con mucha más frecuencia que los números bajos. Lo notable es que este comportamiento solo será evidente cuando examine las frecuencias a largo plazo. En cualquier tirada individual, los dados parecerán comportarse aleatoriamente. Esta es una gran noticia si juegas a Settlers of Catan (solo dile a tus amigos que perdiste los dados), pero debería ser perturbador si analizas los datos, porque significa que el sesgo puede ocurrir fácilmente sin que nadie lo note a corto plazo. Figure 3.5: Los dados ahora están claramente sesgados hacia números altos, ya que las sumas altas ocurren con mucha más frecuencia que las sumas bajas. 3.2.2 Obteniendo Más Ayuda R también viene con una comunidad súper activa de usuarios a la que puede acudir para obtener ayuda en la lista de correo de R-help. Puede enviar un correo electrónico a la lista con preguntas, pero existe una gran posibilidad de que su pregunta ya haya sido respondida. Descúbrelo buscando en los archivos. Incluso mejor que la lista R-help es Stack Overflow, un sitio web que permite a los programadores responder preguntas y a los usuarios clasificar las respuestas según su utilidad. Personalmente, creo que el formato Stack Overflow es más fácil de usar que la lista de correo electrónico R-help (y los encuestados son más amigables con los humanos). Puede enviar su propia pregunta o buscar a través de las preguntas respondidas anteriormente de Stack Overflow relacionadas con R. Hay más de 30,000. Lo mejor de todo es Posit Community, un lugar amigable e inclusivo para compartir preguntas relacionadas con R. Posit Community es un foro muy activo centrado en R. No se sorprenda si hace una pregunta sobre un paquete de R y el autor del paquete aparece para dar respuesta. Para toda la lista de ayuda de R, Stack Overflow y Posit Community, es más probable que obtenga una respuesta útil si proporciona un ejemplo reproducible con su pregunta. Esto significa pegar un pequeño fragmento de código que los usuarios pueden ejecutar para llegar al error o pregunta que tiene en mente. 3.3 Resumen Los paquetes y las páginas de ayuda de R pueden convertirlo en un programador más productivo. Viste en Lo Más Básico (#Básico) que R te da el poder de escribir tus propias funciones que hacen cosas específicas, pero a menudo la función que deseas escribir ya existirá en un paquete de R. Profesores, programadores y científicos han desarrollado más de 13.000 paquetes para su uso, lo que puede ahorrarle un valioso tiempo de programación. Para usar un paquete, debe instalarlo en su computadora una vez con install.packages y luego cargarlo en cada nueva sesión de R con library. Las páginas de ayuda de R lo ayudarán a dominar las funciones que aparecen en R y sus paquetes. Cada función y conjunto de datos en R tiene su propia página de ayuda. Aunque las páginas de ayuda a menudo contienen contenido avanzado, también contienen pistas y ejemplos valiosos que pueden ayudarlo a aprender a usar una función. Ya ha visto suficiente de R para aprender haciendo, que es la mejor manera de aprender R. Puede crear sus propios comandos de R, ejecutarlos y obtener ayuda cuando necesite comprender algo que no he explicado. Lo animo a que experimente con sus propias ideas en R mientras lee los próximos dos proyectos. 3.4 Resumen del Proyecto 1 Has hecho más en este proyecto que permitir el fraude y las apuestas; también aprendió a hablarle a su computadora en el idioma de R. R es un idioma como inglés, español o alemán, excepto que R lo ayuda a hablar con computadoras, no con humanos. Has conocido los sustantivos del lenguaje R, objetos. Y espero que hayas adivinado que las funciones son los verbos (supongo que los argumentos de función serían los adverbios). Cuando combinas funciones y objetos, expresas un pensamiento completo. Al unir pensamientos en una secuencia lógica, puede construir declaraciones elocuentes e incluso artísticas. En ese sentido, R no es tan diferente de cualquier otro idioma. R comparte otra característica de los lenguajes humanos: no te sentirás muy cómodo hablando R hasta que construyas un vocabulario de comandos de R para usar. Afortunadamente, no tienes que ser tímido. Tu computadora será la única que “escuchará” “hablando” R. Tu computadora no es muy indulgente, pero tampoco juzga. No es que tengas que preocuparte; ampliará enormemente su vocabulario de R entre aquí y el final del libro. Ahora que puede usar R, es hora de convertirse en un experto en el uso de R para hacer ciencia de datos. La base de la ciencia de datos es la capacidad de almacenar grandes cantidades de datos y recuperar valores a pedido. A partir de esto, sigue todo lo demás: manipulación de datos, visualización de datos, modelado de datos y más. Sin embargo, no puede almacenar fácilmente un conjunto de datos en su mente al memorizarlo. Tampoco puede almacenar fácilmente un conjunto de datos en papel escribiéndolo. La única forma eficiente de almacenar grandes cantidades de datos es con una computadora. De hecho, las computadoras son tan eficientes que su desarrollo en las últimas tres décadas ha cambiado por completo el tipo de datos que podemos acumular y los métodos que podemos usar para analizarlos. En resumen, el almacenamiento de datos informáticos ha impulsado la revolución en la ciencia que llamamos ciencia de datos. Proyecto 2: Baraja de Cartas lo hará parte de esta revolución enseñándole cómo usar R para almacenar conjuntos de datos en la memoria de su computadora y cómo recuperar y manipular datos una vez que están allí. "],["proyecto-2-baraja-de-cartas.html", "4 Proyecto 2: Baraja de Cartas", " 4 Proyecto 2: Baraja de Cartas Este proyecto, que abarca los siguientes cuatro capítulos, le enseñará cómo almacenar, recuperar y cambiar valores de datos en la memoria de su computadora. Estas habilidades lo ayudarán a guardar y administrar datos sin acumular errores. En el proyecto, diseñará una baraja de cartas que pueda barajar y repartir. Lo mejor de todo es que la baraja recordará qué cartas se han repartido, como una baraja real. Puede usar el mazo para jugar juegos de cartas, adivinar fortunas y probar estrategias de conteo de cartas. En el camino, aprenderá cómo: Guardar nuevos tipos de datos, como cadenas de caracteres y valores lógicos Guardar un conjunto de datos como vector, matriz, arreglo, lista o data frame Cargar y guardar sus propios conjuntos de datos con R Extraer valores individuales de un conjunto de datos Cambiar valores individuales dentro de un conjunto de datos Escribir pruebas lógicas Usar el símbolo de valor faltante de R, NA Para simplificar el proyecto, lo he dividido en cuatro tareas. Cada tarea le enseñará una nueva habilidad para administrar datos con R: Task 1: Construir la baraja En [Objetos de R], diseñarás y construirás una baraja virtual de naipes. Este será un conjunto de datos completo, como los que usará como científico de datos. Necesitará saber cómo usar los tipos de datos y las estructuras de datos de R para que esto funcione. Task 2: Construir funciones para repartir y barajar A continuación, en Notación de R, escribirá dos funciones para usar con la baraja. Una función repartirá cartas de la baraja y la otra volverá a barajar la baraja. Para escribir estas funciones, necesitará saber cómo extraer valores de un conjunto de datos con R. Tarea 3: Cambiar el sistema de puntos para adaptarlo a tu juego En [Modificación de valores], utilizará el sistema de notación de R para cambiar los valores de puntos de sus cartas para que coincidan con los juegos de cartas que desee jugar, como guerra, corazones o blackjack. Esto le ayudará a cambiar los valores existentes en los conjuntos de datos existentes. Tarea 4: Gestionar el estado de la baraja Finalmente, en [Entornos], te asegurarás de que tu mazo recuerde qué cartas ha repartido. Esta es una tarea avanzada y presentará el sistema de entorno de R y las reglas de alcance. Para hacerlo con éxito, deberá aprender los detalles minuciosos de cómo R busca y usa los datos que ha almacenado en su computadora. "],["objectos-de-r.html", "5 Objectos de R 5.1 Vectores Atómicos 5.2 Atributos 5.3 Matrices 5.4 Arreglos 5.5 Clases 5.6 Coerción 5.7 Listas 5.8 Data Frames 5.9 Cargando Datos 5.10 Guardando Datos 5.11 Resumen", " 5 Objectos de R En este capítulo, usará R para armar una baraja de 52 cartas. Comenzará construyendo objetos R simples que representan naipes y luego avanzará hasta una tabla de datos completa. En resumen, creará el equivalente a una hoja de cálculo de Excel desde cero. Cuando hayas terminado, tu mazo de cartas se verá así: cara palo valor rey picas 13 reina picas 12 jota picas 11 diez picas 10 nueve picas 9 ocho picas 8 ... ¿Necesita crear un conjunto de datos desde cero para usarlo en R? Para nada. Puede cargar la mayoría de los conjuntos de datos en R con un simple paso, consulte [Cargar datos]. Pero este ejercicio le enseñará cómo R almacena datos y cómo puede ensamblar, o desensamblar, sus propios conjuntos de datos. También aprenderá sobre los diversos tipos de objetos disponibles para usar en R (¡no todos los objetos de R son iguales!). Considere este ejercicio como un rito de iniciación; al hacerlo, se convertirá en un experto en el almacenamiento de datos en R. Comenzaremos con lo más básico. El tipo de objeto más simple en R es un vector atómico. Los vectores atómicos no tienen energía nuclear, pero son muy simples y aparecen en todas partes. Si observa lo suficientemente de cerca, verá que la mayoría de las estructuras en R se construyen a partir de vectores atómicos. 5.1 Vectores Atómicos Un vector atómico es solo un simple vector de datos. De hecho, ya ha creado un vector atómico, su objeto dado del Proyecto 1: Dados ponderados. Puede hacer un vector atómico agrupando algunos valores de datos con c: dado &lt;- c(1, 2, 3, 4, 5, 6) dado ## 1 2 3 4 5 6 is.vector(dado) ## TRUE is.vector is.vector comprueba si un objeto es un vector atómico. Devuelve TRUE si el objeto es un vector atómico y FALSE en caso contrario. También puedes hacer un vector atómico con un solo valor. R guarda valores individuales como un vector atómico de longitud 1: cinco &lt;- 5 cinco ## 5 is.vector(cinco) ## TRUE length(cinco) ## 1 length(dado) ## 6 length length devuelve la longitud de un vector atómico. Cada vector atómico almacena sus valores como un vector unidimensional y cada vector atómico solo puede almacenar un tipo de datos. Puede guardar diferentes tipos de datos en R utilizando diferentes tipos de vectores atómicos. En total, R reconoce seis tipos básicos de vectores atómicos: dobles, enteros, caracteres, lógicos, complejos y sin procesar. Para crear su mazo de cartas, necesitará usar diferentes tipos de vectores atómicos para guardar diferentes tipos de información (texto y números). Puede hacer esto usando algunas convenciones simples cuando ingresa sus datos. Por ejemplo, puede crear un vector de números enteros al incluir una L mayúscula con su entrada. Puede crear un vector de caracteres encerrando su entrada entre comillas: ent &lt;- 1L text &lt;- &quot;as&quot; Cada tipo de vector atómico tiene su propia convención (descrita a continuación). R reconocerá la convención y la usará para crear un vector atómico del tipo apropiado. Si desea crear vectores atómicos que tengan más de un elemento, puede combinar un elemento con la función c de Paquetes y páginas de ayuda. Use la misma convención con cada elemento: ent &lt;- c(1L, 5L) text &lt;- c(&quot;as&quot;, &quot;corazon&quot;) Quizás se pregunte por qué R usa múltiples tipos de vectores. Los tipos de vectores ayudan a que R se comporte como cabría esperar. Por ejemplo, R hará operaciones matemáticas con vectores atómicos que contienen números, pero no con vectores atómicos que contienen cadenas de caracteres: sum(ent) ## 6 sum(text) ## Error in sum(text) : invalid &#39;type&#39; (character) of argument ¡Pero nos estamos adelantando! Prepárese para saludar a los seis tipos de vectores atómicos en R. 5.1.1 Dobles Un vector doble almacena números regulares. Los números pueden ser positivos o negativos, grandes o pequeños, y tener dígitos a la derecha del lugar decimal o no. En general, R guardará cualquier número que escriba en R como un doble. Entonces, por ejemplo, el dado que hiciste en Proyecto 1: Dados ponderados era un objeto doble: dado &lt;- c(1, 2, 3, 4, 5, 6) dado ## 1 2 3 4 5 6 Por lo general, sabrá con qué tipo de objeto está trabajando en R (será obvio), pero también puede preguntarle a R qué tipo de objeto es un objeto con typeof. Por ejemplo: typeof(dado) ## &quot;double&quot; Algunas funciones de R se refieren a los dobles como “numéricos”, y yo haré lo mismo con frecuencia. Doble es un término informático. Se refiere a la cantidad específica de bytes que usa su computadora para almacenar un número, pero encuentro que “numérico” es mucho más intuitivo cuando se hace ciencia de datos. 5.1.2 Enteros Los vectores enteros almacenan números enteros, números que se pueden escribir sin un componente decimal. Como científico de datos, no usará el tipo de número entero con mucha frecuencia porque puede guardar los números enteros como un objeto doble. Puede crear específicamente un número entero en R escribiendo un número seguido de una L mayúscula. Por ejemplo: ent &lt;- c(-1L, 2L, 4L) ent ## -1 2 4 typeof(ent) ## &quot;integer&quot; Tenga en cuenta que R no guardará un número como un entero a menos que incluya L. Los números enteros sin la L se guardarán como dobles. La única diferencia entre 4 y 4L es cómo R guarda el número en la memoria de tu computadora. Los números enteros se definen con mayor precisión en la memoria de su computadora que los dobles (a menos que el número entero sea muy grande o pequeño). ¿Por qué guardaría sus datos como un número entero en lugar de un doble? A veces, una diferencia en la precisión puede tener efectos sorprendentes. Su computadora asigna 64 bits de memoria para almacenar cada doble en un programa de R. Esto permite mucha precisión, pero algunos números no se pueden expresar exactamente en 64 bits, el equivalente a una secuencia de 64 unos y ceros. Por ejemplo, el número \\(\\pi\\) contiene una secuencia interminable de dígitos a la derecha del lugar decimal. Su computadora debe redondear \\(\\pi\\) a algo cercano, pero no exactamente igual a \\(\\pi\\) para almacenar \\(\\pi\\) en su memoria. Muchos números decimales comparten esta característica. Como resultado, cada doble tiene una precisión de unos 16 dígitos significativos. Esto introduce un pequeño error. En la mayoría de los casos, este error de redondeo pasará desapercibido. Sin embargo, en algunas situaciones, el error de redondeo puede causar resultados sorprendentes. Por ejemplo, puede esperar que el resultado de la siguiente expresión sea cero, pero no lo es: sqrt(2)^2 - 2 ## 4.440892e-16 La raíz cuadrada de dos no se puede expresar exactamente en 16 dígitos significativos. Como resultado, R tiene que redondear la cantidad y la expresión se resuelve en algo muy cercano a cero, pero no del todo. Estos errores se conocen como errores de punto flotante, y hacer aritmética en estas condiciones se conoce como aritmética de punto flotante. La aritmética de punto flotante no es una característica de R; es una característica de la programación de computadoras. Por lo general, los errores de punto flotante no serán suficientes para arruinar su día. Solo tenga en cuenta que pueden ser la causa de resultados sorprendentes. Puede evitar errores de punto flotante si evita los decimales y solo usa números enteros. Sin embargo, esta no es una opción en la mayoría de las situaciones de ciencia de datos. No puedes hacer muchas matemáticas con números enteros antes de que necesites un número no entero para expresar el resultado. Afortunadamente, los errores causados por la aritmética de punto flotante suelen ser insignificantes (y cuando no lo son, son fáciles de detectar). Como resultado, generalmente usará dobles en lugar de números enteros como científico de datos. 5.1.3 Caracteres Un vector de caracteres almacena pequeños fragmentos de texto. Puede crear un vector de caracteres en R escribiendo un carácter o una cadena de caracteres entre comillas: text &lt;- c(&quot;Hola&quot;, &quot;Mundo&quot;) text ## &quot;Hola&quot; &quot;Mundo&quot; typeof(text) ## &quot;character&quot; typeof(&quot;Hola&quot;) ## &quot;character&quot; Los elementos individuales de un vector de caracteres se conocen como cadenas. Tenga en cuenta que una cadena puede contener más que solo letras. También puede ensamblar una cadena de caracteres a partir de números o símbolos. Ejercicio 5.1 (Carácter or Número) ¿Puedes encontrar la diferencia entre una cadena de caracteres y un número? Aquí hay una prueba: ¿Cuáles de estos son cadenas de caracteres y cuáles son números? 1, \"1\", \"uno\". Solution. \"1\" y \"uno\" son ambos cadenas de caracteres. Las cadenas de caracteres pueden contener caracteres numéricos, pero eso no los convierte en numéricos. Son solo cadenas que tienen números en ellas. Puede distinguir cadenas de números reales porque las cadenas vienen entre comillas. De hecho, todo lo que esté entre comillas en R se tratará como una cadena de caracteres, independientemente de lo que aparezca entre las comillas. Es fácil confundir objetos de R con cadenas de caracteres. ¿Por qué? Porque ambos aparecen como fragmentos de texto en código de R. Por ejemplo, x es el nombre de un objeto R llamado “x”, \"x\" es una cadena de caracteres que contiene el carácter “x”. Uno es un objeto que contiene datos sin procesar, el otro es un fragmento de datos sin procesar en sí mismo. Espere un error cada vez que olvide sus comillas; R comenzará a buscar un objeto que probablemente no exista. 5.1.4 Lógicos Los vectores lógicos almacenan TRUE y FALSE, la forma de R de datos booleanos. Los lógicos son muy útiles para hacer cosas como comparaciones: 3 &gt; 4 ## FALSE Cada vez que escriba TRUE o FALSE en letras mayúsculas (sin comillas), R tratará su entrada como datos lógicos. R también asume que T y F son abreviaturas de TRUE y FALSE, a menos que se definan en otra parte (por ejemplo, ‘T &lt;- 500’). Dado que el significado de T y F puede cambiar, es mejor quedarse con TRUE y FALSE: logico &lt;- c(TRUE, FALSE, TRUE) logico ## TRUE FALSE TRUE typeof(logico) ## &quot;logical&quot; typeof(F) ## &quot;logical&quot; 5.1.5 Complejo y Sin Procesar Dobles, enteros, caracteres y lógicos son los tipos más comunes de vectores atómicos en R, pero R también reconoce dos tipos más: complejos y sin procesar. Es dudoso que alguna vez los use para analizar datos, pero aquí están por el bien de la minuciosidad. Los vectores complejos almacenan números complejos. Para crear un vector complejo, agregue un término imaginario a un número con i: comp &lt;- c(1 + 1i, 1 + 2i, 1 + 3i) comp ## 1+1i 1+2i 1+3i typeof(comp) ## &quot;complex&quot; Los vectores sin procesar almacenan bytes de datos sin procesar. Hacer vectores sin procesar se vuelve complicado, pero puedes hacer un vector sin procesar vacío de longitud n con raw(n). Consulte la página de ayuda de raw para obtener más opciones al trabajar con este tipo de datos: raw(3) ## 00 00 00 typeof(raw(3)) ## &quot;raw&quot; Ejercicio 5.2 (Vector de Cartas) Cree un vector atómico que almacene solo los nombres de las caras de las cartas en una escalera real, por ejemplo, el as de picas, el rey de picas, la reina de picas, la jota de picas y el diez de picas. El nombre de la cara del as de picas sería “as” y “picas” es el palo. ¿Qué tipo de vector usarás para guardar los nombres? Solution. Un vector de caracteres es el tipo de vector atómico más apropiado para guardar los nombres de las cartas. Puedes crear uno con la función c si pones cada nombre entre comillas: mano &lt;- c(&quot;as&quot;, &quot;rey&quot;, &quot;reina&quot;, &quot;jota&quot;, &quot;diez&quot;) mano ## &quot;as&quot; &quot;rey&quot; &quot;reina&quot; &quot;jota&quot; &quot;diez&quot; typeof(mano) ## &quot;character&quot; Esto crea un grupo unidimensional de nombres de cartas. ¡Excelente trabajo! Ahora hagamos una estructura de datos más sofisticada, una tabla bidimensional de nombres de cartas y palos. Puede construir un objeto más sofisticado a partir de un vector atómico dándole algunos atributos y asignándole una clase. 5.2 Atributos Un atributo es una pieza de información que puede adjuntar a un vector atómico (o cualquier objeto de R). El atributo no afectará ninguno de los valores del objeto y no aparecerá cuando muestre su objeto. Puede pensar en un atributo como “metadatos”; es solo un lugar conveniente para colocar información asociada con un objeto. R normalmente ignorará estos metadatos, pero algunas funciones de R verificarán atributos específicos. Estas funciones pueden usar los atributos para hacer cosas especiales con los datos. Puedes ver qué atributos tiene un objeto con attributes. attributes devolverá NULL si un objeto no tiene atributos. Un vector atómico, como dado, no tendrá ningún atributo a menos que le des alguno: attributes(dado) ## NULL NULL R usa NULL para representar el conjunto nulo, un objeto vacío. NULL a menudo es devuelto por funciones cuyos valores no están definidos. Puede crear un objeto NULL escribiendo NULL en letras mayúsculas. 5.2.1 Nombres Los atributos más comunes para dar un vector atómico son nombres, dimensiones (dim) y clases. Cada uno de estos atributos tiene su propia función auxiliar que puede usar para otorgar atributos a un objeto. También puede usar las funciones auxiliares para buscar el valor de estos atributos para los objetos que ya los tienen. Por ejemplo, puedes buscar el valor del atributo de nombres de dado con names: names(dado) ## NULL NULL significa que dado no tiene un atributo de nombres. Puedes darle uno a dado asignando un vector de caracteres a la salida de names. El vector debe incluir un nombre para cada elemento en dado: names(dado) &lt;- c(&quot;uno&quot;, &quot;dos&quot;, &quot;tres&quot;, &quot;cuatro&quot;, &quot;cinco&quot;, &quot;seis&quot;) Ahora dado tiene el atributo nombres: names(dado) ## &quot;uno&quot; &quot;dos&quot; &quot;tres&quot; &quot;cuatro&quot; &quot;cinco&quot; &quot;seis&quot; attributes(dado) ## $names ## [1] &quot;uno&quot; &quot;dos&quot; &quot;tres&quot; &quot;cuatro&quot; &quot;cinco&quot; &quot;seis&quot; R mostrará los nombres sobre los elementos de dado cada vez que mires el vector: dado ## uno dos tres cuatro cinco seis ## 1 2 3 4 5 6 Sin embargo, los nombres no afectarán los valores reales del vector, ni los nombres se verán afectados cuando manipule los valores del vector: dado + 1 ## uno dos tres cuatro cinco seis ## 2 3 4 5 6 7 También puede usar names para cambiar el atributo de nombres o eliminarlo todo junto. Para cambiar los nombres, asigna un nuevo conjunto de etiquetas a names: names(dado) &lt;- c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;, &quot;six&quot;) dado ## one two three four five six ## 1 2 3 4 5 6 Para eliminar el atributo de nombres, configúrelo en NULL: names(dado) &lt;- NULL dado ## 1 2 3 4 5 6 5.2.2 Dimensiones Puede transformar un vector atómico en una matriz n-dimensional dándole un atributo de dimensiones con dim. Para hacer esto, establezca el atributo dim en un vector numérico de longitud n. R reorganizará los elementos del vector en n dimensiones. Cada dimensión tendrá tantas filas (o columnas, etc.) como el valor n del vector dim. Por ejemplo, puede reorganizar dado en una matriz de 2 × 3 (que tiene 2 filas y 3 columnas): dim(dado) &lt;- c(2, 3) dado ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 o en una mariz de 3 × 2 (que tiene 3 filas y 2 columnas): dim(dado) &lt;- c(3, 2) dado ## [,1] [,2] ## [1,] 1 4 ## [2,] 2 5 ## [3,] 3 6 o en hipercubo de 1 × 2 × 3 (que tiene 1 fila, 2 columnas, y 3 “rebanadas”). Esta es una estructura tridimensional, pero R necesitará mostrarla rebanada por rebanada en la pantalla bidimensional de su computadora: dim(dado) &lt;- c(1, 2, 3) dado ## , , 1 ## ## [,1] [,2] ## [1,] 1 2 ## ## , , 2 ## ## [,1] [,2] ## [1,] 3 4 ## ## , , 3 ## ## [,1] [,2] ## [1,] 5 6 R siempre usará el primer valor en dim para el número de filas y el segundo valor para el número de columnas. En general, las filas siempre van primero en las operaciones de R que se ocupan tanto de filas como de columnas. Puede notar que no tiene mucho control sobre cómo R reorganiza los valores en filas y columnas. Por ejemplo, R siempre llena cada matriz por columnas, en lugar de por filas. Si desea tener más control sobre este proceso, puede usar una de las funciones auxiliares de R, matrix o array. Hacen lo mismo que cambiar el atributo dim, pero proporcionan argumentos adicionales para personalizar el proceso. 5.3 Matrices Las matrices almacenan valores en una matriz bidimensional, como una matriz de álgebra lineal. Para crear uno, primero dale a matrix un vector atómico para reorganizar en una matriz. Luego, defina cuántas filas debe haber en la matriz configurando el argumento nrow en un número. matrix organizará su vector de valores en una matriz con el número especificado de filas. Alternativamente, puede establecer el argumento ncol, que le dice a R cuántas columnas incluir en la matriz: m &lt;- matrix(dado, nrow = 2) m ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 matrix llenará la matriz columna por columna por defecto, pero puedes llenar la matriz fila por fila si incluyes el argumento byrow = TRUE: m &lt;- matrix(dado, nrow = 2, byrow = TRUE) m ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 matrix también tiene otros argumentos predeterminados que puede usar para personalizar su matriz. Puede leer sobre ellos en la página de ayuda de matrix (accesible por ?matrix). 5.4 Arreglos La función array crea una matriz de n dimensiones. Por ejemplo, podría usar array para clasificar los valores en un cubo de tres dimensiones o un hipercubo en 4, 5 o n dimensiones. array no es tan personalizable como matrix y básicamente hace lo mismo que configurar el atributo dim. Para usar array, proporcione un vector atómico como primer argumento y un vector de dimensiones como segundo argumento, ahora llamado dim: ar &lt;- array(c(11:14, 21:24, 31:34), dim = c(2, 2, 3)) ar ## , , 1 ## ## [,1] [,2] ## [1,] 11 13 ## [2,] 12 14 ## ## , , 2 ## ## [,1] [,2] ## [1,] 21 23 ## [2,] 22 24 ## ## , , 3 ## ## [,1] [,2] ## [1,] 31 33 ## [2,] 32 34 Ejercicio 5.3 (Hacer una Matriz) Cree la siguiente matriz, que almacena el nombre y el palo de cada carta en una escalera real. ## [,1] [,2] ## [1,] &quot;as&quot; &quot;picas&quot; ## [2,] &quot;rey&quot; &quot;picas&quot; ## [3,] &quot;reina&quot; &quot;picas&quot; ## [4,] &quot;jota&quot; &quot;picas&quot; ## [5,] &quot;diez&quot; &quot;picas&quot; Solution. Hay más de una forma de construir esta matriz, pero en todos los casos, deberá comenzar creando un vector de caracteres con 10 valores. Si comienza con el siguiente vector de caracteres, puede convertirlo en una matriz con cualquiera de los siguientes tres comandos: mano1 &lt;- c(&quot;as&quot;, &quot;rey&quot;, &quot;reina&quot;, &quot;jota&quot;, &quot;diez&quot;, &quot;picas&quot;, &quot;picas&quot;, &quot;picas&quot;, &quot;picas&quot;, &quot;picas&quot;) matrix(mano1, nrow = 5) matrix(mano1, ncol = 2) dim(mano1) &lt;- c(5, 2) También puede comenzar con un vector de caracteres que enumere las cartas en un orden ligeramente diferente. En este caso, deberá pedirle a R que llene la matriz fila por fila en lugar de columna por columna: mano2 &lt;- c(&quot;as&quot;, &quot;picas&quot;, &quot;rey&quot;, &quot;picas&quot;, &quot;reina&quot;, &quot;picas&quot;, &quot;jota&quot;, &quot;picas&quot;, &quot;diez&quot;, &quot;picas&quot;) matrix(mano2, nrow = 5, byrow = TRUE) matrix(mano2, ncol = 2, byrow = TRUE) 5.5 Clases Tenga en cuenta que cambiar las dimensiones de su objeto no cambiará el tipo del objeto, pero cambiará el atributo clase del objeto: dim(dado) &lt;- c(2, 3) typeof(dado) ## &quot;double&quot; class(dado) ## &quot;matrix&quot; Una matriz es un caso especial de un vector atómico. Por ejemplo, la matriz dado es un caso especial de vector doble. Cada elemento de la matriz sigue siendo un doble, pero los elementos se han organizado en una nueva estructura. R agregó un atributo de clase a dado cuando cambiaste sus dimensiones. Esta clase describe el nuevo formato de dado. Muchas funciones de R buscarán específicamente el atributo clase de un objeto y luego manejarán el objeto de una manera predeterminada en función del atributo. Tenga en cuenta que el atributo clase de un objeto no siempre aparecerá cuando ejecute attributes; es posible que deba buscarlo específicamente con class: attributes(dado) ## $dim ## [1] 2 3 Puede aplicar class a objetos que no tienen un atributo de clase. class devolverá un valor basado en el tipo atómico del objeto. Tenga en cuenta que la “clase” de un doble es “numérica”, una desviación extraña, pero por la que estoy agradecido. Creo que la propiedad más importante de un vector doble es que contiene números, una propiedad que “numeric” hace evidente: class(&quot;Hola&quot;) ## &quot;character&quot; class(5) ## &quot;numeric&quot; También puede usar class para establecer el atributo clase de un objeto, pero esto suele ser una mala idea. R esperará que los objetos de una clase compartan ciertas características, como atributos, que su objeto puede no poseer. Aprenderá a crear y utilizar sus propias clases en [Proyecto 3: Máquina Tragamonedas]. 5.5.1 Fechas y Horarios El sistema de atributos permite que R represente más tipos de datos que solo dobles, enteros, caracteres, lógicos, complejos y sin procesar. La hora parece una cadena de caracteres cuando la visualizas, pero su tipo de datos es en realidad \"doble\", y su clase es \"POSIXct\" \"POSIXt\" (tiene dos clases): ahora &lt;- Sys.time() ahora ## &quot;2014-03-17 12:00:00 UTC&quot; typeof(ahora) ## &quot;double&quot; class(ahora) ## &quot;POSIXct&quot; &quot;POSIXt&quot; POSIXct es un marco ampliamente utilizado para representar fechas y horas. En el marco de POSIXct, cada hora se representa por la cantidad de segundos que han pasado entre la hora y las 12:00 a. m. del 1 de enero de 1970 (en la zona Universal Time Coordinated (UTC)). Por ejemplo, el tiempo anterior ocurre 1 395 057 600 segundos después. Entonces, en el sistema POSIXct, el tiempo se guardaría como 1395057600. R crea el objeto de tiempo construyendo un vector doble con un elemento, 1395057600. Puede ver este vector eliminando el atributo clase de ahora, o usando la función unclass, que hace lo mismo: unclass(ahora) ## 1395057600 R luego le da al vector doble un atributo clase que contiene dos clases, \"POSIXct\" y \"POSIXt\". Este atributo alerta a las funciones de R de que están tratando con un tiempo POSIXct, para que puedan tratarlo de una manera especial. Por ejemplo, las funciones R usarán el estándar POSIXct para convertir la hora en una cadena de caracteres fácil de usar antes de mostrarla. Puede aprovechar este sistema dando la clase POSIXct a objetos R aleatorios. Por ejemplo, ¿alguna vez se ha preguntado qué día era un millón de segundos después de las 12:00 a. m. del 1 de enero de 1970? millon &lt;- 1000000 millon ## 1e+06 class(millon) &lt;- c(&quot;POSIXct&quot;, &quot;POSIXt&quot;) millon ## &quot;1970-01-12 13:46:40 UTC&quot; 12 de enero de 1970. Vaya. Un millón de segundos pasan más rápido de lo que piensas. Esta conversión funcionó bien porque la clase POSIXct no depende de ningún atributo adicional, pero en general, forzar la clase de un objeto es una mala idea. Hay muchas clases diferentes de datos en R y sus paquetes, y cada día se inventan nuevas clases. Sería difícil aprender sobre cada clase, pero no es necesario. La mayoría de las clases solo son útiles en situaciones específicas. Dado que cada clase viene con su propia página de ayuda, puede esperar para aprender sobre una clase hasta que la encuentre. Sin embargo, hay una clase de datos que es tan omnipresente en R que debería conocerla junto con los tipos de datos atómicos. Esa clase es factores. 5.5.2 Factores Los factores son la forma en que R almacena información categórica, como el origen étnico o el color de ojos. Piense en un factor como algo así como un género; solo puede tener ciertos valores (masculino o femenino), y estos valores pueden tener su propio orden idiosincrático (damas primero). Este arreglo hace que los factores sean muy útiles para registrar los niveles de tratamiento de un estudio y otras variables categóricas. Para hacer un factor, pase un vector atómico a la función factor. R recodificará los datos en el vector como enteros y almacenará los resultados en un vector entero. R también agregará un atributo niveles (levels en inglés) al entero, que contiene un conjunto de etiquetas para mostrar los valores de los factores, y un atributo class, que contiene la clase factor: genero &lt;- factor(c(&quot;masculino&quot;, &quot;femenino&quot;, &quot;femenino&quot;, &quot;masculino&quot;)) typeof(genero) ## &quot;integer&quot; attributes(genero) ## $levels ## [1] &quot;femenino&quot; &quot;masculino&quot; ## ## $class ## [1] &quot;factor&quot; Puedes ver exactamente cómo R almacena tu factor con unclass: unclass(genero) ## [1] 2 1 1 2 ## attr(,&quot;levels&quot;) ## [1] &quot;femenino&quot; &quot;masculino&quot; R usa el atributo de niveles cuando muestra el factor, como verá. R mostrará cada 1 como femenino, la primera etiqueta en el vector de niveles, y cada 2 como masculino, la segunda etiqueta. Si el factor incluyera 3, se mostrarían como la tercera etiqueta, y así sucesivamente: genero ## masculino femenino femenino masculino ## Levels: femenino masculino Los factores facilitan la colocación de variables categóricas en un modelo estadístico porque las variables ya están codificadas como números. Sin embargo, los factores pueden resultar confusos, ya que parecen cadenas de caracteres pero se comportan como números enteros. R a menudo intentará convertir cadenas de caracteres en factores cuando cargue y cree datos. En general, tendrá una experiencia más fluida si no permite que R haga factores hasta que los solicite. Te mostraré cómo hacer esto cuando comencemos a leer datos. Puede convertir un factor en una cadena de caracteres con la función as.character. R conservará la versión de visualización del factor, no los números enteros almacenados en la memoria: as.character(genero) ## &quot;masculino&quot; &quot;femenino&quot; &quot;femenino&quot; &quot;masculino&quot; Ahora que comprende las posibilidades que brindan los vectores atómicos de R, hagamos un tipo de naipe más complicado. Ejercicio 5.4 (Escriba una Carta) Muchos juegos de cartas asignan un valor numérico a cada carta. Por ejemplo, en el blackjack, cada carta con figuras vale 10 puntos, cada carta con números vale entre 2 y 10 puntos, y cada as vale 1 u 11 puntos, dependiendo de la puntuación final. Haz un naipe virtual combinando “as”, “corazón” y 1 en un vector. ¿Qué tipo de vector atómico resultará? Comprueba si tienes razón. Solution. Es posible que hayas adivinado que este ejercicio no saldría bien. Cada vector atómico solo puede almacenar un tipo de datos. Como resultado, R convierte todos sus valores en cadenas de caracteres: carta &lt;- c(&quot;as&quot;, &quot;corazones&quot;, 1) carta ## &quot;as&quot; &quot;corazones&quot; &quot;1&quot; Esto causará problemas si desea hacer operaciones matemáticas con ese valor en puntos, por ejemplo, para ver quién ganó su juego de blackjack. Tipos de datos en vectores Si intenta poner varios tipos de datos en un vector, R convertirá los elementos en un solo tipo de datos. Dado que las matrices y los arreglos son casos especiales de vectores atómicos, sufren el mismo comportamiento. Cada uno solo puede almacenar un tipo de datos. Esto crea un par de problemas. Primero, muchos conjuntos de datos contienen múltiples tipos de datos. Los programas simples como Excel y Numbers pueden guardar múltiples tipos de datos en el mismo conjunto de datos, y debería esperar que R también pueda hacerlo. No te preocupes, puede. En segundo lugar, la coerción es un comportamiento común en R, por lo que querrá saber cómo funciona. 5.6 Coerción El comportamiento de coerción de R puede parecer inconveniente, pero no es arbitrario. R siempre sigue las mismas reglas cuando obliga a los tipos de datos. Una vez que esté familiarizado con estas reglas, puede usar el comportamiento de coerción de R para hacer cosas sorprendentemente útiles. Entonces, ¿cómo coacciona R los tipos de datos? Si una cadena de caracteres está presente en un vector atómico, R convertirá todo lo demás en el vector en cadenas de caracteres. Si un vector solo contiene lógicos y números, R convertirá los lógicos en números; cada TRUE se convierte en 1, y cada FALSE se convierte en 0, como se muestra en la Figura 5.1. Figure 5.1: R siempre usa las mismas reglas para obligar a los datos a un solo tipo. Si hay cadenas de caracteres presentes, todo se convertirá en una cadena de caracteres. De lo contrario, los lógicos se convierten en numéricos. Este arreglo preserva la información. Es fácil mirar una cadena de caracteres y decir qué información solía contener. Por ejemplo, puede detectar fácilmente los orígenes de \"TRUE\" y \"5\". También puede volver a transformar fácilmente un vector de 1 y 0 en TRUE y FALSE. R usa las mismas reglas de coerción cuando intenta hacer operaciones matemáticas con valores lógicos. Entonces el siguiente código: sum(c(TRUE, TRUE, FALSE, FALSE)) se convertirá: sum(c(1, 1, 0, 0)) ## 2 Esto significa que sum contará el número de TRUE en un vector lógico (y mean calculará la proporción de TRUE). Listo, ¿eh? Puede pedirle explícitamente a R que convierta datos de un tipo a otro con las funciones as. R convertirá los datos siempre que haya una forma sensata de hacerlo: as.character(1) ## &quot;1&quot; as.logical(1) ## TRUE as.numeric(FALSE) ## 0 Ahora sabe cómo R coacciona los tipos de datos, pero esto no lo ayudará a salvar una carta. Para hacer eso, deberá evitar la coerción por completo. Puedes hacer esto usando un nuevo tipo de objeto, una lista. Antes de ver las listas, abordemos una pregunta que podría tener en mente. Muchos conjuntos de datos contienen múltiples tipos de información. La incapacidad de vectores, matrices y arreglos para almacenar múltiples tipos de datos parece ser una limitación importante. Entonces, ¿por qué molestarse con ellos? En algunos casos, usar un solo tipo de datos es una gran ventaja. Los vectores, las matrices y los arreglos hacen que sea muy fácil hacer operaciones matemáticas con grandes conjuntos de números porque R sabe que puede manipular cada valor de la misma manera. Las operaciones con vectores, matrices y arreglos también tienden a ser rápidas porque los objetos son muy fáciles de almacenar en la memoria. En otros casos, permitir un solo tipo de datos no es una desventaja. Los vectores son la estructura de datos más común en R porque almacenan muy bien las variables. Cada valor de una variable mide la misma propiedad, por lo que no es necesario utilizar diferentes tipos de datos. 5.7 Listas Las listas son como vectores atómicos porque agrupan datos en un conjunto unidimensional. Sin embargo, las listas no agrupan valores individuales; las listas agrupan objetos de R, como vectores atómicos y otras listas. Por ejemplo, puede crear una lista que contenga un vector numérico de longitud 31 en su primer elemento, un vector de caracteres de longitud 1 en su segundo elemento y una nueva lista de longitud 2 en su tercer elemento. Para hacer esto, use la función list. list crea una lista de la misma manera que c crea un vector. Separe cada elemento de la lista con una coma: lista1 &lt;- list(100:130, &quot;R&quot;, list(TRUE, FALSE)) lista1 ## [[1]] ## [1] 100 101 102 103 104 105 106 107 108 109 110 111 112 ## [14] 113 114 115 116 117 118 119 120 121 122 123 124 125 ## [27] 126 127 128 129 130 ## ## [[2]] ## [1] &quot;R&quot; ## ## [[3]] ## [[3]][[1]] ## [1] TRUE ## ## [[3]][[2]] ## [1] FALSE Dejé la notación [1] en la salida para que puedas ver cómo cambia para las listas. Los índices entre corchetes le indican qué elemento de la lista se está mostrando. Los índices de un solo paréntesis le indican qué subelemento de un elemento se muestra. Por ejemplo, 100 es el primer subelemento del primer elemento de la lista. \"R\" es el primer subelemento del segundo elemento. Esta notación de dos sistemas surge porque cada elemento de una lista puede ser cualquier objeto R, incluido un nuevo vector (o lista) con sus propios índices. Las listas son un tipo básico de objeto en R, a la par de los vectores atómicos. Al igual que los vectores atómicos, se utilizan como bloques de construcción para crear muchos tipos más sofisticados de objetos de R. Como puede imaginar, la estructura de las listas puede volverse bastante complicada, pero esta flexibilidad hace que las listas sean una herramienta de almacenamiento útil para todo uso en R: puede agrupar cualquier cosa con una lista. Sin embargo, no todas las listas tienen que ser complicadas. Puede almacenar una carta de juego en una lista muy simple. Ejercicio 5.5 (Usar una Lista para Crear una Carta) Use una lista para almacenar una sola carta, como el as de corazones, que tiene un valor de punto de uno. La lista debe guardar la cara de la carta, el palo y el valor del punto en elementos separados. Solution. Puedes crear tu carta así. En el siguiente ejemplo, el primer elemento de la lista es un vector de caracteres (de longitud 1). El segundo elemento también es un vector de caracteres y el tercer elemento es un vector numérico: carta &lt;- list(&quot;as&quot;, &quot;corazones&quot;, 1) carta ## [[1]] ## [1] &quot;as&quot; ## ## [[2]] ## [1] &quot;corazones&quot; ## ## [[3]] ## [1] 1 También puede usar una lista para almacenar una baraja completa de cartas. Dado que puede guardar una sola carta de juego como una lista, puede guardar una baraja de cartas de juego como una lista de 52 sublistas (una para cada carta). Pero no nos molestemos, hay una forma mucho más limpia de hacer lo mismo. Puede usar una clase especial de lista, conocida como data frames. 5.8 Data Frames Data frames son la versión bidimensional de una lista. Son, por mucho, la estructura de almacenamiento más útil para el análisis de datos y proporcionan una forma ideal de almacenar una baraja completa de cartas. Puede pensar en un data frame como el equivalente de R a la hoja de cálculo de Excel porque almacena datos en un formato similar. Data frames agrupan vectores en una tabla bidimensional. Cada vector se convierte en una columna en la tabla. Como resultado, cada columna de un data frame puede contener un tipo diferente de datos; pero dentro de una columna, cada celda debe tener el mismo tipo de datos, como en la Figura 5.2. Figure 5.2: Data frames almacenan datos como una secuencia de columnas. Cada columna puede ser un tipo de datos diferente. Cada columna en un data frame debe tener la misma longitud. Crear un data frame a mano requiere escribir mucho, pero puede hacerlo (si lo desea) con la función data.frame. Proporcione a data.frame cualquier número de vectores, cada uno separado por una coma. Cada vector debe establecerse igual a un nombre que describa el vector. data.frame convertirá cada vector en una columna del nuevo data frame: df &lt;- data.frame(cara = c(&quot;as&quot;, &quot;dos&quot;, &quot;seis&quot;), palo = c(&quot;treboles&quot;, &quot;treboles&quot;, &quot;treboles&quot;), valor = c(1, 2, 3)) df ## cara palo valor ## as treboles 1 ## dos treboles 2 ## seis treboles 3 Deberá asegurarse de que cada vector tenga la misma longitud (o se puede hacer así con las reglas de reciclaje de R; consulte la figura 2.4, ya que los data frames no pueden combinar columnas de diferentes longitudes. En el código anterior, nombré los argumentos en data.frame cara, palo y valor, pero puedes nombrar los argumentos como quieras. data.frame utilizará los nombres de sus argumentos para etiquetar las columnas del data frame. Nombres También puede dar nombres a una lista o vector cuando crea uno de estos objetos. Use la misma sintaxis que con data.frame: list(cara = \"as\", palo = \"corazones\", value = 1) c(cara = \"as\", palo = \"corazones\", value = \"one\") Los nombres se almacenarán en el atributo names del objeto. Si observa el tipo de data frame, verá que es una lista. De hecho, cada data frame es una lista con la clase data.frame. Puede ver qué tipos de objetos se agrupan en una lista (o data frame) con la función str: typeof(df) ## &quot;list&quot; class(df) ## &quot;data.frame&quot; str(df) ## &#39;data.frame&#39;: 3 obs. of 3 variables: ## $ cara : Factor w/ 3 levels &quot;as&quot;,&quot;seis&quot;,&quot;dos&quot;: 1 3 2 ## $ palo : Factor w/ 1 level &quot;treboles&quot;: 1 1 1 ## $ valor: num 1 2 3 Observe que R guardó sus cadenas de caracteres como factores. ¡Te dije que a R le gustan los factores! No es un gran problema aquí, pero puede evitar este comportamiento agregando el argumento stringsAsFactors = FALSE a data.frame: df &lt;- data.frame(cara = c(&quot;as&quot;, &quot;dos&quot;, &quot;seis&quot;), palo = c(&quot;treboles&quot;, &quot;treboles&quot;, &quot;treboles&quot;), value = c(1, 2, 3), stringsAsFactors = FALSE) Un data frame es una excelente manera de construir una baraja completa de cartas. Puede convertir cada fila del data frame en una carta de juego y cada columna en un tipo de valor, cada uno con su propio tipo de datos apropiado. El data frame se vería así: ## cara palo valor ## rey picas 13 ## reina picas 12 ## jota picas 11 ## diez picas 10 ## nueve picas 9 ## ocho picas 8 ## siete picas 7 ## seis picas 6 ## cinco picas 5 ## cuatro picas 4 ## tres picas 3 ## dos picas 2 ## as picas 1 ## rey treboles 13 ## reina treboles 12 ## jota treboles 11 ## diez treboles 10 ## ... y así sucesivamente. Podría crear este data frame con data.frame, ¡pero mire la escritura involucrada! Necesitas escribir tres vectores, cada uno con 52 elementos: baraja &lt;- data.frame( cara = c(&quot;rey&quot;, &quot;reina&quot;, &quot;jota&quot;, &quot;diez&quot;, &quot;nueve&quot;, &quot;ocho&quot;, &quot;siete&quot;, &quot;seis&quot;, &quot;cinco&quot;, &quot;cuatro&quot;, &quot;tres&quot;, &quot;dos&quot;, &quot;as&quot;, &quot;rey&quot;, &quot;reina&quot;, &quot;jota&quot;, &quot;diez&quot;, &quot;nueve&quot;, &quot;ocho&quot;, &quot;siete&quot;, &quot;seis&quot;, &quot;cinco&quot;, &quot;cuatro&quot;, &quot;tres&quot;, &quot;dos&quot;, &quot;as&quot;, &quot;rey&quot;, &quot;reina&quot;, &quot;jota&quot;, &quot;diez&quot;, &quot;nueve&quot;, &quot;ocho&quot;, &quot;siete&quot;, &quot;seis&quot;, &quot;cinco&quot;, &quot;cuatro&quot;, &quot;tres&quot;, &quot;dos&quot;, &quot;as&quot;, &quot;rey&quot;, &quot;reina&quot;, &quot;jota&quot;, &quot;diez&quot;, &quot;nueve&quot;, &quot;ocho&quot;, &quot;siete&quot;, &quot;seis&quot;, &quot;cinco&quot;, &quot;cuatro&quot;, &quot;tres&quot;, &quot;dos&quot;, &quot;as&quot;), palo = c(&quot;picas&quot;, &quot;picas&quot;, &quot;picas&quot;, &quot;picas&quot;, &quot;picas&quot;, &quot;picas&quot;, &quot;picas&quot;, &quot;picas&quot;, &quot;picas&quot;, &quot;picas&quot;, &quot;picas&quot;, &quot;picas&quot;, &quot;picas&quot;, &quot;treboles&quot;, &quot;treboles&quot;, &quot;treboles&quot;, &quot;treboles&quot;, &quot;treboles&quot;, &quot;treboles&quot;, &quot;treboles&quot;, &quot;treboles&quot;, &quot;treboles&quot;, &quot;treboles&quot;, &quot;treboles&quot;, &quot;treboles&quot;, &quot;treboles&quot;, &quot;diamantes&quot;, &quot;diamantes&quot;, &quot;diamantes&quot;, &quot;diamantes&quot;, &quot;diamantes&quot;, &quot;diamantes&quot;, &quot;diamantes&quot;, &quot;diamantes&quot;, &quot;diamantes&quot;, &quot;diamantes&quot;, &quot;diamantes&quot;, &quot;diamantes&quot;, &quot;diamantes&quot;, &quot;corazones&quot;, &quot;corazones&quot;, &quot;corazones&quot;, &quot;corazones&quot;, &quot;corazones&quot;, &quot;corazones&quot;, &quot;corazones&quot;, &quot;corazones&quot;, &quot;corazones&quot;, &quot;corazones&quot;, &quot;corazones&quot;, &quot;corazones&quot;, &quot;corazones&quot;), valor = c(13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1) ) Debe evitar escribir grandes conjuntos de datos a mano siempre que sea posible. Escribir invita a errores tipográficos y errores. Siempre es mejor adquirir grandes conjuntos de datos como un archivo de computadora. Luego puede pedirle a R que lea el archivo y almacene el contenido como un objeto. Creé un archivo para que lo cargues que contiene un marco de datos de información de naipes, así que no te preocupes por escribir el código. En su lugar, dirija su atención hacia la carga de datos en R. 5.9 Cargando Datos Puede cargar el data frame Mazo desde el archivo mazo.csv. Tómese un momento para descargar el archivo antes de seguir leyendo. Visite el sitio web, haga clic en “Descargar Zip” y luego descomprima y abra la carpeta que descarga su navegador web. mazo.csv estará dentro. mazo.csv es un archivo de valores separados por comas, o CSV para abreviar. Los CSV son archivos de texto sin formato, lo que significa que puede abrirlos en un editor de texto (así como en muchos otros programas). Si abre mazo.csv, notará que contiene una tabla de datos similar a la siguiente tabla. Cada fila de la tabla se guarda en su propia línea y se usa una coma para separar las celdas dentro de cada fila. Cada archivo CSV comparte este formato básico: &quot;cara&quot;,&quot;palo&quot;,&quot;valor&quot; &quot;rey&quot;,&quot;picas&quot;,13 &quot;reina&quot;,&quot;picas&quot;,12 &quot;jota&quot;,&quot;picas&quot;,11 &quot;diez&quot;,&quot;picas&quot;,10 &quot;nueve&quot;,&quot;picas&quot;,9 ... y así sucesivamente. La mayoría de las aplicaciones de ciencia de datos pueden abrir archivos de texto sin formato y exportar datos como archivos de texto sin formato. Esto hace que los archivos de texto sin formato sean una especie de lingua franca para la ciencia de datos. Para cargar un archivo de texto sin formato en R, haga clic en el icono Import Dataset en RStudio, que se muestra en la Figura 5.3. Luego seleccione “From text file (base)”. Figure 5.3: Puede importar datos desde archivos de texto sin formato con Import Dataset de RStudio. RStudio le pedirá que seleccione el archivo que desea importar, luego abrirá un asistente para ayudarlo a importar los datos, como en la Figura 5.4. Utilice el asistente para decirle a RStudio qué nombre dar al conjunto de datos. También puede usar el asistente para decirle a RStudio qué carácter usa el conjunto de datos como separador, qué carácter usa para representar decimales (generalmente un punto en los Estados Unidos y una coma en Europa) y si el conjunto de datos viene o no con una fila de nombres de columna (conocido como header). Para ayudarlo, el asistente le muestra cómo se ve el archivo sin procesar, así como también cómo se verán los datos cargados según la configuración de entrada. También puede desmarcar la casilla “Strings as factors” en el asistente. Recomiendo hacer esto. Si lo hace, R cargará todas sus cadenas de caracteres como cadenas de caracteres. Si no lo hace, R los convertirá en factores. Figure 5.4: Asistente de importación de RStudio. Una vez que todo se vea bien, haga clic en Import. RStudio leerá los datos y los guardará en un data frame. RStudio también abrirá un visor de datos, para que pueda ver sus nuevos datos en un formato de hoja de cálculo. Esta es una buena manera de verificar que todo salió como se esperaba. Si todo funcionó bien, su archivo debería aparecer en una pestaña View de RStudio, como se ve en la Figura 5.5. Puede examinar el data frame en la consola con head(mazo) Datos en Línea Puede cargar un archivo de texto sin formato directamente desde Internet haciendo click en Import Dataset &gt; From Text (readr) y copiando la url del archivo en la casilla “File/URL” del asistente de importación de RStudio. Para poder utlizar esta opción debera instalar el paquete readr. Figure 5.5: Cuando importa un conjunto de datos, RStudio guardará los datos en un data frame y luego mostrará el data frame en una pestaña View. Puede abrir cualquier data frame en una pestaña View en cualquier momento con la función View. Ahora es tu turno. Descargue mazo.csv e impórtelo a RStudio. Asegúrese de guardar la salida en un objeto de R llamado mazo: lo usará en los próximos capítulos. Si todo va correctamente, las primeras líneas de su data frame deberían verse así: head(mazo) ## cara palo valor ## rey picas 13 ## reina picas 12 ## jota picas 11 ## diez picas 10 ## nueve picas 9 ## ocho picas 8 head y tail son dos funciones que proporcionan una manera fácil de echar un vistazo a grandes conjuntos de datos. head devolverá solo las primeras seis filas del conjunto de datos, y tail devolverá solo las últimas seis filas. Para ver un número diferente de filas, dé a head o tail un segundo argumento, el número de filas que le gustaría ver, por ejemplo, head (mazo, 10). R puede abrir muchos tipos de archivos, no solo CSV. Visite [Cargar y Guardar Datos en R] para obtener información sobre cómo abrir otros tipos comunes de archivos en R. 5.10 Guardando Datos Antes de continuar, guardemos una copia de mazo como un nuevo archivo .csv. De esa manera, puede enviarlo por correo electrónico a un colega, almacenarlo en una memoria USB o abrirlo en un programa diferente. Puede guardar cualquier data frame en R en un archivo .csv con el comando write.csv. Para guardar mazo, ejecute: write.csv(mazo, file = &quot;cartas.csv&quot;, row.names = FALSE) R convertirá su data frame en un archivo de texto sin formato con el formato de valores separados por comas y guardará el archivo en su directorio de trabajo. Para ver dónde está su directorio de trabajo, ejecute getwd(). Para cambiar la ubicación de su directorio de trabajo, visite Session &gt; Set Working Directory &gt; Choose Directory en la barra de menú de RStudio. Puede personalizar el proceso de guardado con el amplio conjunto de argumentos opcionales de write.csv (consulte ?write.csv para obtener más detalles). Sin embargo, hay tres argumentos que debería usar cada vez que ejecute write.csv. Primero, debe darle a write.csv el nombre del data frame que desea guardar. A continuación, debe proporcionar un nombre de archivo para darle a su archivo. R tomará este nombre literalmente, así que asegúrese de proporcionar una extensión. Finalmente, debe agregar el argumento row.names = FALSE. Esto evitará que R agregue una columna de números al comienzo de su marco de datos. Estos números identificarán sus filas del 1 al 52, pero es poco probable que cualquier programa en el que abra cartas.csv comprenda el sistema de nombres de fila. Lo más probable es que el programa asuma que los nombres de las filas son la primera columna de datos en su marco de datos. De hecho, esto es exactamente lo que asumirá R si vuelve a abrir cartas.csv. Si guarda y abre cartas.csv varias veces en R, notará que se forman columnas duplicadas de números de fila al comienzo de su marco de datos. No puedo explicar por qué R hace esto, pero puedo explicar cómo evitarlo: use row.names = FALSE siempre que guarde datos con write.csv. Para obtener más detalles sobre cómo guardar archivos, incluido cómo comprimir archivos guardados y cómo guardar archivos en otros formatos, consulte [Cargar y Guardar Datos en R]. Buen trabajo. Ahora tiene una baraja de cartas virtual con la que trabajar. Tómese un respiro y, cuando regrese, comenzaremos a escribir algunas funciones para usar en su mazo. 5.11 Resumen Puede guardar datos en R con cinco objetos diferentes, que le permiten almacenar diferentes tipos de valores en diferentes tipos de relaciones, como en la Figura ??. De estos objetos, los data frame son, por mucho, los más útiles para la ciencia de datos. Los data frame almacenan una de las formas de datos más comunes utilizadas en la ciencia de datos, los datos tabulares. Figure 5.6: Las estructuras de datos más comunes de R son vectores, matrices, arreglos, listas y marcos de datos. Puede cargar datos tabulares en un data frame con el botón Import Dataset de RStudio, siempre que los datos se guarden como un archivo de texto sin formato. Este requisito no es tan limitante como parece. La mayoría de los programas de software pueden exportar datos como un archivo de texto sin formato. Entonces, si tiene un archivo de Excel (por ejemplo), puede abrir el archivo en Excel y exportar los datos como CSV para usar con R. De hecho, abrir un archivo en su programa original es una buena práctica. Los archivos de Excel usan metadatos, como hojas y fórmulas, que ayudan a Excel a trabajar con el archivo. R puede intentar extraer datos sin procesar del archivo, pero no será tan bueno para hacerlo como lo es Microsoft Excel. Ningún programa es mejor para convertir archivos de Excel que Excel. Del mismo modo, ningún programa es mejor para convertir archivos SAS Xport que SAS, y así sucesivamente. Sin embargo, es posible que se encuentre con un archivo específico del programa, pero no con el programa que lo creó. No querría comprar una licencia SAS de varios miles de dólares solo para abrir un archivo SAS. Afortunadamente, R puede abrir muchos tipos de archivos, incluidos archivos de otros programas y bases de datos. R incluso tiene sus propios formatos específicos del programa que pueden ayudarlo a ahorrar memoria y tiempo si sabe que trabajará completamente en R. Si desea obtener más información sobre todas sus opciones para cargar y guardar datos en R, consulte [Cargar y Guardar Datos en R]. Notación de R se basará en las habilidades que aprendió en este capítulo. Aquí, aprendió cómo almacenar datos en R. En Notación de R, aprenderá cómo acceder a los valores una vez que se han almacenado. También escribirá dos funciones que le permitirán comenzar a usar su mazo, una función para barajar y una función para repartir. "],["notación-de-r.html", "6 Notación de R 6.1 Selecting Values 6.2 Deal a Card 6.3 Shuffle the Deck 6.4 Dollar Signs and Double Brackets 6.5 Summary", " 6 Notación de R Now that you have a deck of cards, you need a way to do card-like things with it. First, you’ll want to reshuffle the deck from time to time. And next, you’ll want to deal cards from the deck (one card at a time, whatever card is on top—we’re not cheaters). To do these things, you’ll need to work with the individual values inside your data frame, a task essential to data science. For example, to deal a card from the top of your deck, you’ll need to write a function that selects the first row of values in your data frame, like this deal(deck) ## face suit value ## king spades 13 You can select values within an R object with R’s notation system. 6.1 Selecting Values R has a notation system that lets you extract values from R objects. To extract a value or set of values from a data frame, write the data frame’s name followed by a pair of hard brackets: deck[ , ] Between the brackets will go two indexes separated by a comma. The indexes tell R which values to return. R will use the first index to subset the rows of the data frame and the second index to subset the columns. You have a choice when it comes to writing indexes. There are six different ways to write an index for R, and each does something slightly different. They are all very simple and quite handy, so let’s take a look at each of them. You can create indexes with: Positive integers Negative integers Zero Blank spaces Logical values Names The simplest of these to use is positive integers. 6.1.1 Positive Integers R treats positive integers just like ij notation in linear algebra: deck[i,j] will return the value of deck that is in the ith row and the jth column, Figure 6.1. Notice that i and j only need to be integers in the mathematical sense. They can be saved as numerics in R head(deck) ## face suit value ## king spades 13 ## queen spades 12 ## jack spades 11 ## ten spades 10 ## nine spades 9 ## eight spades 8 deck[1, 1] ## &quot;king&quot; To extract more than one value, use a vector of positive integers. For example, you can return the first row of deck with deck[1, c(1, 2, 3)] or deck[1, 1:3]: deck[1, c(1, 2, 3)] ## face suit value ## king spades 13 R will return the values of deck that are in both the first row and the first, second, and third columns. Note that R won’t actually remove these values from deck. R will give you a new set of values which are copies of the original values. You can then save this new set to an R object with R’s assignment operator: new &lt;- deck[1, c(1, 2, 3)] new ## face suit value ## king spades 13 Repetition If you repeat a number in your index, R will return the corresponding value(s) more than once in your “subset.” This code will return the first row of deck twice: deck[c(1, 1), c(1, 2, 3)] ## face suit value ## king spades 13 ## king spades 13 Figure 6.1: R uses the ij notation system of linear algebra. The commands in this figure will return the shaded values. R’s notation system is not limited to data frames. You can use the same syntax to select values in any R object, as long as you supply one index for each dimension of the object. So, for example, you can subset a vector (which has one dimension) with a single index: vec &lt;- c(6, 1, 3, 6, 10, 5) vec[1:3] ## 6 1 3 Indexing begins at 1 In some programming languages, indexing begins with 0. This means that 0 returns the first element of a vector, 1 returns the second element, and so on. This isn’t the case with R. Indexing in R behaves just like indexing in linear algebra. The first element is always indexed by 1. Why is R different? Maybe because it was written for mathematicians. Those of us who learned indexing from a linear algebra course wonder why computers programmers start with 0. drop = FALSE If you select two or more columns from a data frame, R will return a new data frame: deck[1:2, 1:2] ## face suit ## king spades ## queen spades However, if you select a single column, R will return a vector: deck[1:2, 1] ## &quot;king&quot; &quot;queen&quot; If you would prefer a data frame instead, you can add the optional argument drop = FALSE between the brackets: deck[1:2, 1, drop = FALSE] ## face ## king ## queen This method also works for selecting a single column from a matrix or an array. 6.1.2 Negative Integers Negative integers do the exact opposite of positive integers when indexing. R will return every element except the elements in a negative index. For example, deck[-1, 1:3] will return everything but the first row of deck. deck[-(2:52), 1:3] will return the first row (and exclude everything else): deck[-(2:52), 1:3] ## face suit value ## king spades 13 Negative integers are a more efficient way to subset than positive integers if you want to include the majority of a data frame’s rows or columns. R will return an error if you try to pair a negative integer with a positive integer in the same index: deck[c(-1, 1), 1] ## Error in xj[i] : only 0&#39;s may be mixed with negative subscripts However, you can use both negative and positive integers to subset an object if you use them in different indexes (e.g., if you use one in the rows index and one in the columns index, like deck[-1, 1]). 6.1.3 Zero What would happen if you used zero as an index? Zero is neither a positive integer nor a negative integer, but R will still use it to do a type of subsetting. R will return nothing from a dimension when you use zero as an index. This creates an empty object: deck[0, 0] ## data frame with 0 columns and 0 rows To be honest, indexing with zero is not very helpful. 6.1.4 Blank Spaces You can use a blank space to tell R to extract every value in a dimension. This lets you subset an object on one dimension but not the others, which is useful for extracting entire rows or columns from a data frame: deck[1, ] ## face suit value ## king spades 13 6.1.5 Logical Values If you supply a vector of TRUEs and FALSEs as your index, R will match each TRUE and FALSE to a row in your data frame (or a column depending on where you place the index). R will then return each row that corresponds to a TRUE, Figure 6.2. It may help to imagine R reading through the data frame and asking, “Should I return the _i_th row of the data structure?” and then consulting the _i_th value of the index for its answer. For this system to work, your vector must be as long as the dimension you are trying to subset: deck[1, c(TRUE, TRUE, FALSE)] ## face suit ## king spades rows &lt;- c(TRUE, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F) deck[rows, ] ## face suit value ## king spades 13 Figure 6.2: You can use vectors of TRUEs and FALSEs to tell R exactly which values you want to extract and which you do not. The command would return just the numbers 1, 6, and 5. This system may seem odd—who wants to type so many TRUEs and FALSEs?—but it will become very powerful in Modifying Values. 6.1.6 Names Finally, you can ask for the elements you want by name—if your object has names (see Names). This is a common way to extract the columns of a data frame, since columns almost always have names: deck[1, c(&quot;face&quot;, &quot;suit&quot;, &quot;value&quot;)] ## face suit value ## king spades 13 # the entire value column deck[ , &quot;value&quot;] ## 13 12 11 10 9 8 7 6 5 4 3 2 1 13 12 11 10 9 8 ## 7 6 5 4 3 2 1 13 12 11 10 9 8 7 6 5 4 3 2 ## 1 13 12 11 10 9 8 7 6 5 4 3 2 1 6.2 Deal a Card Now that you know the basics of R’s notation system, let’s put it to use. Exercise 6.1 (Deal a Card) Complete the following code to make a function that returns the first row of a data frame: deal &lt;- function(cards) { # ? } Solution. You can use any of the systems that return the first row of your data frame to write a deal function. I’ll use positive integers and blanks because I think they are easy to understand: deal &lt;- function(cards) { cards[1, ] } The function does exactly what you want: it deals the top card from your data set. However, the function becomes less impressive if you run deal over and over again: deal(deck) ## face suit value ## king spades 13 deal(deck) ## face suit value ## king spades 13 deal(deck) ## face suit value ## king spades 13 deal always returns the king of spades because deck doesn’t know that we’ve dealt the card away. Hence, the king of spades stays where it is, at the top of the deck ready to be dealt again. This is a difficult problem to solve, and we will deal with it in Environments. In the meantime, you can fix the problem by shuffling your deck after every deal. Then a new card will always be at the top. Shuffling is a temporary compromise: the probabilities at play in your deck will not match the probabilities that occur when you play a game with a single deck of cards. For example, there will still be a probability that the king of spades appears twice in a row. However, things are not as bad as they may seem. Most casinos use five or six decks at a time in card games to prevent card counting. The probabilities that you would encounter in those situations are very close to the ones we will create here. 6.3 Shuffle the Deck When you shuffle a real deck of cards, you randomly rearrange the order of the cards. In your virtual deck, each card is a row in a data frame. To shuffle the deck, you need to randomly reorder the rows in the data frame. Can this be done? You bet! And you already know everything you need to do it. This may sound silly, but start by extracting every row in your data frame: deck2 &lt;- deck[1:52, ] head(deck2) ## face suit value ## king spades 13 ## queen spades 12 ## jack spades 11 ## ten spades 10 ## nine spades 9 ## eight spades 8 What do you get? A new data frame whose order hasn’t changed at all. What if you asked R to extract the rows in a different order? For example, you could ask for row 2, then row 1, and then the rest of the cards: deck3 &lt;- deck[c(2, 1, 3:52), ] head(deck3) ## face suit value ## queen spades 12 ## king spades 13 ## jack spades 11 ## ten spades 10 ## nine spades 9 ## eight spades 8 R complies. You’ll get all the rows back, and they’ll come in the order you ask for them. If you want the rows to come in a random order, then you need to sort the integers from 1 to 52 into a random order and use the results as a row index. How could you generate such a random collection of integers? With our friendly neighborhood sample function: random &lt;- sample(1:52, size = 52) random ## 35 28 39 9 18 29 26 45 47 48 23 22 21 16 32 38 1 15 20 ## 11 2 4 14 49 34 25 8 6 10 41 46 17 33 5 7 44 3 27 ## 50 12 51 40 52 24 19 13 42 37 43 36 31 30 deck4 &lt;- deck[random, ] head(deck4) ## face suit value ## five diamonds 5 ## queen diamonds 12 ## ace diamonds 1 ## five spades 5 ## nine clubs 9 ## jack diamonds 11 Now the new set is truly shuffled. You’ll be finished once you wrap these steps into a function. Exercise 6.2 (Shuffle a Deck) Use the preceding ideas to write a shuffle function. shuffle should take a data frame and return a shuffled copy of the data frame. Solution. Your shuffle function will look like the one that follows: shuffle &lt;- function(cards) { random &lt;- sample(1:52, size = 52) cards[random, ] } Nice work! Now you can shuffle your cards between each deal: deal(deck) ## face suit value ## king spades 13 deck2 &lt;- shuffle(deck) deal(deck2) ## face suit value ## jack clubs 11 6.4 Dollar Signs and Double Brackets Two types of object in R obey an optional second system of notation. You can extract values from data frames and lists with the $ syntax. You will encounter the $ syntax again and again as an R programmer, so let’s examine how it works. To select a column from a data frame, write the data frame’s name and the column name separated by a $. Notice that no quotes should go around the column name: deck$value ## 13 12 11 10 9 8 7 6 5 4 3 2 1 13 12 11 10 9 8 7 ## 6 5 4 3 2 1 13 12 11 10 9 8 7 6 5 4 3 2 1 13 ## 12 11 10 9 8 7 6 5 4 3 2 1 R will return all of the values in the column as a vector. This $ notation is incredibly useful because you will often store the variables of your data sets as columns in a data frame. From time to time, you’ll want to run a function like mean or median on the values in a variable. In R, these functions expect a vector of values as input, and deck$value delivers your data in just the right format: mean(deck$value) ## 7 median(deck$value) ## 7 You can use the same $ notation with the elements of a list, if they have names. This notation has an advantage with lists, too. If you subset a list in the usual way, R will return a new list that has the elements you requested. This is true even if you only request a single element. To see this, make a list: lst &lt;- list(numbers = c(1, 2), logical = TRUE, strings = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) lst ## $numbers ## [1] 1 2 ## $logical ## [1] TRUE ## $strings ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; And then subset it: lst[1] ## $numbers ## [1] 1 2 The result is a smaller list with one element. That element is the vector c(1, 2). This can be annoying because many R functions do not work with lists. For example, sum(lst[1]) will return an error. It would be horrible if once you stored a vector in a list, you could only ever get it back as a list: sum(lst[1]) ## Error in sum(lst[1]) : invalid &#39;type&#39; (list) of argument When you use the $ notation, R will return the selected values as they are, with no list structure around them: lst$numbers ## 1 2 You can then immediately feed the results to a function: sum(lst$numbers) ## 3 If the elements in your list do not have names (or you do not wish to use the names), you can use two brackets, instead of one, to subset the list. This notation will do the same thing as the $ notation: lst[[1]] ## 1 2 In other words, if you subset a list with single-bracket notation, R will return a smaller list. If you subset a list with double-bracket notation, R will return just the values that were inside an element of the list. You can combine this feature with any of R’s indexing methods: lst[&quot;numbers&quot;] ## $numbers ## [1] 1 2 lst[[&quot;numbers&quot;]] ## 1 2 This difference is subtle but important. In the R community, there is a popular, and helpful, way to think about it, Figure 6.3. Imagine that each list is a train and each element is a train car. When you use single brackets, R selects individual train cars and returns them as a new train. Each car keeps its contents, but those contents are still inside a train car (i.e., a list). When you use double brackets, R actually unloads the car and gives you back the contents. Figure 6.3: It can be helpful to think of your list as a train. Use single brackets to select train cars, double brackets to select the contents inside of a car. Never attach In R’s early days, it became popular to use attach() on a data set once you had it loaded. Don’t do this! attach recreates a computing environment similar to those used in other statistics applications like Stata and SPSS, which crossover users liked. However, R is not Stata or SPSS. R is optimized to use the R computing environment, and running attach() can cause confusion with some R functions. What does attach() do? On the surface, attach saves you typing. If you attach the deck data set, you can refer to each of its variables by name; instead of typing deck$face, you can just type face. But typing isn’t bad. It gives you a chance to be explicit, and in computer programming, explicit is good. Attaching a data set creates the possibility that R will confuse two variable names. If this occurs within a function, you’re likely to get unusable results and an unhelpful error message to explain what happened. Now that you are an expert at retrieving values stored in R, let’s summarize what you’ve accomplished. 6.5 Summary You have learned how to access values that have been stored in R. You can retrieve a copy of values that live inside a data frame and use the copies for new computations. In fact, you can use R’s notation system to access values in any R object. To use it, write the name of an object followed by brackets and indexes. If your object is one-dimensional, like a vector, you only need to supply one index. If it is two-dimensional, like a data frame, you need to supply two indexes separated by a comma. And, if it is n-dimensional, you need to supply n indexes, each separated by a comma. In Modifying Values, you’ll take this system a step further and learn how to change the actual values that are stored inside your data frame. This is all adding up to something special: complete control of your data. You can now store your data in your computer, retrieve individual values at will, and use your computer to perform correct calculations with those values. Does this sound basic? It may be, but it is also powerful and essential for efficient data science. You no longer need to memorize everything in your head, nor worry about doing mental arithmetic wrong. This low-level control over your data is also a prerequisite for more efficient R programs, the subject of Project 3: Slot Machine. "],["modify.html", "7 Modifying Values", " 7 Modifying Values Are you ready to play some games with your virtual deck? Not so fast! The point system in your deck of cards doesn’t align well with many card games. For example, in war and poker, aces are usually scored higher than kings. They’d have a point value of 14, not 1. In this task, you will change the point system of your deck three times to match three different games: war, hearts, and blackjack. Each of these games will teach you something different about modifying the values inside of a data set. Start by making a copy of deck that you can manipulate. This will ensure that you always have a pristine copy of deck to fall back on (should things go awry): deck2 &lt;- deck 7.0.1 Changing Values in Place You can use R’s notation system to modify values within an R object. First, describe the value (or values) you wish to modify. Then use the assignment operator &lt;- to overwrite those values. R will update the selected values in the original object. Let’s put this into action with a real example: vec &lt;- c(0, 0, 0, 0, 0, 0) vec ## 0 0 0 0 0 0 Here’s how you can select the first value of vec: vec[1] ## 0 And here is how you can modify it: vec[1] &lt;- 1000 vec ## 1000 0 0 0 0 0 You can replace multiple values at once as long as the number of new values equals the number of selected values: vec[c(1, 3, 5)] &lt;- c(1, 1, 1) vec ## 1 0 1 0 1 0 vec[4:6] &lt;- vec[4:6] + 1 vec ## 1 0 1 1 2 1 You can also create values that do not yet exist in your object. R will expand the object to accommodate the new values: vec[7] &lt;- 0 vec ## 1 0 1 1 2 1 0 This provides a great way to add new variables to your data set: deck2$new &lt;- 1:52 head(deck2) ## face suit value new ## king spades 13 1 ## queen spades 12 2 ## jack spades 11 3 ## ten spades 10 4 ## nine spades 9 5 ## eight spades 8 6 You can also remove columns from a data frame (and elements from a list) by assigning them the symbol NULL: deck2$new &lt;- NULL head(deck2) ## face suit value ## king spades 13 ## queen spades 12 ## jack spades 11 ## ten spades 10 ## nine spades 9 ## eight spades 8 In the game of war, aces are king (figuratively speaking). They receive the highest value of all the cards, which would be something like 14. Every other card gets the value that it already has in deck. To play war, you just need to change the values of your aces from 1 to 14. As long as you haven’t shuffled your deck, you know just where the aces are. They appear every 13 cards. Hence, you can describe them with R’s notation system: deck2[c(13, 26, 39, 52), ] ## face suit value ## ace spades 1 ## ace clubs 1 ## ace diamonds 1 ## ace hearts 1 You can single out just the values of the aces by subsetting the columns dimension of deck2. Or, even better, you can subset the column vector deck2$value: deck2[c(13, 26, 39, 52), 3] ## 1 1 1 1 deck2$value[c(13, 26, 39, 52)] ## 1 1 1 1 Now all you have to do is assign a new set of values to these old values. The set of new values will have to be the same size as the set of values that you are replacing. So you could save c(14, 14, 14, 14) into the ace values, or you could just save 14 and rely on R’s recycling rules to expand 14 to c(14, 14, 14, 14): deck2$value[c(13, 26, 39, 52)] &lt;- c(14, 14, 14, 14) # or deck2$value[c(13, 26, 39, 52)] &lt;- 14 Notice that the values change in place. You don’t end up with a modified copy of deck2; the new values will appear inside deck2: head(deck2, 13) ## face suit value ## king spades 13 ## queen spades 12 ## jack spades 11 ## ten spades 10 ## nine spades 9 ## eight spades 8 ## seven spades 7 ## six spades 6 ## five spades 5 ## four spades 4 ## three spades 3 ## two spades 2 ## ace spades 14 The same technique will work whether you store your data in a vector, matrix, array, list, or data frame. Just describe the values that you want to change with R’s notation system, then assign over those values with R’s assignment operator. Things worked very easily in this example because you knew exactly where each ace was. The cards were sorted in an orderly manner and an ace appeared every 13 rows. But what if the deck had been shuffled? You could look through all the cards and note the locations of the aces, but that would be tedious. If your data frame were larger, it might be impossible: deck3 &lt;- shuffle(deck) Where are the aces now? head(deck3) ## face suit value ## queen clubs 12 ## king clubs 13 ## ace spades 1 # an ace ## nine clubs 9 ## seven spades 7 ## queen diamonds 12 Why not ask R to find the aces for you? You can do this with logical subsetting. Logical subsetting provides a way to do targeted extraction and modification with R objects, a sort of search-and-destroy mission inside your own data sets. 7.0.2 Logical Subsetting Do you remember R’s logical index system, logicals? To recap, you can select values with a vector of TRUEs and FALSEs. The vector must be the same length as the dimension that you wish to subset. R will return every element that matches a TRUE: vec ## 1 0 1 1 2 1 0 vec[c(FALSE, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE)] ## 2 At first glance, this system might seem impractical. Who wants to type out long vectors of TRUEs and FALSEs? No one. But you don’t have to. You can let a logical test create a vector of TRUEs and FALSEs for you. 7.0.2.1 Logical Tests A logical test is a comparison like “is one less than two?”, 1 &lt; 2, or “is three greater than four?”, 3 &gt; 4. R provides seven logical operators that you can use to make comparisons, shown in Table 7.1. Table 7.1: R’s Logical Operators Operator Syntax Tests &gt; a &gt; b Is a greater than b? &gt;= a &gt;= b Is a greater than or equal to b? &lt; a &lt; b Is a less than b? &lt;= a &lt;= b Is a less than or equal to b? == a == b Is a equal to b? != a != b Is a not equal to b? %in% a %in% c(a, b, c) Is a in the group c(a, b, c)? Each operator returns a TRUE or a FALSE. If you use an operator to compare vectors, R will do element-wise comparisons—just like it does with the arithmetic operators: 1 &gt; 2 ## FALSE 1 &gt; c(0, 1, 2) ## TRUE FALSE FALSE c(1, 2, 3) == c(3, 2, 1) ## FALSE TRUE FALSE %in% is the only operator that does not do normal element-wise execution. %in% tests whether the value(s) on the left side are in the vector on the right side. If you provide a vector on the left side, %in% will not pair up the values on the left with the values on the right and then do element-wise tests. Instead, %in% will independently test whether each value on the left is somewhere in the vector on the right: 1 %in% c(3, 4, 5) ## FALSE c(1, 2) %in% c(3, 4, 5) ## FALSE FALSE c(1, 2, 3) %in% c(3, 4, 5) ## FALSE FALSE TRUE c(1, 2, 3, 4) %in% c(3, 4, 5) ## FALSE FALSE TRUE TRUE Notice that you test for equality with a double equals sign, ==, and not a single equals sign, =, which is another way to write &lt;-. It is easy to forget and use a = b to test if a equals b. Unfortunately, you’ll be in for a nasty surprise. R won’t return a TRUE or FALSE, because it won’t have to: a will equal b, because you just ran the equivalent of a &lt;- b. = is an assignment operator Be careful not to confuse = with ==. = does the same thing as &lt;-: it assigns a value to an object. You can compare any two R objects with a logical operator; however, logical operators make the most sense if you compare two objects of the same data type. If you compare objects of different data types, R will use its coercion rules to coerce the objects to the same type before it makes the comparison. Exercise 7.1 (How many Aces?) Extract the face column of deck2 and test whether each value is equal to ace. As a challenge, use R to quickly count how many cards are equal to ace. Solution. You can extract the face column with R’s $ notation: deck2$face ## &quot;king&quot; &quot;queen&quot; &quot;jack&quot; &quot;ten&quot; &quot;nine&quot; ## &quot;eight&quot; &quot;seven&quot; &quot;six&quot; &quot;five&quot; &quot;four&quot; ## &quot;three&quot; &quot;two&quot; &quot;ace&quot; &quot;king&quot; &quot;queen&quot; ## &quot;jack&quot; &quot;ten&quot; &quot;nine&quot; &quot;eight&quot; &quot;seven&quot; ## &quot;six&quot; &quot;five&quot; &quot;four&quot; &quot;three&quot; &quot;two&quot; ## &quot;ace&quot; &quot;king&quot; &quot;queen&quot; &quot;jack&quot; &quot;ten&quot; ## &quot;nine&quot; &quot;eight&quot; &quot;seven&quot; &quot;six&quot; &quot;five&quot; ## &quot;four&quot; &quot;three&quot; &quot;two&quot; &quot;ace&quot; &quot;king&quot; ## &quot;queen&quot; &quot;jack&quot; &quot;ten&quot; &quot;nine&quot; &quot;eight&quot; ## &quot;seven&quot; &quot;six&quot; &quot;five&quot; &quot;four&quot; &quot;three&quot; ## &quot;two&quot; &quot;ace&quot; Next, you can use the == operator to test whether each value is equal to ace. In the following code, R will use its recycling rules to indivuidually compare every value of deck2$face to \"ace\". Notice that the quotation marks are important. If you leave them out, R will try to find an object named ace to compare against deck2$face: deck2$face == &quot;ace&quot; ## FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## FALSE FALSE FALSE FALSE FALSE TRUE FALSE ## FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## FALSE FALSE FALSE FALSE TRUE FALSE FALSE ## FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## FALSE FALSE FALSE TRUE FALSE FALSE FALSE ## FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## FALSE FALSE TRUE You can use sum to quickly count the number of TRUEs in the previous vector. Remember that R will coerce logicals to numerics when you do math with them. R will turn TRUEs into ones and FALSEs into zeroes. As a result, sum will count the number of TRUEs: sum(deck2$face == &quot;ace&quot;) ## 4 You can use this method to spot and then change the aces in your deck—even if you’ve shuffled your cards. First, build a logical test that identifies the aces in your shuffled deck: deck3$face == &quot;ace&quot; Then use the test to single out the ace point values. Since the test returns a logical vector, you can use it as an index: deck3$value[deck3$face == &quot;ace&quot;] ## 1 1 1 1 Finally, use assignment to change the ace values in deck3: deck3$value[deck3$face == &quot;ace&quot;] &lt;- 14 head(deck3) ## face suit value ## queen clubs 12 ## king clubs 13 ## ace spades 14 # an ace ## nine clubs 9 ## seven spades 7 ## queen diamonds 12 To summarize, you can use a logical test to select values within an object. Logical subsetting is a powerful technique because it lets you quickly identify, extract, and modify individual values in your data set. When you work with logical subsetting, you do not need to know where in your data set a value exists. You only need to know how to describe the value with a logical test. Logical subsetting is one of the things R does best. In fact, logical subsetting is a key component of vectorized programming, a coding style that lets you write fast and efficient R code, which we will study in Speed. Let’s put logical subsetting to use with a new game: hearts. In hearts, every card has a value of zero: deck4 &lt;- deck deck4$value &lt;- 0 head(deck4, 13) ## face suit value ## king spades 0 ## queen spades 0 ## jack spades 0 ## ten spades 0 ## nine spades 0 ## eight spades 0 ## seven spades 0 ## six spades 0 ## five spades 0 ## four spades 0 ## three spades 0 ## two spades 0 ## ace spades 0 except cards in the suit of hearts and the queen of spades. Each card in the suit of hearts has a value of 1. Can you find these cards and replace their values? Give it a try. Exercise 7.2 (Score the Deck for Hearts) Assign a value of 1 to every card in deck4 that has a suit of hearts. Solution. To do this, first write a test that identifies cards in the hearts suit: deck4$suit == &quot;hearts&quot; ## FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## FALSE FALSE FALSE FALSE TRUE TRUE TRUE ## TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## TRUE TRUE TRUE Then use your test to select the values of these cards: deck4$value[deck4$suit == &quot;hearts&quot;] ## 0 0 0 0 0 0 0 0 0 0 0 0 0 Finally, assign a new number to these values: deck4$value[deck4$suit == &quot;hearts&quot;] &lt;- 1 Now all of your hearts cards have been updated: deck4$value[deck4$suit == &quot;hearts&quot;] ## 1 1 1 1 1 1 1 1 1 1 1 1 1 In hearts, the queen of spades has the most unusual value of all: she’s worth 13 points. It should be simple to change her value, but she’s surprisingly hard to find. You could find all of the queens: deck4[deck4$face == &quot;queen&quot;, ] ## face suit value ## queen spades 0 ## queen clubs 0 ## queen diamonds 0 ## queen hearts 1 But that’s three cards too many. On the other hand, you could find all of the cards in spades: deck4[deck4$suit == &quot;spades&quot;, ] ## face suit value ## king spades 0 ## queen spades 0 ## jack spades 0 ## ten spades 0 ## nine spades 0 ## eight spades 0 ## seven spades 0 ## six spades 0 ## five spades 0 ## four spades 0 ## three spades 0 ## two spades 0 ## ace spades 0 But that’s 12 cards too many. What you really want to find is all of the cards that have both a face value equal to queen and a suit value equal to spades. You can do that with a Boolean operator. Boolean operators combine multiple logical tests together into a single test. 7.0.2.2 Boolean Operators Boolean operators are things like and (&amp;) and or (|). They collapse the results of multiple logical tests into a single TRUE or FALSE. R has six boolean operators, shown in Table 7.2. Table 7.2: Boolean operators Operator Syntax Tests &amp; cond1 &amp; cond2 Are both cond1 and cond2 true? | cond1 | cond2 Is one or more of cond1 and cond2 true? xor xor(cond1, cond2) Is exactly one of cond1 and cond2 true? ! !cond1 Is cond1 false? (e.g., ! flips the results of a logical test) any any(cond1, cond2, cond3, ...) Are any of the conditions true? all all(cond1, cond2, cond3, ...) Are all of the conditions true? To use a Boolean operator, place it between two complete logical tests. R will execute each logical test and then use the Boolean operator to combine the results into a single TRUE or FALSE, Figure 7.1. The most common mistake with Boolean operators It is easy to forget to put a complete test on either side of a Boolean operator. In English, it is efficient to say “Is x greater than two and less than nine?” But in R, you need to write the equivalent of “Is x greater than two and is x less than nine?” This is shown in Figure 7.1. Figure 7.1: R will evaluate the expressions on each side of a Boolean operator separately, and then combine the results into a single TRUE or FALSE. If you do not supply a complete test to each side of the operator, R will return an error. When used with vectors, Boolean operators will follow the same element-wise execution as arithmetic and logical operators: a &lt;- c(1, 2, 3) b &lt;- c(1, 2, 3) c &lt;- c(1, 2, 4) a == b ## TRUE TRUE TRUE b == c ## TRUE TRUE FALSE a == b &amp; b == c ## TRUE TRUE FALSE Could you use a Boolean operator to locate the queen of spades in your deck? Of course you can. You want to test each card to see if it is both a queen and a spade. You can write this test in R with: deck4$face == &quot;queen&quot; &amp; deck4$suit == &quot;spades&quot; ## FALSE TRUE FALSE FALSE FALSE FALSE FALSE ## FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## FALSE FALSE FALSE I’ll save the results of this test to its own object. That will make the results easier to work with: queenOfSpades &lt;- deck4$face == &quot;queen&quot; &amp; deck4$suit == &quot;spades&quot; Next, you can use the test as an index to select the value of the queen of spades. Make sure the test actually selects the correct value: deck4[queenOfSpades, ] ## face suit value ## queen spades 0 deck4$value[queenOfSpades] ## 0 Now that you’ve found the queen of spades, you can update her value: deck4$value[queenOfSpades] &lt;- 13 deck4[queenOfSpades, ] ## face suit value ## queen spades 13 Your deck is now ready to play hearts. Exercise 7.3 (Practice with Tests) If you think you have the hang of logical tests, try converting these sentences into tests written with R code. To help you out, I’ve defined some R objects after the sentences that you can use to test your answers: Is w positive? Is x greater than 10 and less than 20? Is object y the word February? Is every value in z a day of the week? w &lt;- c(-1, 0, 1) x &lt;- c(5, 15) y &lt;- &quot;February&quot; z &lt;- c(&quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Friday&quot;) Solution. Here are some model answers. If you got stuck, be sure to re-read how R evaluates logical tests that use Boolean values: w &gt; 0 10 &lt; x &amp; x &lt; 20 y == &quot;February&quot; all(z %in% c(&quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;, &quot;Sunday&quot;)) Let’s consider one last game, blackjack. In blackjack, each number card has a value equal to its face value. Each face card (king, queen, or jack) has a value of 10. Finally, each ace has a value of 11 or 1, depending on the final results of the game. Let’s begin with a fresh copy of deck—that way the number cards (two through ten) will start off with the correct value: deck5 &lt;- deck head(deck5, 13) ## king spades 13 ## queen spades 12 ## jack spades 11 ## ten spades 10 ## nine spades 9 ## eight spades 8 ## seven spades 7 ## six spades 6 ## five spades 5 ## four spades 4 ## three spades 3 ## two spades 2 ## ace spades 1 You can change the value of the face cards in one fell swoop with %in%: facecard &lt;- deck5$face %in% c(&quot;king&quot;, &quot;queen&quot;, &quot;jack&quot;) deck5[facecard, ] ## face suit value ## king spades 13 ## queen spades 12 ## jack spades 11 ## king clubs 13 ## queen clubs 12 ## jack clubs 11 ## king diamonds 13 ## queen diamonds 12 ## jack diamonds 11 ## king hearts 13 ## queen hearts 12 ## jack hearts 11 deck5$value[facecard] &lt;- 10 head(deck5, 13) ## face suit value ## king spades 10 ## queen spades 10 ## jack spades 10 ## ten spades 10 ## nine spades 9 ## eight spades 8 ## seven spades 7 ## six spades 6 ## five spades 5 ## four spades 4 ## three spades 3 ## two spades 2 ## ace spades 1 Now you just need to fix the ace values—or do you? It is hard to decide what value to give the aces because their exact value will change from hand to hand. At the end of each hand, an ace will equal 11 if the sum of the player’s cards does not exceed 21. Otherwise, the ace will equal 1. The actual value of the ace will depend on the other cards in the player’s hand. This is a case of missing information. At the moment, you do not have enough information to assign a correct point value to the ace cards. 7.0.3 Missing Information Missing information problems happen frequently in data science. Usually, they are more straightforward: you don’t know a value because the measurement was lost, corrupted, or never taken to begin with. R has a way to help you manage these missing values. The NA character is a special symbol in R. It stands for “not available” and can be used as a placeholder for missing information. R will treat NA exactly as you should want missing information treated. For example, what result would you expect if you add 1 to a piece of missing information? 1 + NA ## NA R will return a second piece of missing information. It would not be correct to say that 1 + NA = 1 because there is a good chance that the missing quantity is not zero. You do not have enough information to determine the result. What if you tested whether a piece of missing information is equal to 1? NA == 1 ## NA Again, your answer would be something like “I do not know if this is equal to one,” that is, NA. Generally, NAs will propagate whenever you use them in an R operation or function. This can save you from making errors based on missing data. 7.0.3.1 na.rm Missing values can help you work around holes in your data sets, but they can also create some frustrating problems. Suppose, for example, that you’ve collected 1,000 pass:[observations] and wish to take their average with R’s mean function. If even one of the values is NA, your result will be NA: c(NA, 1:50) ## NA 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ## 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ## 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 mean(c(NA, 1:50)) ## NA Understandably, you may prefer a different behavior. Most R functions come with the optional argument, na.rm, which stands for NA remove. R will ignore NAs when it evaluates a function if you add the argument na.rm = TRUE: mean(c(NA, 1:50), na.rm = TRUE) ## 25.5 7.0.3.2 is.na On occasion, you may want to identify the NAs in your data set with a logical test, but that too creates a problem. How would you go about it? If something is a missing value, any logical test that uses it will return a missing value, even this test: NA == NA ## NA Which means that tests like this won’t help you find missing values: c(1, 2, 3, NA) == NA ## NA NA NA NA But don’t worry too hard; R supplies a special function that can test whether a value is an NA. The function is sensibly named is.na: is.na(NA) ## TRUE vec &lt;- c(1, 2, 3, NA) is.na(vec) ## FALSE FALSE FALSE TRUE Let’s set all of your ace values to NA. This will accomplish two things. First, it will remind you that you do not know the final value of each ace. Second, it will prevent you from accidentally scoring a hand that has an ace before you determine the ace’s final value. You can set your ace values to NA in the same way that you would set them to a number: deck5$value[deck5$face == &quot;ace&quot;] &lt;- NA head(deck5, 13) ## face suit value ## king spades 10 ## queen spades 10 ## jack spades 10 ## ten spades 10 ## nine spades 9 ## eight spades 8 ## seven spades 7 ## six spades 6 ## five spades 5 ## four spades 4 ## three spades 3 ## two spades 2 ## ace spades NA Congratulations. Your deck is now ready for a game of blackjack. 7.0.4 Summary You can modify values in place inside an R object when you combine R’s notation syntax with the assignment operator, &lt;-. This lets you update your data and clean your data sets When you work with large data sets, modifying and retrieving values creates a logistical problem of its own. How can you search through the data to find the values that you want to modify or retrieve? As an R user, you can do this with logical subsetting. Create a logical test with logical and Boolean operators and then use the test as an index in R’s bracket notation. R will return the values that you are looking for, even if you do not know where they are. Retrieving individual values will not be your only concern as an R programmer. You’ll also need to retrieve entire data sets themselves; for example, you may call one in a function. Environments will teach you how R looks up and saves data sets and other R objects in its environment system. You’ll then use this knowledge to fix the deal and shuffle functions. "],["environments.html", "8 Environments 8.1 Environments 8.2 Working with Environments 8.3 Scoping Rules 8.4 Assignment 8.5 Evaluation 8.6 Closures 8.7 Summary 8.8 Project 2 Wrap-up", " 8 Environments Your deck is now ready for a game of blackjack (or hearts or war), but are your shuffle and deal functions up to snuff? Definitely not. For example, deal deals the same card over and over again: deal(deck) ## face suit value ## king spades 13 deal(deck) ## face suit value ## king spades 13 deal(deck) ## face suit value ## king spades 13 And the shuffle function doesn’t actually shuffle deck (it returns a copy of deck that has been shuffled). In short, both of these functions use deck, but neither manipulates deck—and we would like them to. To fix these functions, you will need to learn how R stores, looks up, and manipulates objects like deck. R does all of these things with the help of an environment system. 8.1 Environments Consider for a moment how your computer stores files. Every file is saved in a folder, and each folder is saved in another folder, which forms a hierarchical file system. If your computer wants to open up a file, it must first look up the file in this file system. You can see your file system by opening a finder window. For example, Figure 8.1 shows part of the file system on my computer. I have tons of folders. Inside one of them is a subfolder named Documents, inside of that subfolder is a sub-subfolder named ggsubplot, inside of that folder is a folder named inst, inside of that is a folder named doc, and inside of that is a file named manual.pdf. Figure 8.1: Your computer arranges files into a hierarchy of folders and subfolders. To look at a file, you need to find where it is saved in the file system. R uses a similar system to save R objects. Each object is saved inside of an environment, a list-like object that resembles a folder on your computer. Each environment is connected to a parent environment, a higher-level environment, which creates a hierarchy of environments. You can see R’s environment system with the parenvs function in the pryr package (note parenvs came in the pryr package when this book was first published). parenvs(all = TRUE) will return a list of the environments that your R session is using. The actual output will vary from session to session depending on which packages you have loaded. Here’s the output from my current session: library(pryr) parenvs(all = TRUE) ## label name ## 1 &lt;environment: R_GlobalEnv&gt; &quot;&quot; ## 2 &lt;environment: package:pryr&gt; &quot;package:pryr&quot; ## 3 &lt;environment: 0x7fff3321c388&gt; &quot;tools:rstudio&quot; ## 4 &lt;environment: package:stats&gt; &quot;package:stats&quot; ## 5 &lt;environment: package:graphics&gt; &quot;package:graphics&quot; ## 6 &lt;environment: package:grDevices&gt; &quot;package:grDevices&quot; ## 7 &lt;environment: package:utils&gt; &quot;package:utils&quot; ## 8 &lt;environment: package:datasets&gt; &quot;package:datasets&quot; ## 9 &lt;environment: package:methods&gt; &quot;package:methods&quot; ## 10 &lt;environment: 0x7fff3193dab0&gt; &quot;Autoloads&quot; ## 11 &lt;environment: base&gt; &quot;&quot; ## 12 &lt;environment: R_EmptyEnv&gt; &quot;&quot; It takes some imagination to interpret this output, so let’s visualize the environments as a system of folders, Figure 8.2. You can think of the environment tree like this. The lowest-level environment is named R_GlobalEnv and is saved inside an environment named package:pryr, which is saved inside the environment named 0x7fff3321c388, and so on, until you get to the final, highest-level environment, R_EmptyEnv. R_EmptyEnv is the only R environment that does not have a parent environment. Figure 8.2: R stores R objects in an environment tree that resembles your computer’s folder system. Remember that this example is just a metaphor. R’s environments exist in your RAM memory, and not in your file system. Also, R environments aren’t technically saved inside one another. Each environment is connected to a parent environment, which makes it easy to search up R’s environment tree. But this connection is one-way: there’s no way to look at one environment and tell what its “children” are. So you cannot search down R’s environment tree. In other ways, though, R’s environment system works similar to a file system. 8.2 Working with Environments R comes with some helper functions that you can use to explore your environment tree. First, you can refer to any of the environments in your tree with as.environment. as.environment takes an environment name (as a character string) and returns the corresponding environment: as.environment(&quot;package:stats&quot;) ## &lt;environment: package:stats&gt; ## attr(,&quot;name&quot;) ## [1] &quot;package:stats&quot; ## attr(,&quot;path&quot;) ## [1] &quot;/Library/Frameworks/R.framework/Versions/3.0/Resources/library/stats&quot; Three environments in your tree also come with their own accessor functions. These are the global environment (R_GlobalEnv), the base environment (base), and the empty environment (R_EmptyEnv). You can refer to them with: globalenv() ## &lt;environment: R_GlobalEnv&gt; baseenv() ## &lt;environment: base&gt; emptyenv() ##&lt;environment: R_EmptyEnv&gt; Next, you can look up an environment’s parent with parent.env: parent.env(globalenv()) ## &lt;environment: package:pryr&gt; ## attr(,&quot;name&quot;) ## [1] &quot;package:pryr&quot; ## attr(,&quot;path&quot;) ## [1] &quot;/Library/Frameworks/R.framework/Versions/3.0/Resources/library/pryr&quot; Notice that the empty environment is the only R environment without a parent: parent.env(emptyenv()) ## Error in parent.env(emptyenv()) : the empty environment has no parent You can view the objects saved in an environment with ls or ls.str. ls will return just the object names, but ls.str will display a little about each object’s structure: ls(emptyenv()) ## character(0) ls(globalenv()) ## &quot;deal&quot; &quot;deck&quot; &quot;deck2&quot; &quot;deck3&quot; &quot;deck4&quot; &quot;deck5&quot; ## &quot;die&quot; &quot;gender&quot; &quot;hand&quot; &quot;lst&quot; &quot;mat&quot; &quot;mil&quot; ## &quot;new&quot; &quot;now&quot; &quot;shuffle&quot; &quot;vec&quot; The empty environment is—not surprisingly—empty; the base environment has too many objects to list here; and the global environment has some familiar faces. It is where R has saved all of the objects that you’ve created so far. RStudio’s environment pane displays all of the objects in your global environment. You can use R’s $ syntax to access an object in a specific environment. For example, you can access deck from the global environment: head(globalenv()$deck, 3) ## face suit value ## king spades 13 ## queen spades 12 ## jack spades 11 And you can use the assign function to save an object into a particular environment. First give assign the name of the new object (as a character string). Then give assign the value of the new object, and finally the environment to save the object in: assign(&quot;new&quot;, &quot;Hello Global&quot;, envir = globalenv()) globalenv()$new ## &quot;Hello Global&quot; Notice that assign works similar to &lt;-. If an object already exists with the given name in the given environment, assign will overwrite it without asking for permission. This makes assign useful for updating objects but creates the potential for heartache. Now that you can explore R’s environment tree, let’s examine how R uses it. R works closely with the environment tree to look up objects, store objects, and evaluate functions. How R does each of these tasks will depend on the current active environment. 8.2.1 The Active Environment At any moment of time, R is working closely with a single environment. R will store new objects in this environment (if you create any), and R will use this environment as a starting point to look up existing objects (if you call any). I’ll call this special environment the active environment. The active environment is usually the global environment, but this may change when you run a function. You can use environment to see the current active environment: environment() &lt;environment: R_GlobalEnv&gt; The global environment plays a special role in R. It is the active environment for every command that you run at the command line. As a result, any object that you create at the command line will be saved in the global environment. You can think of the global environment as your user workspace. When you call an object at the command line, R will look for it first in the global environment. But what if the object is not there? In that case, R will follow a series of rules to look up the object. 8.3 Scoping Rules R follows a special set of rules to look up objects. These rules are known as R’s scoping rules, and you’ve already met a couple of them: R looks for objects in the current active environment. When you work at the command line, the active environment is the global environment. Hence, R looks up objects that you call at the command line in the global environment. Here is a third rule that explains how R finds objects that are not in the active environment When R does not find an object in an environment, R looks in the environment’s parent environment, then the parent of the parent, and so on, until R finds the object or reaches the empty environment. So, if you call an object at the command line, R will look for it in the global environment. If R can’t find it there, R will look in the parent of the global environment, and then the parent of the parent, and so on, working its way up the environment tree until it finds the object, as in Figure 8.3. If R cannot find the object in any environment, it will return an error that says the object is not found. Figure 8.3: R will search for an object by name in the active environment, here the global environment. If R does not find the object there, it will search in the active environment’s parent, and then the parent’s parent, and so on until R finds the object or runs out of environments. Remember that functions are a type of object in R. R will store and look up functions the same way it stores and looks up other objects, by searching for them by name in the environment tree. 8.4 Assignment When you assign a value to an object, R saves the value in the active environment under the object’s name. If an object with the same name already exists in the active environment, R will overwrite it. For example, an object named new exists in the global environment: new ## &quot;Hello Global&quot; You can save a new object named new to the global environment with this command. R will overwrite the old object as a result: new &lt;- &quot;Hello Active&quot; new ## &quot;Hello Active&quot; This arrangement creates a quandary for R whenever R runs a function. Many functions save temporary objects that help them do their jobs. For example, the roll function from [Project 1: Weighted Dice] saved an object named die and an object named dice: roll &lt;- function() { die &lt;- 1:6 dice &lt;- sample(die, size = 2, replace = TRUE) sum(dice) } R must save these temporary objects in the active environment; but if R does that, it may overwrite existing objects. Function authors cannot guess ahead of time which names may already exist in your active environment. How does R avoid this risk? Every time R runs a function, it creates a new active environment to evaluate the function in. 8.5 Evaluation R creates a new environment each time it evaluates a function. R will use the new environment as the active environment while it runs the function, and then R will return to the environment that you called the function from, bringing the function’s result with it. Let’s call these new environments runtime environments because R creates them at runtime to evaluate functions. We’ll use the following function to explore R’s runtime environments. We want to know what the environments look like: what are their parent environments, and what objects do they contain? show_env is designed to tell us: show_env &lt;- function(){ list(ran.in = environment(), parent = parent.env(environment()), objects = ls.str(environment())) } show_env is itself a function, so when we call show_env(), R will create a runtime environment to evaluate the function in. The results of show_env will tell us the name of the runtime environment, its parent, and which objects the runtime environment contains: show_env() ## $ran.in ## &lt;environment: 0x7ff711d12e28&gt; ## ## $parent ## &lt;environment: R_GlobalEnv&gt; ## ## $objects The results reveal that R created a new environment named 0x7ff711d12e28 to run show_env() in. The environment had no objects in it, and its parent was the global environment. So for purposes of running show_env, R’s environment tree looked like Figure 8.4. Let’s run show_env again: show_env() ## $ran.in ## &lt;environment: 0x7ff715f49808&gt; ## ## $parent ## &lt;environment: R_GlobalEnv&gt; ## ## $objects This time show_env ran in a new environment, 0x7ff715f49808. R creates a new environment each time you run a function. The 0x7ff715f49808 environment looks exactly the same as 0x7ff711d12e28. It is empty and has the same global environment as its parent. Figure 8.4: R creates a new environment to run show_env in. The environment is a child of the global environment. Now let’s consider which environment R will use as the parent of the runtime environment. R will connect a function’s runtime environment to the environment that the function was first created in. This environment plays an important role in the function’s life—because all of the function’s runtime environments will use it as a parent. Let’s call this environment the origin environment. You can look up a function’s origin environment by running environment on the function: environment(show_env) ## &lt;environment: R_GlobalEnv&gt; The origin environment of show_env is the global environment because we created show_env at the command line, but the origin environment does not need to be the global environment. For example, the environment of parenvs is the pryr package: environment(parenvs) ## &lt;environment: namespace:pryr&gt; In other words, the parent of a runtime environment will not always be the global environment; it will be whichever environment the function was first created in. Finally, let’s look at the objects contained in a runtime environment. At the moment, show_env’s runtime environments do not contain any objects, but that is easy to fix. Just have show_env create some objects in its body of code. R will store any objects created by show_env in its runtime environment. Why? Because the runtime environment will be the active environment when those objects are created: show_env &lt;- function(){ a &lt;- 1 b &lt;- 2 c &lt;- 3 list(ran.in = environment(), parent = parent.env(environment()), objects = ls.str(environment())) } This time when we run show_env, R stores a, b, and c in the runtime environment: show_env() ## $ran.in ## &lt;environment: 0x7ff712312cd0&gt; ## ## $parent ## &lt;environment: R_GlobalEnv&gt; ## ## $objects ## a : num 1 ## b : num 2 ## c : num 3 This is how R ensures that a function does not overwrite anything that it shouldn’t. Any objects created by the function are stored in a safe, out-of-the-way runtime environment. R will also put a second type of object in a runtime environment. If a function has arguments, R will copy over each argument to the runtime environment. The argument will appear as an object that has the name of the argument but the value of whatever input the user provided for the argument. This ensures that a function will be able to find and use each of its arguments: foo &lt;- &quot;take me to your runtime&quot; show_env &lt;- function(x = foo){ list(ran.in = environment(), parent = parent.env(environment()), objects = ls.str(environment())) } show_env() ## $ran.in ## &lt;environment: 0x7ff712398958&gt; ## ## $parent ## &lt;environment: R_GlobalEnv&gt; ## ## $objects ## x : chr &quot;take me to your runtime&quot; Let’s put this all together to see how R evaluates a function. Before you call a function, R is working in an active environment; let’s call this the calling environment. It is the environment R calls the function from. Then you call the function. R responds by setting up a new runtime environment. This environment will be a child of the function’s origin enviornment. R will copy each of the function’s arguments into the runtime environment and then make the runtime environment the new active environment. Next, R runs the code in the body of the function. If the code creates any objects, R stores them in the active, that is, runtime environment. If the code calls any objects, R uses its scoping rules to look them up. R will search the runtime environment, then the parent of the runtime environment (which will be the origin environment), then the parent of the origin environment, and so on. Notice that the calling environment might not be on the search path. Usually, a function will only call its arguments, which R can find in the active runtime environment. Finally, R finishes running the function. It switches the active environment back to the calling environment. Now R executes any other commands in the line of code that called the function. So if you save the result of the function to an object with &lt;-, the new object will be stored in the calling environment. To recap, R stores its objects in an environment system. At any moment of time, R is working closely with a single active environment. It stores new objects in this environment, and it uses the environment as a starting point when it searches for existing objects. R’s active environment is usually the global environment, but R will adjust the active environment to do things like run functions in a safe manner. How can you use this knowledge to fix the deal and shuffle functions? First, let’s start with a warm-up question. Suppose I redefine deal at the command line like this: deal &lt;- function() { deck[1, ] } Notice that deal no longer takes an argument, and it calls the deck object, which lives in the global environment. Exercise 8.1 (Will deal work?) Will R be able to find deck and return an answer when I call the new version of deal, such as deal()? Solution. Yes. deal will still work the same as before. R will run deal in a runtime environment that is a child of the global environment. Why will it be a child of the global environment? Because the global environment is the origin environment of deal (we defined deal in the global environment): environment(deal) ## &lt;environment: R_GlobalEnv&gt; When deal calls deck, R will need to look up the deck object. R’s scoping rules will lead it to the version of deck in the global environment, as in Figure 8.5. deal works as expected as a result: deal() ## face suit value ## king spades 13 Figure 8.5: R finds deck by looking in the parent of deal’s runtime environment. The parent is the global environment, deal’s origin environment. Here, R finds the copy of deck. Now let’s fix the deal function to remove the cards it has dealt from deck. Recall that deal returns the top card of deck but does not remove the card from the deck. As a result, deal always returns the same card: deal() ## face suit value ## king spades 13 deal() ## face suit value ## king spades 13 You know enough R syntax to remove the top card of deck. The following code will save a prisitine copy of deck and then remove the top card: DECK &lt;- deck deck &lt;- deck[-1, ] head(deck, 3) ## face suit value ## queen spades 12 ## jack spades 11 ## ten spades 10 Now let’s add the code to deal. Here deal saves (and then returns) the top card of deck. In between, it removes the card from deck…or does it? deal &lt;- function() { card &lt;- deck[1, ] deck &lt;- deck[-1, ] card } This code won’t work because R will be in a runtime environment when it executes deck &lt;- deck[-1, ]. Instead of overwriting the global copy of deck with deck[-1, ], deal will just create a slightly altered copy of deck in its runtime environment, as in Figure 8.6. Figure 8.6: The deal function looks up deck in the global environment but saves deck[-1, ] in the runtime environment as a new object named deck. Exercise 8.2 (Overwrite deck) Rewrite the deck &lt;- deck[-1, ] line of deal to assign deck[-1, ] to an object named deck in the global environment. Hint: consider the assign function. Solution. You can assign an object to a specific environment with the assign function: deal &lt;- function() { card &lt;- deck[1, ] assign(&quot;deck&quot;, deck[-1, ], envir = globalenv()) card } Now deal will finally clean up the global copy of deck, and we can deal cards just as we would in real life: deal() ## face suit value ## queen spades 12 deal() ## face suit value ## jack spades 11 deal() ## face suit value ## ten spades 10 Let’s turn our attention to the shuffle function: shuffle &lt;- function(cards) { random &lt;- sample(1:52, size = 52) cards[random, ] } shuffle(deck) doesn’t shuffle the deck object; it returns a shuffled copy of the deck object: head(deck, 3) ## face suit value ## nine spades 9 ## eight spades 8 ## seven spades 7 a &lt;- shuffle(deck) head(deck, 3) ## face suit value ## nine spades 9 ## eight spades 8 ## seven spades 7 head(a, 3) ## face suit value ## ace diamonds 1 ## seven clubs 7 ## two clubs 2 This behavior is now undesirable in two ways. First, shuffle fails to shuffle deck. Second, shuffle returns a copy of deck, which may be missing the cards that have been dealt away. It would be better if shuffle returned the dealt cards to the deck and then shuffled. This is what happens when you shuffle a deck of cards in real life. Exercise 8.3 (Rewrite shuffle) Rewrite shuffle so that it replaces the copy of deck that lives in the global environment with a shuffled version of DECK, the intact copy of deck that also lives in the global environment. The new version of shuffle should have no arguments and return no output. Solution. You can update shuffle in the same way that you updated deck. The following version will do the job: shuffle &lt;- function(){ random &lt;- sample(1:52, size = 52) assign(&quot;deck&quot;, DECK[random, ], envir = globalenv()) } Since DECK lives in the global environment, shuffle’s environment of origin, shuffle will be able to find DECK at runtime. R will search for DECK first in shuffle’s runtime environment, and then in shuffle’s origin environment—the global environment—which is where DECK is stored. The second line of shuffle will create a reordered copy of DECK and save it as deck in the global environment. This will overwrite the previous, nonshuffled version of deck. 8.6 Closures Our system finally works. For example, you can shuffle the cards and then deal a hand of blackjack: shuffle() deal() ## face suit value ## queen hearts 12 deal() ## face suit value ## eight hearts 8 But the system requires deck and DECK to exist in the global environment. Lots of things happen in this environment, and it is possible that deck may get modified or erased by accident. It would be better if we could store deck in a safe, out-of-the-way place, like one of those safe, out-of-the-way environments that R creates to run functions in. In fact, storing deck in a runtime environment is not such a bad idea. You could create a function that takes deck as an argument and saves a copy of deck as DECK. The function could also save its own copies of deal and shuffle: setup &lt;- function(deck) { DECK &lt;- deck DEAL &lt;- function() { card &lt;- deck[1, ] assign(&quot;deck&quot;, deck[-1, ], envir = globalenv()) card } SHUFFLE &lt;- function(){ random &lt;- sample(1:52, size = 52) assign(&quot;deck&quot;, DECK[random, ], envir = globalenv()) } } When you run setup, R will create a runtime environment to store these objects in. The environment will look like Figure 8.7. Now all of these things are safely out of the way in a child of the global environment. That makes them safe but hard to use. Let’s ask setup to return DEAL and SHUFFLE so we can use them. The best way to do this is to return the functions as a list: setup &lt;- function(deck) { DECK &lt;- deck DEAL &lt;- function() { card &lt;- deck[1, ] assign(&quot;deck&quot;, deck[-1, ], envir = globalenv()) card } SHUFFLE &lt;- function(){ random &lt;- sample(1:52, size = 52) assign(&quot;deck&quot;, DECK[random, ], envir = globalenv()) } list(deal = DEAL, shuffle = SHUFFLE) } cards &lt;- setup(deck) Figure 8.7: Running setup will store deck and DECK in an out-of-the-way place, and create a DEAL and SHUFFLE function. Each of these objects will be stored in an environment whose parent is the global environment. Then you can save each of the elements of the list to a dedicated object in the global environment: deal &lt;- cards$deal shuffle &lt;- cards$shuffle Now you can run deal and shuffle just as before. Each object contains the same code as the original deal and shuffle: deal ## function() { ## card &lt;- deck[1, ] ## assign(&quot;deck&quot;, deck[-1, ], envir = globalenv()) ## card ## } ## &lt;environment: 0x7ff7169c3390&gt; shuffle ## function(){ ## random &lt;- sample(1:52, size = 52) ## assign(&quot;deck&quot;, DECK[random, ], envir = globalenv()) ## } ## &lt;environment: 0x7ff7169c3390&gt; However, the functions now have one important difference. Their origin environment is no longer the global environment (although deal and shuffle are currently saved there). Their origin environment is the runtime environment that R made when you ran setup. That’s where R created DEAL and SHUFFLE, the functions copied into the new deal and shuffle, as shown in: environment(deal) ## &lt;environment: 0x7ff7169c3390&gt; environment(shuffle) ## &lt;environment: 0x7ff7169c3390&gt; Why does this matter? Because now when you run deal or shuffle, R will evaluate the functions in a runtime environment that uses 0x7ff7169c3390 as its parent. DECK and deck will be in this parent environment, which means that deal and shuffle will be able to find them at runtime. DECK and deck will be in the functions’ search path but still out of the way in every other respect, as shown in Figure 8.8. Figure 8.8: Now deal and shuffle will be run in an environment that has the protected deck and DECK in its search path. This arrangement is called a closure. setup’s runtime environment “encloses” the deal and shuffle functions. Both deal and shuffle can work closely with the objects contained in the enclosing environment, but almost nothing else can. The enclosing environment is not on the search path for any other R function or environment. You may have noticed that deal and shuffle still update the deck object in the global environment. Don’t worry, we’re about to change that. We want deal and shuffle to work exclusively with the objects in the parent (enclosing) environment of their runtime environments. Instead of having each function reference the global environment to update deck, you can have them reference their parent environment at runtime, as shown in Figure 8.9: setup &lt;- function(deck) { DECK &lt;- deck DEAL &lt;- function() { card &lt;- deck[1, ] assign(&quot;deck&quot;, deck[-1, ], envir = parent.env(environment())) card } SHUFFLE &lt;- function(){ random &lt;- sample(1:52, size = 52) assign(&quot;deck&quot;, DECK[random, ], envir = parent.env(environment())) } list(deal = DEAL, shuffle = SHUFFLE) } cards &lt;- setup(deck) deal &lt;- cards$deal shuffle &lt;- cards$shuffle Figure 8.9: When you change your code, deal and shuffle will go from updating the global environment (left) to updating their parent environment (right). We finally have a self-contained card game. You can delete (or modify) the global copy of deck as much as you want and still play cards. deal and shuffle will use the pristine, protected copy of deck: rm(deck) shuffle() deal() ## face suit value ## ace hearts 1 deal() ## face suit value ## jack clubs 11 Blackjack! 8.7 Summary R saves its objects in an environment system that resembles your computer’s file system. If you understand this system, you can predict how R will look up objects. If you call an object at the command line, R will look for the object in the global environment and then the parents of the global environment, working its way up the environment tree one environment at a time. R will use a slightly different search path when you call an object from inside of a function. When you run a function, R creates a new environment to execute commands in. This environment will be a child of the environment where the function was originally defined. This may be the global environment, but it also may not be. You can use this behavior to create closures, which are functions linked to objects in protected environments. As you become familiar with R’s environment system, you can use it to produce elegant results, like we did here. However, the real value of understanding the environment system comes from knowing how R functions do their job. You can use this knowledge to figure out what is going wrong when a function does not perform as expected. 8.8 Project 2 Wrap-up You now have full control over the data sets and values that you load into R. You can store data as R objects, you can retrieve and manipulate data values at will, and you can even predict how R will store and look up your objects in your computer’s memory. You may not realize it yet, but your expertise makes you a powerful, computer-augmented data user. You can use R to save and work with larger data sets than you could otherwise handle. So far we’ve only worked with deck, a small data set; but you can use the same techniques to work with any data set that fits in your computer’s memory. However, storing data is not the only logistical task that you will face as a data scientist. You will often want to do tasks with your data that are so complex or repetitive that they are difficult to do without a computer. Some of the things can be done with functions that already exist in R and its packages, but others cannot. You will be the most versatile as a data scientist if you can write your own programs for computers to follow. R can help you do this. When you are ready, Project 3: Slot Machine will teach you the most useful skills for writing programs in R. "],["slots.html", "9 Project 3: Slot Machine", " 9 Project 3: Slot Machine Slot machines are the most popular game in modern casinos. If you’ve never seen one, a slot machine resembles an arcade game that has a lever on its side. For a small fee you can pull the lever, and the machine will generate a random combination of three symbols. If the correct combination appears, you can win a prize, maybe even the jackpot. Slot machines make fantastic profits for casinos because they offer a very low payout rate. In many games, such as Blackjack and Roulette, the odds are only slightly stacked in the casino’s favor. In the long run, the casino pays back 97 to 98 cents in prizes of every dollar that a gambler spends on these games. With slot machines, it is typical for a casino to only pay back 90 to 95 cents—and the casino keeps the rest. If this seems underhanded, keep in mind that slot machines are one of the most popular games at a casino; few people seem to mind. And if you consider that state lotteries have payout rates that are much closer to 50 cents on the dollar, slot machines don’t look that bad. In this project, you will build a real, working slot machine modeled after some real life Video Lottery Terminals from Manitoba, Canada. The terminals were a source of scandal in the 1990s. You’ll get to the bottom of this scandal by writing a program that recreates the slot machines. You’ll then do some calculations and run some simulations that reveal the true payout rate of the machines. This project will teach you how to write programs and run simulations in R. You will also learn how to: Use a practical strategy to design programs Use if and else statements to tell R what to do when Create lookup tables to find values Use for, while, and repeat loops to automate repetitive operations Use S3 methods, R’s version of Object-Oriented Programming Measure the speed of R code Write fast, vectorized R code "],["programs.html", "10 Programs 10.1 Strategy 10.2 if Statements 10.3 else Statements 10.4 Lookup Tables 10.5 Code Comments 10.6 Summary", " 10 Programs In this chapter, you will build a real, working slot machine that you can play by running an R function. When you’re finished, you’ll be able to play it like this: play() ## 0 0 DD ## $0 play() ## 7 7 7 ## $80 The play function will need to do two things. First, it will need to randomly generate three symbols; and, second, it will need to calculate a prize based on those symbols. The first step is easy to simulate. You can randomly generate three symbols with the sample function—just like you randomly “rolled” two dice in [Project 1: Weighted Dice]. The following function generates three symbols from a group of common slot machine symbols: diamonds (DD), sevens (7), triple bars (BBB), double bars (BB), single bars (B), cherries (C), and zeroes (0). The symbols are selected randomly, and each symbol appears with a different probability: get_symbols &lt;- function() { wheel &lt;- c(&quot;DD&quot;, &quot;7&quot;, &quot;BBB&quot;, &quot;BB&quot;, &quot;B&quot;, &quot;C&quot;, &quot;0&quot;) sample(wheel, size = 3, replace = TRUE, prob = c(0.03, 0.03, 0.06, 0.1, 0.25, 0.01, 0.52)) } You can use get_symbols to generate the symbols used in your slot machine: get_symbols() ## &quot;BBB&quot; &quot;0&quot; &quot;C&quot; get_symbols() ## &quot;0&quot; &quot;0&quot; &quot;0&quot; get_symbols() ## &quot;7&quot; &quot;0&quot; &quot;B&quot; get_symbols uses the probabilities observed in a group of video lottery terminals from Manitoba, Canada. These slot machines became briefly controversial in the 1990s, when a reporter decided to test their payout rate. The machines appeared to pay out only 40 cents on the dollar, even though the manufacturer claimed they would pay out 92 cents on the dollar. The original data collected on the machines and a description of the controversy is available online in a journal article by W. John Braun. The controversy died down when additional testing showed that the manufacturer was correct. The Manitoba slot machines use the complicated payout scheme shown in Table 10.1. A player will win a prize if he gets: Three of the same type of symbol (except for three zeroes) Three bars (of mixed variety) One or more cherries Otherwise, the player receives no prize. The monetary value of the prize is determined by the exact combination of symbols and is further modified by the presence of diamonds. Diamonds are treated like “wild cards,” which means they can be considered any other symbol if it would increase a player’s prize. For example, a player who rolls 7 7 DD would earn a prize for getting three sevens. There is one exception to this rule, however: a diamond cannot be considered a cherry unless the player also gets one real cherry. This prevents a dud roll like, 0 DD 0 from being scored as 0 C 0. Diamonds are also special in another way. Every diamond that appears in a combination doubles the amount of the final prize. So 7 7 DD would actually be scored higher than 7 7 7. Three sevens would earn you $80, but two sevens and a diamond would earn you $160. One seven and two diamonds would be even better, resulting in a prize that has been doubled twice, or $320. A jackpot occurs when a player rolls DD DD DD. Then a player earns $100 doubled three times, which is $800. Table 10.1: Each play of the slot machine costs $1. A player’s symbols determine how much they win. Diamonds (DD) are wild, and each diamond doubles the final prize. * = any symbol. Combination Prize($) DD DD DD 100 7 7 7 80 BBB BBB BBB 40 BB BB BB 25 B B B 10 C C C 10 Any combination of bars 5 C C * 5 C * C 5 * C C 5 C * * 2 * C * 2 * * C 2 To create your play function, you will need to write a program that can take the output of get_symbols and calculate the correct prize based on Table 10.1. In R, programs are saved either as R scripts or as functions. We’ll save your program as a function named score. When you are finished, you will be able to use score to calculate a prize like this: score(c(&quot;DD&quot;, &quot;DD&quot;, &quot;DD&quot;)) ## 800 After that it will be easy to create the full slot machine, like this: play &lt;- function() { symbols &lt;- get_symbols() print(symbols) score(symbols) } The print command prints its output to the console window, which makes print a useful way to display messages from within the body of a function. You may notice that play calls a new function, print. This will help play display the three slot machine symbols, since they do not get returned by the last line of the function. The print command prints its output to the console window – even if R calls it from within a function. In [Project 1: Weighted Dice], I encouraged you to write all of your R code in an R script, a text file where you can compose and save code. That advice will become very important as you work through this chapter. Remember that you can open an R script in RStudio by going to the menu bar and clicking on File &gt; New File &gt; R Script. 10.1 Strategy Scoring slot-machine results is a complex task that will require a complex algorithm. You can make this, and other coding tasks, easier by using a simple strategy: Break complex tasks into simple subtasks. Use concrete examples. Describe your solutions in English, then convert them to R. Let’s start by looking at how you can divide a program into subtasks that are simple to work with. A program is a set of step-by-step instructions for your computer to follow. Taken together, these instructions may accomplish something very sophisticated. Taken apart, each individual step will likely be simple and straightforward. You can make coding easier by identifying the individual steps or subtasks within your program. You can then work on each subtask separately. If a subtask seems complicated, try to divide it again into even subtasks that are even more simple. You can often reduce an R program into substasks so simple that each can be performed with a preexisting function. R programs contain two types of subtasks: sequential steps and parallel cases. 10.1.1 Sequential Steps One way to subdivide a program is into a series of sequential steps. The play function takes the approach, shown in Figure 10.1. First, it generates three symbols (step 1), then it displays them in the console window (step 2), and then it scores them (step 3): play &lt;- function() { # step 1: generate symbols symbols &lt;- get_symbols() # step 2: display the symbols print(symbols) # step 3: score the symbols score(symbols) } To have R execute steps in sequence, place the steps one after another in an R script or function body. Figure 10.1: The play function uses a series of steps. 10.1.2 Parallel Cases Another way to divide a task is to spot groups of similar cases within the task. Some tasks require different algorithms for different groups of input. If you can identify those groups, you can work out their algorithms one at a time. For example, score will need to calculate the prize one way if symbols contains three of a kind (In that case, score will need to match the common symbol to a prize). score will need to calculate the prize a second way if the symbols are all bars (In that case, score can just assign a prize of $5). And, finally, score will need to calculate the prize in a third way if the symbols do not contain three of a kind or all bars (In that case, score must count the number of cherries present). score will never use all three of these algorithms at once; it will always choose just one algorithm to run based on the combination of symbols. Diamonds complicate all of this because diamonds can be treated as wild cards. Let’s ignore that for now and focus on the simpler case where diamonds double the prize but are not wilds. score can double the prize as necessary after it runs one of the following algorithms, as shown in Figure 10.2. Adding the score cases to the play steps reveals a strategy for the complete slot machine program, as shown in Figure 10.3. We’ve already solved the first few steps in this strategy. Our program can get three slot machine symbols with the get_symbols function. Then it can display the symbols with the print function. Now let’s examine how the program can handle the parallel score cases. Figure 10.2: The score function must distinguish between parallel cases. Figure 10.3: The complete slot machine simulation will involve subtasks that are arranged both in series and in parallel. 10.2 if Statements Linking cases together in parallel requires a bit of structure; your program faces a fork in the road whenever it must choose between cases. You can help the program navigate this fork with an if statement. An if statement tells R to do a certain task for a certain case. In English you would say something like, “If this is true, do that.” In R, you would say: if (this) { that } The this object should be a logical test or an R expression that evaluates to a single TRUE or FALSE. If this evaluates to TRUE, R will run all of the code that appears between the braces that follow the if statement (i.e., between the { and } symbols). If this evaluates to FALSE, R will skip the code between the braces without running it. For example, you could write an if statement that ensures some object, num, is positive: if (num &lt; 0) { num &lt;- num * -1 } If num &lt; 0 is TRUE, R will multiply num by negative one, which will make num positive: num &lt;- -2 if (num &lt; 0) { num &lt;- num * -1 } num ## 2 If num &lt; 0 is FALSE, R will do nothing and num will remain as it is—positive (or zero): num &lt;- 4 if (num &lt; 0) { num &lt;- num * -1 } num ## 4 The condition of an if statement must evaluate to a single TRUE or FALSE. If the condition creates a vector of TRUEs and FALSEs (which is easier to make than you may think), your if statement will print a warning message and use only the first element of the vector. Remember that you can condense vectors of logical values to a single TRUE or FALSE with the functions any and all. You don’t have to limit your if statements to a single line of code; you can include as many lines as you like between the braces. For example, the following code uses many lines to ensure that num is positive. The additional lines print some informative statements if num begins as a negative number. R will skip the entire code block—print statements and all—if num begins as a positive number: num &lt;- -1 if (num &lt; 0) { print(&quot;num is negative.&quot;) print(&quot;Don&#39;t worry, I&#39;ll fix it.&quot;) num &lt;- num * -1 print(&quot;Now num is positive.&quot;) } ## &quot;num is negative.&quot; ## &quot;Don&#39;t worry, I&#39;ll fix it.&quot; ## &quot;Now num is positive.&quot; num ## 1 Try the following quizzes to develop your understanding of if statements. Exercise 10.1 (Quiz A) What will this return? x &lt;- 1 if (3 == 3) { x &lt;- 2 } x Solution. The code will return the number 2. x begins as 1, and then R encounters the if statement. Since the condition evaluates to TRUE, R will run x &lt;- 2, changing the value of x. Exercise 10.2 (Quiz B) What will this return? x &lt;- 1 if (TRUE) { x &lt;- 2 } x Solution. This code will also return the number 2. It works the same as the code in Quiz A, except the condition in this statement is already TRUE. R doesn’t even need to evaluate it. As a result, the code inside the if statement will be run, and x will be set to 2. Exercise 10.3 (Quiz C) What will this return? x &lt;- 1 if (x == 1) { x &lt;- 2 if (x == 1) { x &lt;- 3 } } x Solution. Once again, the code will return the number 2. x starts out as 1, and the condition of the first if statement will evaluate to TRUE, which causes R to run the code in the body of the if statement. First, R sets x equal to 2, then R evaluates the second if statement, which is in the body of the first. This time x == 1 will evaluate to FALSE because x now equals 2. As a result, R ignores x &lt;- 3 and exits both if statements. 10.3 else Statements if statements tell R what to do when your condition is true, but you can also tell R what to do when the condition is false. else is a counterpart to if that extends an if statement to include a second case. In English, you would say, “If this is true, do plan A; else do plan B.” In R, you would say: if (this) { Plan A } else { Plan B } When this evaluates to TRUE, R will run the code in the first set of braces, but not the code in the second. When this evaluates to FALSE, R will run the code in the second set of braces, but not the first. You can use this arrangement to cover all of the possible cases. For example, you could write some code that rounds a decimal to the nearest integer. Start with a decimal: a &lt;- 3.14 Then isolate the decimal component with trunc: dec &lt;- a - trunc(a) dec ## 0.14 trunc takes a number and returns only the portion of the number that appears to the left of the decimal place (i.e., the integer part of the number). a - trunc(a) is a convenient way to return the decimal part of a. Then use an if else tree to round the number (either up or down): if (dec &gt;= 0.5) { a &lt;- trunc(a) + 1 } else { a &lt;- trunc(a) } a ## 3 If your situation has more than two mutually exclusive cases, you can string multiple if and else statements together by adding a new if statement immediately after else. For example: a &lt;- 1 b &lt;- 1 if (a &gt; b) { print(&quot;A wins!&quot;) } else if (a &lt; b) { print(&quot;B wins!&quot;) } else { print(&quot;Tie.&quot;) } ## &quot;Tie.&quot; R will work through the if conditions until one evaluates to TRUE, then R will ignore any remaining if and else clauses in the tree. If no conditions evaluate to TRUE, R will run the final else statement. If two if statements describe mutually exclusive events, it is better to join the if statements with an else if than to list them separately. This lets R ignore the second if statement whenever the first returns a TRUE, which saves work. You can use if and else to link the subtasks in your slot-machine function. Open a fresh R script, and copy this code into it. The code will be the skeleton of our final score function. Compare it to the flow chart for score in Figure 10.2: if ( # Case 1: all the same &lt;1&gt;) { prize &lt;- # look up the prize &lt;3&gt; } else if ( # Case 2: all bars &lt;2&gt; ) { prize &lt;- # assign $5 &lt;4&gt; } else { # count cherries &lt;5&gt; prize &lt;- # calculate a prize &lt;7&gt; } # count diamonds &lt;6&gt; # double the prize if necessary &lt;8&gt; Our skeleton is rather incomplete; there are many sections that are just code comments instead of real code. However, we’ve reduced the program to eight simple subtasks: &lt;1&gt; - Test whether the symbols are three of a kind. &lt;2&gt; - Test whether the symbols are all bars. &lt;3&gt; - Look up the prize for three of a kind based on the common symbol. &lt;4&gt; - Assign a prize of $5. &lt;5&gt; - Count the number of cherries. &lt;6&gt; - Count the number of diamonds. &lt;7&gt; - Calculate a prize based on the number of cherries. &lt;8&gt; - Adjust the prize for diamonds. If you like, you can reorganize your flow chart around these tasks, as in Figure 10.4. The chart will describe the same strategy, but in a more precise way. I’ll use a diamond shape to symbolize an if else decision. Figure 10.4: score can navigate three cases with two if else decisions. We can also break some of our tasks into two steps. Now we can work through the subtasks one at a time, adding R code to the if tree as we go. Each subtask will be easy to solve if you set up a concrete example to work with and try to describe a solution in English before coding in R. The first subtask asks you to test whether the symbols are three of a kind. How should you begin writing the code for this subtask? You know that the final score function will look something like this: score &lt;- function(symbols) { # calculate a prize prize } Its argument, symbols, will be the output of get_symbols, a vector that contains three character strings. You could start writing score as I have written it, by defining an object named score and then slowly filling in the body of the function. However, this would be a bad idea. The eventual function will have eight separate parts, and it will not work correctly until all of those parts are written (and themselves work correctly). This means you would have to write the entire score function before you could test any of the subtasks. If score doesn’t work—which is very likely—you will not know which subtask needs fixed. You can save yourself time and headaches if you focus on one subtask at a time. For each subtask, create a concrete example that you can test your code on. For example, you know that score will need to work on a vector named symbols that contains three character strings. If you make a real vector named symbols, you can run the code for many of your subtasks on the vector as you go: symbols &lt;- c(&quot;7&quot;, &quot;7&quot;, &quot;7&quot;) If a piece of code does not work on symbols, you will know that you need to fix it before you move on. You can change the value of symbols from subtask to subtask to ensure that your code works in every situation: symbols &lt;- c(&quot;B&quot;, &quot;BB&quot;, &quot;BBB&quot;) symbols &lt;- c(&quot;C&quot;, &quot;DD&quot;, &quot;0&quot;) Only combine your subtasks into a score function once each subtask works on a concrete example. If you follow this plan, you will spend more time using your functions and less time trying to figure out why they do not work. After you set up a concrete example, try to describe how you will do the subtask in English. The more precisely you can describe your solution, the easier it will be to write your R code. Our first subtask asks us to “test whether the symbols are three of a kind.” This phrase does not suggest any useful R code to me. However, I could describe a more precise test for three of a kind: three symbols will be the same if the first symbol is equal to the second and the second symbol is equal to the third. Or, even more precisely: A vector named symbols will contain three of the same symbol if the first element of symbols is equal to the second element of symbols and the second element of symbols is equal to the third element of symbols. Exercise 10.4 (Write a Test) Turn the preceding statement into a logical test written in R. Use your knowledge of logical tests, Boolean operators, and subsetting from [R Notation]. The test should work with the vector symbols and return a TRUE if and only if each element in symbols is the same. Be sure to test your code on symbols. Solution. Here are a couple of ways to test that symbols contains three of the same symbol. The first method parallels the English suggestion above, but there are other ways to do the same test. There is no right or wrong answer, so long as your solution works, which is easy to check because you’ve created a vector named symbols: symbols ## &quot;7&quot; &quot;7&quot; &quot;7&quot; symbols[1] == symbols[2] &amp; symbols[2] == symbols[3] ## TRUE symbols[1] == symbols[2] &amp; symbols[1] == symbols[3] ## TRUE all(symbols == symbols[1]) ## TRUE As your vocabulary of R functions broadens, you’ll think of more ways to do basic tasks. One method that I like for checking three of a kind is: length(unique(symbols) == 1) The unique function returns every unique term that appears in a vector. If your symbols vector contains three of a kind (i.e., one unique term that appears three times), then unique(symbols) will return a vector of length 1. Now that you have a working test, you can add it to your slot-machine script: same &lt;- symbols[1] == symbols[2] &amp;&amp; symbols[2] == symbols[3] if (same) { prize &lt;- # look up the prize } else if ( # Case 2: all bars ) { prize &lt;- # assign $5 } else { # count cherries prize &lt;- # calculate a prize } # count diamonds # double the prize if necessary &amp;&amp; and || behave like &amp; and | but can sometimes be more efficient. The double operators will not evaluate the second test in a pair of tests if the first test makes the result clear. For example, if symbols[1] does not equal symbols[2] in the next expression, &amp;&amp; will not evaluate symbols[2] == symbols[3]; it can immediately return a FALSE for the whole expression (because FALSE &amp; TRUE and FALSE &amp; FALSE both evaluate to FALSE). This efficiency can speed up your programs; however, double operators are not appropriate everywhere. &amp;&amp; and || are not vectorized, which means they can only handle a single logical test on each side of the operator. The second prize case occurs when all the symbols are a type of bar, for example, B, BB, and BBB. Let’s begin by creating a concrete example to work with: symbols &lt;- c(&quot;B&quot;, &quot;BBB&quot;, &quot;BB&quot;) Exercise 10.5 (Test for All Bars) Use R’s logical and Boolean operators to write a test that will determine whether a vector named symbols contains only symbols that are a type of bar. Check whether your test works with our example symbols vector. Remember to describe how the test should work in English, and then convert the solution to R. Solution. As with many things in R, there are multiple ways to test whether symbols contains all bars. For example, you could write a very long test that uses multiple Boolean operators, like this: (symbols[1] == &quot;B&quot; | symbols[1] == &quot;BB&quot; | symbols[1] == &quot;BBB&quot;) &amp; (symbols[2] == &quot;B&quot; | symbols[2] == &quot;BB&quot; | symbols[2] == &quot;BBB&quot;) &amp; (symbols[3] == &quot;B&quot; | symbols[3] == &quot;BB&quot; | symbols[3] == &quot;BBB&quot;) ## TRUE However, this is not a very efficient solution, because R has to run nine logical tests (and you have to type them). You can often replace multiple | operators with a single %in%. Also, you can check that a test is true for each element in a vector with all. These two changes shorten the preceding code to: all(symbols %in% c(&quot;B&quot;, &quot;BB&quot;, &quot;BBB&quot;)) ## TRUE Let’s add this code to our script: same &lt;- symbols[1] == symbols[2] &amp;&amp; symbols[2] == symbols[3] bars &lt;- symbols %in% c(&quot;B&quot;, &quot;BB&quot;, &quot;BBB&quot;) if (same) { prize &lt;- # look up the prize } else if (all(bars)) { prize &lt;- # assign $5 } else { # count cherries prize &lt;- # calculate a prize } # count diamonds # double the prize if necessary You may have noticed that I split this test up into two steps, bars and all(bars). That’s just a matter of personal preference. Wherever possible, I like to write my code so it can be read with function and object names conveying what they do. You also may have noticed that our test for Case 2 will capture some symbols that should be in Case 1 because they contain three of a kind: symbols &lt;- c(&quot;B&quot;, &quot;B&quot;, &quot;B&quot;) all(symbols %in% c(&quot;B&quot;, &quot;BB&quot;, &quot;BBB&quot;)) ## TRUE That won’t be a problem, however, because we’ve connected our cases with else if in the if tree. As soon as R comes to a case that evaluates to TRUE, it will skip over the rest of the tree. Think of it this way: each else tells R to only run the code that follows it if none of the previous conditions have been met. So when we have three of the same type of bar, R will evaluate the code for Case 1 and then skip the code for Case 2 (and Case 3). Our next subtask is to assign a prize for symbols. When the symbols vector contains three of the same symbol, the prize will depend on which symbol there are three of. If there are three DDs, the prize will be $100; if there are three 7s, the prize will be $80; and so on. This suggests another if tree. You could assign a prize with some code like this: if (same) { symbol &lt;- symbols[1] if (symbol == &quot;DD&quot;) { prize &lt;- 800 } else if (symbol == &quot;7&quot;) { prize &lt;- 80 } else if (symbol == &quot;BBB&quot;) { prize &lt;- 40 } else if (symbol == &quot;BB&quot;) { prize &lt;- 5 } else if (symbol == &quot;B&quot;) { prize &lt;- 10 } else if (symbol == &quot;C&quot;) { prize &lt;- 10 } else if (symbol == &quot;0&quot;) { prize &lt;- 0 } } While this code will work, it is a bit long to write and read, and it may require R to perform multiple logical tests before delivering the correct prize. We can do better with a different method. 10.4 Lookup Tables Very often in R, the simplest way to do something will involve subsetting. How could you use subsetting here? Since you know the exact relationship between the symbols and their prizes, you can create a vector that captures this information. This vector can store symbols as names and prize values as elements: payouts &lt;- c(&quot;DD&quot; = 100, &quot;7&quot; = 80, &quot;BBB&quot; = 40, &quot;BB&quot; = 25, &quot;B&quot; = 10, &quot;C&quot; = 10, &quot;0&quot; = 0) payouts ## DD 7 BBB BB B C 0 ## 100 80 40 25 10 10 0 Now you can extract the correct prize for any symbol by subsetting the vector with the symbol’s name: payouts[&quot;DD&quot;] ## DD ## 100 payouts[&quot;B&quot;] ## B ## 10 If you want to leave behind the symbol’s name when subsetting, you can run the unname function on the output: unname(payouts[&quot;DD&quot;]) ## 100 unname returns a copy of an object with the names attribute removed. payouts is a type of lookup table, an R object that you can use to look up values. Subsetting payouts provides a simple way to find the prize for a symbol. It doesn’t take many lines of code, and it does the same amount of work whether your symbol is DD or 0. You can create lookup tables in R by creating named objects that can be subsetted in clever ways. Sadly, our method is not quite automatic; we need to tell R which symbol to look up in payouts. Or do we? What would happen if you subsetted payouts by symbols[1]? Give it a try: symbols &lt;- c(&quot;7&quot;, &quot;7&quot;, &quot;7&quot;) symbols[1] ## &quot;7&quot; payouts[symbols[1]] ## 7 ## 80 symbols &lt;- c(&quot;C&quot;, &quot;C&quot;, &quot;C&quot;) payouts[symbols[1]] ## C ## 10 You don’t need to know the exact symbol to look up because you can tell R to look up whichever symbol happens to be in symbols. You can find this symbol with symbols[1], symbols[2], or symbols[3], because each contains the same symbol in this case. You now have a simple automated way to calculate the prize when symbols contains three of a kind. Let’s add it to our code and then look at Case 2: same &lt;- symbols[1] == symbols[2] &amp;&amp; symbols[2] == symbols[3] bars &lt;- symbols %in% c(&quot;B&quot;, &quot;BB&quot;, &quot;BBB&quot;) if (same) { payouts &lt;- c(&quot;DD&quot; = 100, &quot;7&quot; = 80, &quot;BBB&quot; = 40, &quot;BB&quot; = 25, &quot;B&quot; = 10, &quot;C&quot; = 10, &quot;0&quot; = 0) prize &lt;- unname(payouts[symbols[1]]) } else if (all(bars)) { prize &lt;- # assign $5 } else { # count cherries prize &lt;- # calculate a prize } # count diamonds # double the prize if necessary Case 2 occurs whenever the symbols are all bars. In that case, the prize will be $5, which is easy to assign: same &lt;- symbols[1] == symbols[2] &amp;&amp; symbols[2] == symbols[3] bars &lt;- symbols %in% c(&quot;B&quot;, &quot;BB&quot;, &quot;BBB&quot;) if (same) { payouts &lt;- c(&quot;DD&quot; = 100, &quot;7&quot; = 80, &quot;BBB&quot; = 40, &quot;BB&quot; = 25, &quot;B&quot; = 10, &quot;C&quot; = 10, &quot;0&quot; = 0) prize &lt;- unname(payouts[symbols[1]]) } else if (all(bars)) { prize &lt;- 5 } else { # count cherries prize &lt;- # calculate a prize } # count diamonds # double the prize if necessary Now we can work on the last case. Here, you’ll need to know how many cherries are in symbols before you can calculate a prize. Exercise 10.6 (Find C's) How can you tell which elements of a vector named symbols are a C? Devise a test and try it out. Challenge How might you count the number of Cs in a vector named symbols? Remember R’s coercion rules. Solution. As always, let’s work with a real example: symbols &lt;- c(&quot;C&quot;, &quot;DD&quot;, &quot;C&quot;) One way to test for cherries would be to check which, if any, of the symbols are a C: symbols == &quot;C&quot; ## TRUE FALSE TRUE It’d be even more useful to count how many of the symbols are cherries. You can do this with sum, which expects numeric input, not logical. Knowing this, R will coerce the TRUEs and FALSEs to 1s and 0s before doing the summation. As a result, sum will return the number of TRUEs, which is also the number of cherries: sum(symbols == &quot;C&quot;) ## 2 You can use the same method to count the number of diamonds in symbols: sum(symbols == &quot;DD&quot;) ## 1 Let’s add both of these subtasks to the program skeleton: same &lt;- symbols[1] == symbols[2] &amp;&amp; symbols[2] == symbols[3] bars &lt;- symbols %in% c(&quot;B&quot;, &quot;BB&quot;, &quot;BBB&quot;) if (same) { payouts &lt;- c(&quot;DD&quot; = 100, &quot;7&quot; = 80, &quot;BBB&quot; = 40, &quot;BB&quot; = 25, &quot;B&quot; = 10, &quot;C&quot; = 10, &quot;0&quot; = 0) prize &lt;- unname(payouts[symbols[1]]) } else if (all(bars)) { prize &lt;- 5 } else { cherries &lt;- sum(symbols == &quot;C&quot;) prize &lt;- # calculate a prize } diamonds &lt;- sum(symbols == &quot;DD&quot;) # double the prize if necessary Since Case 3 appears further down the if tree than Cases 1 and 2, the code in Case 3 will only be applied to players that do not have three of a kind or all bars. According to the slot machine’s payout scheme, these players will win $5 if they have two cherries and $2 if they have one cherry. If the player has no cherries, she gets a prize of $0. We don’t need to worry about three cherries because that outcome is already covered in Case 1. As in Case 1, you could write an if tree that handles each combination of cherries, but just like in Case 1, this would be an inefficient solution: if (cherries == 2) { prize &lt;- 5 } else if (cherries == 1) { prize &lt;- 2 } else {} prize &lt;- 0 } Again, I think the best solution will involve subsetting. If you are feeling ambitious, you can try to work this solution out on your own, but you will learn just as quickly by mentally working through the following proposed solution. We know that our prize should be $0 if we have no cherries, $2 if we have one cherry, and $5 if we have two cherries. You can create a vector that contains this information. This will be a very simple lookup table: c(0, 2, 5) Now, like in Case 1, you can subset the vector to retrieve the correct prize. In this case, the prize’s aren’t identified by a symbol name, but by the number of cherries present. Do we have that information? Yes, it is stored in cherries. We can use basic integer subsetting to get the correct prize from the prior lookup table, for example, c(0, 2, 5)[1]. cherries isn’t exactly suited for integer subsetting because it could contain a zero, but that’s easy to fix. We can subset with cherries + 1. Now when cherries equals zero, we have: cherries + 1 ## 1 c(0, 2, 5)[cherries + 1] ## 0 When cherries equals one, we have: cherries + 1 ## 2 c(0, 2, 5)[cherries + 1] ## 2 And when cherries equals two, we have: cherries + 1 ## 3 c(0, 2, 5)[cherries + 1] ## 5 Examine these solutions until you are satisfied that they return the correct prize for each number of cherries. Then add the code to your script, as follows: same &lt;- symbols[1] == symbols[2] &amp;&amp; symbols[2] == symbols[3] bars &lt;- symbols %in% c(&quot;B&quot;, &quot;BB&quot;, &quot;BBB&quot;) if (same) { payouts &lt;- c(&quot;DD&quot; = 100, &quot;7&quot; = 80, &quot;BBB&quot; = 40, &quot;BB&quot; = 25, &quot;B&quot; = 10, &quot;C&quot; = 10, &quot;0&quot; = 0) prize &lt;- unname(payouts[symbols[1]]) } else if (all(bars)) { prize &lt;- 5 } else { cherries &lt;- sum(symbols == &quot;C&quot;) prize &lt;- c(0, 2, 5)[cherries + 1] } diamonds &lt;- sum(symbols == &quot;DD&quot;) # double the prize if necessary Lookup Tables Versus if Trees This is the second time we’ve created a lookup table to avoid writing an if tree. Why is this technique helpful and why does it keep appearing? Many if trees in R are essential. They provide a useful way to tell R to use different algorithms in different cases. However, if trees are not appropriate everywhere. if trees have a couple of drawbacks. First, they require R to run multiple tests as it works its way down the if tree, which can create unnecessary work. Second, as you’ll see in Speed, it can be difficult to use if trees in vectorized code, a style of code that takes advantage of R’s programming strengths to create fast programs. Lookup tables do not suffer from either of these drawbacks. You won’t be able to replace every if tree with a lookup table, nor should you. However, you can usually use lookup tables to avoid assigning variables with if trees. As a general rule, use an if tree if each branch of the tree runs different code. Use a lookup table if each branch of the tree only assigns a different value. To convert an if tree to a lookup table, identify the values to be assigned and store them in a vector. Next, identify the selection criteria used in the conditions of the if tree. If the conditions use character strings, give your vector names and use name-based subsetting. If the conditions use integers, use integer-based subsetting. The final subtask is to double the prize once for every diamond present. This means that the final prize will be some multiple of the current prize. For example, if no diamonds are present, the prize will be: prize * 1 # 1 = 2 ^ 0 If one diamond is present, it will be: prize * 2 # 2 = 2 ^ 1 If two diamonds are present, it will be: prize * 4 # 4 = 2 ^ 2 And if three diamonds are present, it will be: prize * 8 # 8 = 2 ^ 3 Can you think of an easy way to handle this? How about something similar to these examples? Exercise 10.7 (Adjust for Diamonds) Write a method for adjusting prize based on diamonds. Describe a solution in English first, and then write your code. Solution. Here is a concise solution inspired by the previous pattern. The adjusted prize will equal: prize * 2 ^ diamonds which gives us our final score script: same &lt;- symbols[1] == symbols[2] &amp;&amp; symbols[2] == symbols[3] bars &lt;- symbols %in% c(&quot;B&quot;, &quot;BB&quot;, &quot;BBB&quot;) if (same) { payouts &lt;- c(&quot;DD&quot; = 100, &quot;7&quot; = 80, &quot;BBB&quot; = 40, &quot;BB&quot; = 25, &quot;B&quot; = 10, &quot;C&quot; = 10, &quot;0&quot; = 0) prize &lt;- unname(payouts[symbols[1]]) } else if (all(bars)) { prize &lt;- 5 } else { cherries &lt;- sum(symbols == &quot;C&quot;) prize &lt;- c(0, 2, 5)[cherries + 1] } diamonds &lt;- sum(symbols == &quot;DD&quot;) prize * 2 ^ diamonds 10.5 Code Comments You now have a working score script that you can save to a function. Before you save your script, though, consider adding comments to your code with a #. Comments can make your code easier to understand by explaining why the code does what it does. You can also use comments to break long programs into scannable chunks. For example, I would include three comments in the score code: # identify case same &lt;- symbols[1] == symbols[2] &amp;&amp; symbols[2] == symbols[3] bars &lt;- symbols %in% c(&quot;B&quot;, &quot;BB&quot;, &quot;BBB&quot;) # get prize if (same) { payouts &lt;- c(&quot;DD&quot; = 100, &quot;7&quot; = 80, &quot;BBB&quot; = 40, &quot;BB&quot; = 25, &quot;B&quot; = 10, &quot;C&quot; = 10, &quot;0&quot; = 0) prize &lt;- unname(payouts[symbols[1]]) } else if (all(bars)) { prize &lt;- 5 } else { cherries &lt;- sum(symbols == &quot;C&quot;) prize &lt;- c(0, 2, 5)[cherries + 1] } # adjust for diamonds diamonds &lt;- sum(symbols == &quot;DD&quot;) prize * 2 ^ diamonds Now that each part of your code works, you can wrap it into a function with the methods you learned in Writing Your Own Functions. Either use RStudio’s Extract Function option in the menu bar under Code, or use the function function. Ensure that the last line of the function returns a result (it does), and identify any arguments used by your function. Often the concrete examples that you used to test your code, like symbols, will become the arguments of your function. Run the following code to start using the score function: score &lt;- function (symbols) { # identify case same &lt;- symbols[1] == symbols[2] &amp;&amp; symbols[2] == symbols[3] bars &lt;- symbols %in% c(&quot;B&quot;, &quot;BB&quot;, &quot;BBB&quot;) # get prize if (same) { payouts &lt;- c(&quot;DD&quot; = 100, &quot;7&quot; = 80, &quot;BBB&quot; = 40, &quot;BB&quot; = 25, &quot;B&quot; = 10, &quot;C&quot; = 10, &quot;0&quot; = 0) prize &lt;- unname(payouts[symbols[1]]) } else if (all(bars)) { prize &lt;- 5 } else { cherries &lt;- sum(symbols == &quot;C&quot;) prize &lt;- c(0, 2, 5)[cherries + 1] } # adjust for diamonds diamonds &lt;- sum(symbols == &quot;DD&quot;) prize * 2 ^ diamonds } Once you have defined the score function, the play function will work as well: play &lt;- function() { symbols &lt;- get_symbols() print(symbols) score(symbols) } Now it is easy to play the slot machine: play() ## &quot;0&quot; &quot;BB&quot; &quot;B&quot; ## 0 play() ## &quot;DD&quot; &quot;0&quot; &quot;B&quot; ## 0 play() ## &quot;BB&quot; &quot;BB&quot; &quot;B&quot; ## 25 10.6 Summary An R program is a set of instructions for your computer to follow that has been organized into a sequence of steps and cases. This may make programs seem simple, but don’t be fooled: you can create complicated results with the right combination of simple steps (and cases). As a programmer, you are more likely to be fooled in the opposite way. A program may seem impossible to write when you know that it must do something impressive. Do not panic in these situations. Divide the job before you into simple tasks, and then divide the tasks again. You can visualize the relationship between tasks with a flow chart if it helps. Then work on the subtasks one at a time. Describe solutions in English, then convert them to R code. Test each solution against concrete examples as you go. Once each of your subtasks works, combine your code into a function that you can share and reuse. R provides tools that can help you do this. You can manage cases with if and else statements. You can create a lookup table with objects and subsetting. You can add code comments with #. And you can save your programs as a function with function. Things often go wrong when people write programs. It will be up to you to find the source of any errors that occur and to fix them. It should be easy to find the source of your errors if you use a stepwise approach to writing functions, writing—and then testing—one bit at a time. However, if the source of an error eludes you, or you find yourself working with large chunks of untested code, consider using R’s built in debugging tools, described in Debugging R Code. The next two chapters will teach you more tools that you can use in your programs. As you master these tools, you will find it easier to write R programs that let you do whatever you wish to your data. In S3, you will learn how to use R’s S3 system, an invisible hand that shapes many parts of R. You will use the system to build a custom class for your slot machine output, and you will tell R how to display objects that have your class. "],["s3.html", "11 S3 11.1 The S3 System 11.2 Attributes 11.3 Generic Functions 11.4 Methods 11.5 Classes 11.6 S3 and Debugging 11.7 S4 and R5 11.8 Summary", " 11 S3 You may have noticed that your slot machine results do not look the way I promised they would. I suggested that the slot machine would display its results like this: play() ## 0 0 DD ## $0 But the current machine displays its results in a less pretty format: play() ## &quot;0&quot; &quot;0&quot; &quot;DD&quot; ## 0 Moreover, the slot machine uses a hack to display symbols (we call print from within play). As a result, the symbols do not follow your prize output if you save it: one_play &lt;- play() ## &quot;B&quot; &quot;0&quot; &quot;B&quot; one_play ## 0 You can fix both of these problems with R’s S3 system. 11.1 The S3 System S3 refers to a class system built into R. The system governs how R handles objects of different classes. Certain R functions will look up an object’s S3 class, and then behave differently in response. The print function is like this. When you print a numeric vector, print will display a number: num &lt;- 1000000000 print(num) ## 1000000000 But if you give that number the S3 class POSIXct followed by POSIXt, print will display a time: class(num) &lt;- c(&quot;POSIXct&quot;, &quot;POSIXt&quot;) print(num) ## &quot;2001-09-08 19:46:40 CST&quot; If you use objects with classes—and you do—you will run into R’s S3 system. S3 behavior can seem odd at first, but is easy to predict once you are familiar with it. R’s S3 system is built around three components: attributes (especially the class attribute), generic functions, and methods. 11.2 Attributes In Attributes, you learned that many R objects come with attributes, pieces of extra information that are given a name and appended to the object. Attributes do not affect the values of the object, but stick to the object as a type of metadata that R can use to handle the object. For example, a data frame stores its row and column names as attributes. Data frames also store their class, \"data.frame\", as an attribute. You can see an object’s attributes with attribute. If you run attribute on the deck data frame that you created in [Project 2: Playing Cards], you will see: attributes(deck) ## $names ## [1] &quot;face&quot; &quot;suit&quot; &quot;value&quot; ## ## $class ## [1] &quot;data.frame&quot; ## ## $row.names ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ## [20] 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 ## [37] 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 R comes with many helper functions that let you set and access the most common attributes used in R. You’ve already met the names, dim, and class functions, which each work with an eponymously named attribute. However, R also has row.names, levels, and many other attribute-based helper functions. You can use any of these functions to retrieve an attribute’s value: row.names(deck) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; &quot;10&quot; &quot;11&quot; &quot;12&quot; &quot;13&quot; ## [14] &quot;14&quot; &quot;15&quot; &quot;16&quot; &quot;17&quot; &quot;18&quot; &quot;19&quot; &quot;20&quot; &quot;21&quot; &quot;22&quot; &quot;23&quot; &quot;24&quot; &quot;25&quot; &quot;26&quot; ## [27] &quot;27&quot; &quot;28&quot; &quot;29&quot; &quot;30&quot; &quot;31&quot; &quot;32&quot; &quot;33&quot; &quot;34&quot; &quot;35&quot; &quot;36&quot; &quot;37&quot; &quot;38&quot; &quot;39&quot; ## [40] &quot;40&quot; &quot;41&quot; &quot;42&quot; &quot;43&quot; &quot;44&quot; &quot;45&quot; &quot;46&quot; &quot;47&quot; &quot;48&quot; &quot;49&quot; &quot;50&quot; &quot;51&quot; &quot;52&quot; or to change an attribute’s value: row.names(deck) &lt;- 101:152 or to give an object a new attribute altogether: levels(deck) &lt;- c(&quot;level 1&quot;, &quot;level 2&quot;, &quot;level 3&quot;) attributes(deck) ## $names ## [1] &quot;face&quot; &quot;suit&quot; &quot;value&quot; ## ## $class ## [1] &quot;data.frame&quot; ## ## $row.names ## [1] 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 ## [18] 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 ## [35] 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 ## [52] 152 ## ## $levels ## [1] &quot;level 1&quot; &quot;level 2&quot; &quot;level 3&quot; R is very laissez faire when it comes to attributes. It will let you add any attributes that you like to an object (and then it will usually ignore them). The only time R will complain is when a function needs to find an attribute and it is not there. You can add any general attribute to an object with attr; you can also use attr to look up the value of any attribute of an object. Let’s see how this works with one_play, the result of playing our slot machine one time: one_play &lt;- play() one_play ## 0 attributes(one_play) ## NULL attr takes two arguments: an R object and the name of an attribute (as a character string). To give the R object an attribute of the specified name, save a value to the output of attr. Let’s give one_play an attribute named symbols that contains a vector of character strings: attr(one_play, &quot;symbols&quot;) &lt;- c(&quot;B&quot;, &quot;0&quot;, &quot;B&quot;) attributes(one_play) ## $symbols ## [1] &quot;B&quot; &quot;0&quot; &quot;B&quot; To look up the value of any attribute, give attr an R object and the name of the attribute you would like to look up: attr(one_play, &quot;symbols&quot;) ## &quot;B&quot; &quot;0&quot; &quot;B&quot; If you give an attribute to an atomic vector, like one_play, R will usually display the attribute beneath the vector’s values. However, if the attribute changes the vector’s class, R may display all of the information in the vector in a new way (as we saw with POSIXct objects): one_play ## [1] 0 ## attr(,&quot;symbols&quot;) ## [1] &quot;B&quot; &quot;0&quot; &quot;B&quot; R will generally ignore an object’s attributes unless you give them a name that an R function looks for, like names or class. For example, R will ignore the symbols attribute of one_play as you manipulate one_play: one_play + 1 ## 1 ## attr(,&quot;symbols&quot;) ## &quot;B&quot; &quot;0&quot; &quot;B&quot; Exercise 11.1 (Add an Attribute) Modify play to return a prize that contains the symbols associated with it as an attribute named symbols. Remove the redundant call to print(symbols): play &lt;- function() { symbols &lt;- get_symbols() print(symbols) score(symbols) } Solution. You can create a new version of play by capturing the output of score(symbols) and assigning an attribute to it. play can then return the enhanced version of the output: play &lt;- function() { symbols &lt;- get_symbols() prize &lt;- score(symbols) attr(prize, &quot;symbols&quot;) &lt;- symbols prize } Now play returns both the prize and the symbols associated with the prize. The results may not look pretty, but the symbols stick with the prize when we copy it to a new object. We can work on tidying up the display in a minute: play() ## [1] 0 ## attr(,&quot;symbols&quot;) ## [1] &quot;B&quot; &quot;BB&quot; &quot;0&quot; two_play &lt;- play() two_play ## [1] 0 ## attr(,&quot;symbols&quot;) ## [1] &quot;0&quot; &quot;B&quot; &quot;0&quot; You can also generate a prize and set its attributes in one step with the structure function. structure creates an object with a set of attributes. The first argument of structure should be an R object or set of values, and the remaining arguments should be named attributes for structure to add to the object. You can give these arguments any argument names you like. structure will add the attributes to the object under the names that you provide as argument names: play &lt;- function() { symbols &lt;- get_symbols() structure(score(symbols), symbols = symbols) } three_play &lt;- play() three_play ## 0 ## attr(,&quot;symbols&quot;) ## &quot;0&quot; &quot;BB&quot; &quot;B&quot; Now that your play output contains a symbols attribute, what can you do with it? You can write your own functions that lookup and use the attribute. For example, the following function will look up one_play’s symbols attribute and use it to display one_play in a pretty manner. We will use this function to display our slot results, so let’s take a moment to study what it does: slot_display &lt;- function(prize){ # extract symbols symbols &lt;- attr(prize, &quot;symbols&quot;) # collapse symbols into single string symbols &lt;- paste(symbols, collapse = &quot; &quot;) # combine symbol with prize as a character string # \\n is special escape sequence for a new line (i.e. return or enter) string &lt;- paste(symbols, prize, sep = &quot;\\n$&quot;) # display character string in console without quotes cat(string) } slot_display(one_play) ## B 0 B ## $0 The function expects an object like one_play that has both a numerical value and a symbols attribute. The first line of the function will look up the value of the symbols attribute and save it as an object named symbols. Let’s make an example symbols object so we can see what the rest of the function does. We can use one_play’s symbols attribute to do the job. symbols will be a vector of three-character strings: symbols &lt;- attr(one_play, &quot;symbols&quot;) symbols ## &quot;B&quot; &quot;0&quot; &quot;B&quot; Next, slot_display uses paste to collapse the three strings in symbols into a single-character string. paste collapses a vector of character strings into a single string when you give it the collapse argument. paste will use the value of collapse to separate the formerly distinct strings. Hence, symbols becomes B 0 B the three strings separated by a space: symbols &lt;- paste(symbols, collapse = &quot; &quot;) symbols ## &quot;B 0 B&quot; Our function then uses paste in a new way to combine symbols with the value of prize. paste combines separate objects into a character string when you give it a sep argument. For example, here paste will combine the string in symbols, B 0 B, with the number in prize, 0. paste will use the value of sep argument to separate the inputs in the new string. Here, that value is \\n$, so our result will look like \"B 0 B\\n$0\": prize &lt;- one_play string &lt;- paste(symbols, prize, sep = &quot;\\n$&quot;) string ## &quot;B 0 B\\n$0&quot; The last line of slot_display calls cat on the new string. cat is like print; it displays its input at the command line. However, cat does not surround its output with quotation marks. cat also replaces every \\n with a new line or line break. The result is what we see. Notice that it looks just how I suggested that our play output should look in Programs: cat(string) ## B 0 B ## $0 You can use slot_display to manually clean up the output of play: slot_display(play()) ## C B 0 ## $2 slot_display(play()) ## 7 0 BB ## $0 This method of cleaning the output requires you to manually intervene in your R session (to call slot_display). There is a function that you can use to automatically clean up the output of play each time it is displayed. This function is print, and it is a generic function. 11.3 Generic Functions R uses print more often than you may think; R calls print each time it displays a result in your console window. This call happens in the background, so you do not notice it; but the call explains how output makes it to the console window (recall that print always prints its argument in the console window). This print call also explains why the output of print always matches what you see when you display an object at the command line: print(pi) ## 3.141593 pi ## 3.141593 print(head(deck)) ## face suit value ## king spades 13 ## queen spades 12 ## jack spades 11 ## ten spades 10 ## nine spades 9 ## eight spades 8 head(deck) ## face suit value ## king spades 13 ## queen spades 12 ## jack spades 11 ## ten spades 10 ## nine spades 9 ## eight spades 8 print(play()) ## 5 ## attr(,&quot;symbols&quot;) ## &quot;B&quot; &quot;BB&quot; &quot;B&quot; play() ## 5 ## attr(,&quot;symbols&quot;) ## &quot;B&quot; &quot;BB&quot; &quot;B&quot; You can change how R displays your slot output by rewriting print to look like slot_display. Then R would print the output in our tidy format. However, this method would have negative side effects. You do not want R to call slot_display when it prints a data frame, a numerical vector, or any other object. Fortunately, print is not a normal function; it is a generic function. This means that print is written in a way that lets it do different things in different cases. You’ve already seen this behavior in action (although you may not have realized it). print did one thing when we looked at the unclassed version of num: num &lt;- 1000000000 print(num) ## 1000000000 and a different thing when we gave num a class: class(num) &lt;- c(&quot;POSIXct&quot;, &quot;POSIXt&quot;) print(num) ## &quot;2001-09-08 19:46:40 CST&quot; Take a look at the code inside print to see how it does this. You may imagine that print looks up the class attribute of its input and then uses an +if+ tree to pick which output to display. If this occurred to you, great job! print does something very similar, but much more simple. 11.4 Methods When you call print, print calls a special function, UseMethod: print ## function (x, ...) ## UseMethod(&quot;print&quot;) ## &lt;bytecode: 0x7ffee4c62f80&gt; ## &lt;environment: namespace:base&gt; UseMethod examines the class of the input that you provide for the first argument of print, and then passes all of your arguments to a new function designed to handle that class of input. For example, when you give print a POSIXct object, UseMethod will pass all of print’s arguments to print.POSIXct. R will then run print.POSIXct and return the results: print.POSIXct ## function (x, ...) ## { ## max.print &lt;- getOption(&quot;max.print&quot;, 9999L) ## if (max.print &lt; length(x)) { ## print(format(x[seq_len(max.print)], usetz = TRUE), ...) ## cat(&quot; [ reached getOption(\\&quot;max.print\\&quot;) -- omitted&quot;, ## length(x) - max.print, &quot;entries ]\\n&quot;) ## } ## else print(format(x, usetz = TRUE), ...) ## invisible(x) ## } ## &lt;bytecode: 0x7fa948f3d008&gt; ## &lt;environment: namespace:base&gt; If you give print a factor object, UseMethod will pass all of print’s arguments to print.factor. R will then run print.factor and return the results: print.factor ## function (x, quote = FALSE, max.levels = NULL, width = getOption(&quot;width&quot;), ## ...) ## { ## ord &lt;- is.ordered(x) ## if (length(x) == 0L) ## cat(if (ord) ## &quot;ordered&quot; ## ... ## drop &lt;- n &gt; maxl ## cat(if (drop) ## paste(format(n), &quot;&quot;), T0, paste(if (drop) ## c(lev[1L:max(1, maxl - 1)], &quot;...&quot;, if (maxl &gt; 1) lev[n]) ## else lev, collapse = colsep), &quot;\\n&quot;, sep = &quot;&quot;) ## } ## invisible(x) ## } ## &lt;bytecode: 0x7fa94a64d470&gt; ## &lt;environment: namespace:base&gt; print.POSIXct and print.factor are called methods of print. By themselves, print.POSIXct and print.factor work like regular R functions. However, each was written specifically so UseMethod could call it to handle a specific class of print input. Notice that print.POSIXct and print.factor do two different things (also notice that I abridged the middle of print.factor—it is a long function). This is how print manages to do different things in different cases. print calls UseMethod, which calls a specialized method based on the class of print’s first argument. You can see which methods exist for a generic function by calling methods on the function. For example, print has almost 200 methods (which gives you an idea of how many classes exist in R): methods(print) ## [1] print.acf* ## [2] print.anova ## [3] print.aov* ## ... ## [176] print.xgettext* ## [177] print.xngettext* ## [178] print.xtabs* ## ## Nonvisible functions are asterisked This system of generic functions, methods, and class-based dispatch is known as S3 because it originated in the third version of S, the programming language that would evolve into S-PLUS and R. Many common R functions are S3 generics that work with a set of class methods. For example, summary and head also call UseMethod. More basic functions, like c, +, -, &lt; and others also behave like generic functions, although they call .primitive instead of UseMethod. The S3 system allows R functions to behave in different ways for different classes. You can use S3 to format your slot output. First, give your output its own class. Then write a print method for that class. To do this efficiently, you will need to know a little about how UseMethod selects a method function to use. 11.4.1 Method Dispatch UseMethod uses a very simple system to match methods to functions. Every S3 method has a two-part name. The first part of the name will refer to the function that the method works with. The second part will refer to the class. These two parts will be separated by a period. So for example, the print method that works with functions will be called print.function. The summary method that works with matrices will be called summary.matrix. And so on. When UseMethod needs to call a method, it searches for an R function with the correct S3-style name. The function does not have to be special in any way; it just needs to have the correct name. You can participate in this system by writing your own function and giving it a valid S3-style name. For example, let’s give one_play a class of its own. It doesn’t matter what you call the class; R will store any character string in the class attribute: class(one_play) &lt;- &quot;slots&quot; Now let’s write an S3 print method for the +slots+ class. The method doesn’t need to do anything special—it doesn’t even need to print one_play. But it does need to be named print.slots; otherwise UseMethod will not find it. The method should also take the same arguments as print; otherwise, R will give an error when it tries to pass the arguments to print.slots: args(print) ## function (x, ...) ## NULL print.slots &lt;- function(x, ...) { cat(&quot;I&#39;m using the print.slots method&quot;) } Does our method work? Yes, and not only that; R uses the print method to display the contents of one_play. This method isn’t very useful, so I’m going to remove it. You’ll have a chance to write a better one in a minute: print(one_play) ## I&#39;m using the print.slots method one_play ## I&#39;m using the print.slots method rm(print.slots) Some R objects have multiple classes. For example, the output of Sys.time has two classes. Which class will UseMethod use to find a print method? now &lt;- Sys.time() attributes(now) ## $class ## [1] &quot;POSIXct&quot; &quot;POSIXt&quot; UseMethod will first look for a method that matches the first class listed in the object’s class vector. If UseMethod cannot find one, it will then look for the method that matches the second class (and so on if there are more classes in an object’s class vector). If you give print an object whose class or classes do not have a print method, UseMethod will call print.default, a special method written to handle general cases. Let’s use this system to write a better print method for the slot machine output. Exercise 11.2 (Make a Print Method) Write a new print method for the slots class. The method should call slot_display to return well-formatted slot-machine output. What name must you use for this method? Solution. It is surprisingly easy to write a good print.slots method because we’ve already done all of the hard work when we wrote slot_display. For example, the following method will work. Just make sure the method is named print.slots so UseMethod can find it, and make sure that it takes the same arguments as print so UseMethod can pass those arguments to print.slots without any trouble: print.slots &lt;- function(x, ...) { slot_display(x) } Now R will automatically use slot_display to display objects of class +slots+ (and only objects of class “slots”): one_play ## B 0 B ## $0 Let’s ensure that every piece of slot machine output has the slots class. Exercise 11.3 (Add a Class) Modify the play function so it assigns slots to the class attribute of its output: play &lt;- function() { symbols &lt;- get_symbols() structure(score(symbols), symbols = symbols) } Solution. You can set the class attribute of the output at the same time that you set the +symbols+ attribute. Just add class = \"slots\" to the structure call: play &lt;- function() { symbols &lt;- get_symbols() structure(score(symbols), symbols = symbols, class = &quot;slots&quot;) } Now each of our slot machine plays will have the class slots: class(play()) ## &quot;slots&quot; As a result, R will display them in the correct slot-machine format: play() ## BB BB BBB ## $5 play() ## BB 0 0 ## $0 11.5 Classes You can use the S3 system to make a robust new class of objects in R. Then R will treat objects of your class in a consistent, sensible manner. To make a class: Choose a name for your class. Assign each instance of your class a +class+ attribute. Write class methods for any generic function likely to use objects of your class. Many R packages are based on classes that have been built in a similar manner. While this work is simple, it may not be easy. For example, consider how many methods exist for predefined classes. You can call methods on a class with the class argument, which takes a character string. methods will return every method written for the class. Notice that methods will not be able to show you methods that come in an unloaded R package: methods(class = &quot;factor&quot;) ## [1] [.factor [[.factor ## [3] [[&lt;-.factor [&lt;-.factor ## [5] all.equal.factor as.character.factor ## [7] as.data.frame.factor as.Date.factor ## [9] as.list.factor as.logical.factor ## [11] as.POSIXlt.factor as.vector.factor ## [13] droplevels.factor format.factor ## [15] is.na&lt;-.factor length&lt;-.factor ## [17] levels&lt;-.factor Math.factor ## [19] Ops.factor plot.factor* ## [21] print.factor relevel.factor* ## [23] relist.factor* rep.factor ## [25] summary.factor Summary.factor ## [27] xtfrm.factor ## ## Nonvisible functions are asterisked This output indicates how much work is required to create a robust, well-behaved class. You will usually need to write a class method for every basic R operation. Consider two challenges that you will face right away. First, R drops attributes (like class) when it combines objects into a vector: play1 &lt;- play() play1 ## B BBB BBB ## $5 play2 &lt;- play() play2 ## 0 B 0 ## $0 c(play1, play2) ## [1] 5 0 Here, R stops using print.slots to display the vector because the vector c(play1, play2) no longer has a “slots” +class+ attribute. Next, R will drop the attributes of an object (like class) when you subset the object: play1[1] ## [1] 5 You can avoid this behavior by writing a c.slots method and a [.slots method, but then difficulties will quickly accrue. How would you combine the symbols attributes of multiple plays into a vector of symbols attributes? How would you change print.slots to handle vectors of outputs? These challenges are open for you to explore. However, you will usually not have to attempt this type of large-scale programming as a data scientist. In our case, it is very handy to let slots objects revert to single prize values when we combine groups of them together into a vector. 11.6 S3 and Debugging S3 can be annoying if you are trying to understand R functions. It is difficult to tell what a function does if its code body contains a call to UseMethod. Now that you know that UseMethod calls a class-specific method, you can search for and examine the method directly. It will be a function whose name follows the &lt;function.class&gt; syntax, or possibly &lt;function.default&gt;. You can also use the methods function to see what methods are associated with a function or a class. 11.7 S4 and R5 R also contains two other systems that create class specific behavior. These are known as S4 and R5 (or reference classes). Each of these systems is much harder to use than S3, and perhaps as a consequence, more rare. However, they offer safeguards that S3 does not. If you’d like to learn more about these systems, including how to write and use your own generic functions, I recommend the book Advanced R Programming by Hadley Wickham. 11.8 Summary Values are not the only place to store information in R, and functions are not the only way to create unique behavior. You can also do both of these things with R’s S3 system. The S3 system provides a simple way to create object-specific behavior in R. In other words, it is R’s version of object-oriented programming (OOP). The system is implemented by generic functions. These functions examine the class attribute of their input and call a class-specific method to generate output. Many S3 methods will look for and use additional information that is stored in an object’s attributes. Many common R functions are S3 generics. R’s S3 system is more helpful for the tasks of computer science than the tasks of data science, but understanding S3 can help you troubleshoot your work in R as a data scientist. You now know quite a bit about how to write R code that performs custom tasks, but how could you repeat these tasks? As a data scientist, you will often repeat tasks, sometimes thousands or even millions of times. Why? Because repetition lets you simulate results and estimate probabilities. Loops will show you how to automate repetition with R’s for and while functions. You’ll use for to simulate various slot machine plays and to calculate the payout rate of your slot machine. "],["loops.html", "12 Loops 12.1 Expected Values 12.2 expand.grid 12.3 for Loops 12.4 while Loops 12.5 repeat Loops 12.6 Summary", " 12 Loops Loops are R’s method for repeating a task, which makes them a useful tool for programming simulations. This chapter will teach you how to use R’s loop tools. Let’s use the score function to solve a real-world problem. Your slot machine is modeled after real machines that were accused of fraud. The machines appeared to pay out 40 cents on the dollar, but the manufacturer claimed that they paid out 92 cents on the dollar. You can calculate the exact payout rate of your machine with the score program. The payout rate will be the expected value of the slot machine’s prize. 12.1 Expected Values The expected value of a random event is a type of weighted average; it is the sum of each possible outcome of the event, weighted by the probability that each outcome occurs: \\[ E(x) = \\sum_{i = 1}^{n}\\left( x_{i} \\cdot P(x_{i}) \\right) \\] You can think of the expected value as the average prize that you would observe if you played the slot machine an infinite number of times. Let’s use the formula to calculate some simple expected values. Then we will apply the formula to your slot machine. Do you remember the die you created in [Project 1: Weighted Dice]? die &lt;- c(1, 2, 3, 4, 5, 6) Each time you roll the die, it returns a value selected at random (one through six). You can find the expected value of rolling the die with the formula: \\[ E(\\text{die}) = \\sum_{i = 1}^{n}\\left( \\text{die}_{i} \\cdot P(\\text{die}_{i}) \\right) \\] The \\(\\text{die}_{i}\\)s are the possible outcomes of rolling the die: 1, 2, 3, 4, 5, and 6; and the \\(P(\\text{die}_{i})\\)’s are the probabilities associated with each of the outcomes. If your die is fair, each outcome will occur with the same probability: 1/6. So our equation simplifies to: \\[ \\begin{array}{rl} E(\\text{die}) &amp; = \\sum_{i = 1}^{n}\\left( \\text{die}_{i} \\cdot P(\\text{die}_{i}) \\right)\\\\ &amp; = 1 \\cdot \\frac{1}{6} + 2 \\cdot \\frac{1}{6} + 3 \\cdot \\frac{1}{6} + 4 \\cdot \\frac{1}{6} + 5 \\cdot \\frac{1}{6} + 6 \\cdot \\frac{1}{6}\\\\ &amp; = 3.5\\\\ \\end{array} \\] Hence, the expected value of rolling a fair die is 3.5. You may notice that this is also the average value of the die. The expected value will equal the average if every outcome has the same chance of occurring. But what if each outcome has a different chance of occurring? For example, we weighted our dice in [Packages and Help Pages] so that each die rolled 1, 2, 3, 4, and 5 with probability 1/8 and 6 with probability 3/8. You can use the same formula to calculate the expected value in these conditions: \\[ \\begin{array}{rl} E(die) &amp; = 1 \\cdot \\frac{1}{8} + 2 \\cdot \\frac{1}{8} + 3 \\cdot \\frac{1}{8} + 4 \\cdot \\frac{1}{8} + 5 \\cdot \\frac{1}{8} + 6 \\cdot \\frac{3}{8}\\\\ &amp; = 4.125\\\\ \\end{array} \\] Hence, the expected value of a loaded die does not equal the average value of its outcomes. If you rolled a loaded die an infinite number of times, the average outcome would be 4.125, which is higher than what you would expect from a fair die. Notice that we did the same three things to calculate both of these expected values. We have: Listed out all of the possible outcomes Determined the value of each outcome (here just the value of the die) Calculated the probability that each outcome occurred The expected value was then just the sum of the values in step 2 multiplied by the probabilities in step 3. You can use these steps to calculate more sophisticated expected values. For example, you could calculate the expected value of rolling a pair of weighted dice. Let’s do this step by step. First, list out all of the possible outcomes. A total of 36 different outcomes can appear when you roll two dice. For example, you might roll (1, 1), which notates one on the first die and one on the second die. Or, you may roll (1, 2), one on the first die and two on the second. And so on. Listing out these combinations can be tedious, but R has a function that can help. 12.2 expand.grid The expand.grid function in R provides a quick way to write out every combination of the elements in n vectors. For example, you can list every combination of two dice. To do so, run expand.grid on two copies of die: rolls &lt;- expand.grid(die, die) expand.grid will return a data frame that contains every way to pair an element from the first die vector with an element from the second die vector. This will capture all 36 possible combinations of values: rolls ## Var1 Var2 ## 1 1 1 ## 2 2 1 ## 3 3 1 ## ... ## 34 4 6 ## 35 5 6 ## 36 6 6 You can use expand.grid with more than two vectors if you like. For example, you could list every combination of rolling three dice with expand.grid(die, die, die) and every combination of rolling four dice with expand.grid(die, die, die, die), and so on. expand.grid will always return a data frame that contains each possible combination of n elements from the n vectors. Each combination will contain exactly one element from each vector. You can determine the value of each roll once you’ve made your list of outcomes. This will be the sum of the two dice, which you can calculate using R’s element-wise execution: rolls$value &lt;- rolls$Var1 + rolls$Var2 head(rolls, 3) ## Var1 Var2 value ## 1 1 2 ## 2 1 3 ## 3 1 4 R will match up the elements in each vector before adding them together. As a result, each element of value will refer to the elements of Var1 and Var2 that appear in the same row. Next, you must determine the probability that each combination appears. You can calculate this with a basic rule of probability: The probability that n independent, random events all occur is equal to the product of the probabilities that each random event occurs. Or more succinctly: \\[ P(A \\&amp; B \\&amp; C \\&amp; ...) = P(A) \\cdot P(B) \\cdot P(C) \\cdot ... \\] So the probability that we roll a (1, 1) will be equal to the probability that we roll a one on the first die, 1/8, times the probability that we roll a one on the second die, 1/8: \\[ \\begin{array}{rl} P(1 \\&amp; 1) &amp; = P(1) \\cdot P(1) \\\\ &amp; = \\frac{1}{8} \\cdot \\frac{1}{8}\\\\ &amp; = \\frac{1}{64} \\end{array} \\] And the probability that we roll a (1, 2) will be: \\[ \\begin{array}{rl} P(1 \\&amp; 2) &amp; = P(1) \\cdot P(2) \\\\ &amp; = \\frac{1}{8} \\cdot \\frac{1}{8}\\\\ &amp; = \\frac{1}{64} \\end{array} \\] And so on. Let me suggest a three-step process for calculating these probabilities in R. First, we can look up the probabilities of rolling the values in Var1. We’ll do this with the lookup table that follows: prob &lt;- c(&quot;1&quot; = 1/8, &quot;2&quot; = 1/8, &quot;3&quot; = 1/8, &quot;4&quot; = 1/8, &quot;5&quot; = 1/8, &quot;6&quot; = 3/8) prob ## 1 2 3 4 5 6 ## 0.125 0.125 0.125 0.125 0.125 0.375 If you subset this table by rolls$Var1, you will get a vector of probabilities perfectly keyed to the values of Var1: rolls$Var1 ## 1 2 3 4 5 6 1 2 3 4 5 6 1 2 3 4 5 6 1 2 3 4 5 6 1 2 3 4 5 6 1 2 3 4 5 6 prob[rolls$Var1] ## 1 2 3 4 5 6 1 2 3 4 5 6 ## 0.125 0.125 0.125 0.125 0.125 0.375 0.125 0.125 0.125 0.125 0.125 0.375 ## 1 2 3 4 5 6 1 2 3 4 5 6 ## 0.125 0.125 0.125 0.125 0.125 0.375 0.125 0.125 0.125 0.125 0.125 0.375 ## 1 2 3 4 5 6 1 2 3 4 5 6 ## 0.125 0.125 0.125 0.125 0.125 0.375 0.125 0.125 0.125 0.125 0.125 0.375 rolls$prob1 &lt;- prob[rolls$Var1] head(rolls, 3) ## Var1 Var2 value prob1 ## 1 1 2 0.125 ## 2 1 3 0.125 ## 3 1 4 0.125 Second, we can look up the probabilities of rolling the values in Var2: rolls$prob2 &lt;- prob[rolls$Var2] head(rolls, 3) ## Var1 Var2 value prob1 prob2 ## 1 1 2 0.125 0.125 ## 2 1 3 0.125 0.125 ## 3 1 4 0.125 0.125 Third, we can calculate the probability of rolling each combination by multiplying prob1 by prob2: rolls$prob &lt;- rolls$prob1 * rolls$prob2 head(rolls, 3) ## Var1 Var2 value prob1 prob2 prob ## 1 1 2 0.125 0.125 0.015625 ## 2 1 3 0.125 0.125 0.015625 ## 3 1 4 0.125 0.125 0.015625 It is easy to calculate the expected value now that we have each outcome, the value of each outcome, and the probability of each outcome. The expected value will be the summation of the dice values multiplied by the dice probabilities: sum(rolls$value * rolls$prob) ## 8.25 So the expected value of rolling two loaded dice is 8.25. If you rolled a pair of loaded dice an infinite number of times, the average sum would be 8.25. (If you are curious, the expected value of rolling a pair of fair dice is 7, which explains why 7 plays such a large role in dice games like craps.) Now that you’ve warmed up, let’s use our method to calculate the expected value of the slot machine prize. We will follow the same steps we just took: We will list out every possible outcome of playing the machine. This will be a list of every combination of three slot symbols. We will calculate the probability of getting each combination when you play the machine. We will determine the prize that we would win for each combination. When we are finished, we will have a data set that looks like this: ## Var1 Var2 Var3 prob1 prob2 prob3 prob prize ## DD DD DD 0.03 0.03 0.03 0.000027 800 ## 7 DD DD 0.03 0.03 0.03 0.000027 0 ## BBB DD DD 0.06 0.03 0.03 0.000054 0 ## ... and so on. The expected value will then be the sum of the prizes multiplied by their probability of occuring: \\[ E(\\text{prize}) = \\sum_{i = 1}^{n}\\left( \\text{prize}_{i} \\cdot P(\\text{prize}_{i}) \\right) \\] Ready to begin? Exercise 12.1 (List the Combinations) Use expand.grid to make a data frame that contains every possible combination of three symbols from the wheel vector: wheel &lt;- c(&quot;DD&quot;, &quot;7&quot;, &quot;BBB&quot;, &quot;BB&quot;, &quot;B&quot;, &quot;C&quot;, &quot;0&quot;) Be sure to add the argument stringsAsFactors = FALSE to your expand.grid call; otherwise, expand.grid will save the combinations as factors, an unfortunate choice that will disrupt the score function. Solution. To create a data frame of each combination of three symbols, you need to run expand.grid and give it three copies of wheel. The result will be a data frame with 343 rows, one for each unique combination of three slot symbols: combos &lt;- expand.grid(wheel, wheel, wheel, stringsAsFactors = FALSE) combos ## Var1 Var2 Var3 ## 1 DD DD DD ## 2 7 DD DD ## 3 BBB DD DD ## 4 BB DD DD ## 5 B DD DD ## 6 C DD DD ## ... ## 341 B 0 0 ## 342 C 0 0 ## 343 0 0 0 Now, let’s calculate the probability of getting each combination. You can use the probabilities contained in the prob argument of get_symbols to do this. These probabilities determine how frequently each symbol is chosen when your slot machine generates symbols. They were calculated after observing 345 plays of the Manitoba video lottery terminals. Zeroes have the largest chance of being selected (0.52) and cherries the least (0.01): get_symbols &lt;- function() { wheel &lt;- c(&quot;DD&quot;, &quot;7&quot;, &quot;BBB&quot;, &quot;BB&quot;, &quot;B&quot;, &quot;C&quot;, &quot;0&quot;) sample(wheel, size = 3, replace = TRUE, prob = c(0.03, 0.03, 0.06, 0.1, 0.25, 0.01, 0.52) } Exercise 12.2 (Make a Lookup Table) Isolate the previous probabilities in a lookup table. What names will you use in your table? Solution. Your names should match the input that you want to look up. In this case, the input will be the character strings that appear in Var1, Var2, and Var3. So your lookup table should look like this: prob &lt;- c(&quot;DD&quot; = 0.03, &quot;7&quot; = 0.03, &quot;BBB&quot; = 0.06, &quot;BB&quot; = 0.1, &quot;B&quot; = 0.25, &quot;C&quot; = 0.01, &quot;0&quot; = 0.52) Now let’s look up our probabilities. Exercise 12.3 (Lookup the Probabilities) Look up the probabilities of getting the values in Var1. Then add them to combos as a column named prob1. Then do the same for Var2 (prob2) and Var3 (prob3). Solution. Remember that you use R’s selection notation to look up values in a lookup table. The values that result will be keyed to the index that you use: combos$prob1 &lt;- prob[combos$Var1] combos$prob2 &lt;- prob[combos$Var2] combos$prob3 &lt;- prob[combos$Var3] head(combos, 3) ## Var1 Var2 Var3 prob1 prob2 prob3 ## DD DD DD 0.03 0.03 0.03 ## 7 DD DD 0.03 0.03 0.03 ## BBB DD DD 0.06 0.03 0.03 Now how should we calculate the total probability of each combination? Our three slot symbols are all chosen independently, which means that the same rule that governed our dice probabilities governs our symbol probabilities: \\[ P(A \\&amp; B \\&amp; C \\&amp; ...) = P(A) \\cdot P(B) \\cdot P(C) \\cdot ... \\] Exercise 12.4 (Calculate Probabilities for Each Combination) Calculate the overall probabilities for each combination. Save them as a column named prob in combos, then check your work. You can check that the math worked by summing the probabilities. The probabilities should add up to one, because one of the combinations must appear when you play the slot machine. In other words, a combination will appear, with probability of one. You can calculate the probabilities of every possible combination in one fell swoop with some element-wise execution: combos$prob &lt;- combos$prob1 * combos$prob2 * combos$prob3 head(combos, 3) ## Var1 Var2 Var3 prob1 prob2 prob3 prob ## DD DD DD 0.03 0.03 0.03 0.000027 ## 7 DD DD 0.03 0.03 0.03 0.000027 ## BBB DD DD 0.06 0.03 0.03 0.000054 The sum of the probabilities is one, which suggests that our math is correct: sum(combos$prob) ## 1 You only need to do one more thing before you can calculate the expected value: you must determine the prize for each combination in combos. You can calculate the prize with score. For example, we can calculate the prize for the first row of combos like this: symbols &lt;- c(combos[1, 1], combos[1, 2], combos[1, 3]) ## &quot;DD&quot; &quot;DD&quot; &quot;DD&quot; score(symbols) ## 800 However there are 343 rows, which makes for tedious work if you plan to calculate the scores manually. It will be quicker to automate this task and have R do it for you, which you can do with a for loop. 12.3 for Loops A for loop repeats a chunk of code many times, once for each element in a set of input. for loops provide a way to tell R, “Do this for every value of that.” In R syntax, this looks like: for (value in that) { this } The that object should be a set of objects (often a vector of numbers or character strings). The for loop will run the code in that appears between the braces once for each member of that. For example, the for loop below runs print(\"one run\") once for each element in a vector of character strings: for (value in c(&quot;My&quot;, &quot;first&quot;, &quot;for&quot;, &quot;loop&quot;)) { print(&quot;one run&quot;) } ## &quot;one run&quot; ## &quot;one run&quot; ## &quot;one run&quot; ## &quot;one run&quot; The value symbol in a for loop acts like an argument in a function. The for loop will create an object named value and assign it a new value on each run of the loop. The code in your loop can access this value by calling the value object. What values will the for loop assign to value? It will use the elements in the set that you run the loop on. for starts with the first element and then assigns a different element to value on each run of the for loop, until all of the elements have been assigned to value. For example, the for loop below will run print(value) four times and will print out one element of c(\"My\", \"second\", \"for\", \"loop\") each time: for (value in c(&quot;My&quot;, &quot;second&quot;, &quot;for&quot;, &quot;loop&quot;)) { print(value) } ## &quot;My&quot; ## &quot;second&quot; ## &quot;for&quot; ## &quot;loop&quot; On the first run, the for loop substituted \"My\" for value in print(value). On the second run it substituted \"second\", and so on until for had run print(value) once with every element in the set: If you look at value after the loop runs, you will see that it still contains the value of the last element in the set: value ## &quot;loop&quot; I’ve been using the symbol value in my for loops, but there is nothing special about it. You can use any symbol you like in your loop to do the same thing as long as the symbol appears before in in the parentheses that follow for. For example, you could rewrite the previous loop with any of the following: for (word in c(&quot;My&quot;, &quot;second&quot;, &quot;for&quot;, &quot;loop&quot;)) { print(word) } for (string in c(&quot;My&quot;, &quot;second&quot;, &quot;for&quot;, &quot;loop&quot;)) { print(string) } for (i in c(&quot;My&quot;, &quot;second&quot;, &quot;for&quot;, &quot;loop&quot;)) { print(i) } Choose your symbols carefully R will run your loop in whichever environment you call it from. This is bad news if your loop uses object names that already exist in the environment. Your loop will overwrite the existing objects with the objects that it creates. This applies to the value symbol as well. For loops run on sets In many programming languages, for loops are designed to work with integers, not sets. You give the loop a starting value and an ending value, as well as an increment to advance the value by between loops. The for loop then runs until the loop value exceeds the ending value. You can recreate this effect in R by having a for loop execute on a set of integers, but don’t lose track of the fact that R’s for loops execute on members of a set, not sequences of integers. for loops are very useful in programming because they help you connect a piece of code with each element in a set. For example, we could use a for loop to run score once for each row in combos. However, R’s for loops have a shortcoming that you’ll want to know about before you start using them: for loops do not return output. for loops are like Las Vegas: what happens in a for loop stays in a for loop. If you want to use the products of a for loop, you must write the for loop so that it saves its own output as it goes. Our previous examples appeared to return output, but this was misleading. The examples worked because we called print, which always prints its arguments in the console (even if it is called from a function, a for loop, or anything else). Our for loops won’t return anything if you remove the print call: for (value in c(&quot;My&quot;, &quot;third&quot;, &quot;for&quot;, &quot;loop&quot;)) { value } ## To save output from a for loop, you must write the loop so that it saves its own output as it runs. You can do this by creating an empty vector or list before you run the for loop. Then use the for loop to fill up the vector or list. When the for loop is finished, you’ll be able to access the vector or list, which will now have all of your results. Let’s see this in action. The following code creates an empty vector of length 4: chars &lt;- vector(length = 4) The next loop will fill it with strings: words &lt;- c(&quot;My&quot;, &quot;fourth&quot;, &quot;for&quot;, &quot;loop&quot;) for (i in 1:4) { chars[i] &lt;- words[i] } chars ## &quot;My&quot; &quot;fourth&quot; &quot;for&quot; &quot;loop&quot; This approach will usually require you to change the sets that you execute your for loop on. Instead of executing on a set of objects, execute on a set of integers that you can use to index both your object and your storage vector. This approach is very common in R. You’ll find in practice that you use for loops not so much to run code, but to fill up vectors and lists with the results of code. Let’s use a for loop to calculate the prize for each row in combos. To begin, create a new column in combos to store the results of the for loop: combos$prize &lt;- NA head(combos, 3) ## Var1 Var2 Var3 prob1 prob2 prob3 prob prize ## DD DD DD 0.03 0.03 0.03 0.000027 NA ## 7 DD DD 0.03 0.03 0.03 0.000027 NA ## BBB DD DD 0.06 0.03 0.03 0.000054 NA The code creates a new column named prize and fills it with NAs. R uses its recycling rules to populate every value of the column with NA. Exercise 12.5 (Build a Loop) Construct a for loop that will run score on all 343 rows of combos. The loop should run score on the first three entries of the _i_th row of combos and should store the results in the _i_th entry of combos$prize. Solution. You can score the rows in combos with: for (i in 1:nrow(combos)) { symbols &lt;- c(combos[i, 1], combos[i, 2], combos[i, 3]) combos$prize[i] &lt;- score(symbols) } After you run the for loop, combos$prize will contain the correct prize for each row. This exercise also tests the score function; score appears to work correctly for every possible slot combination: head(combos, 3) ## Var1 Var2 Var3 prob1 prob2 prob3 prob prize ## DD DD DD 0.03 0.03 0.03 0.000027 800 ## 7 DD DD 0.03 0.03 0.03 0.000027 0 ## BBB DD DD 0.06 0.03 0.03 0.000054 0 We’re now ready to calculate the expected value of the prize. The expected value is the sum of combos$prize weighted by combos$prob. This is also the payout rate of the slot machine: sum(combos$prize * combos$prob) ## 0.538014 Uh oh. The expected prize is about 0.54, which means our slot machine only pays 54 cents on the dollar over the long run. Does this mean that the manufacturer of the Manitoba slot machines was lying? No, because we ignored an important feature of the slot machine when we wrote score: a diamond is wild. You can treat a DD as any other symbol if it increases your prize, with one exception. You cannot make a DD a C unless you already have another C in your symbols (it’d be too easy if every DD automatically earned you $2). The best thing about DDs is that their effects are cumulative. For example, consider the combination B, DD, B. Not only does the DD count as a B, which would earn a prize of $10; the DD also doubles the prize to $20. Adding this behavior to our code is a little tougher than what we have done so far, but it involves all of the same principles. You can decide that your slot machine doesn’t use wilds and keep the code that we have. In that case, your slot machine will have a payout rate of about 54 percent. Or, you could rewrite your code to use wilds. If you do, you will find that your slot machine has a payout rate of 93 percent, one percent higher than the manufacturer’s claim. You can calculate this rate with the same method that we used in this section. Exercise 12.6 (Challenge) There are many ways to modify score that would count DDs as wild. If you would like to test your skill as an R programmer, try to write your own version of score that correctly handles diamonds. If you would like a more modest challenge, study the following score code. It accounts for wild diamonds in a way that I find elegant and succinct. See if you can understand each step in the code and how it achieves its result. Solution. Here is a version of score that handles wild diamonds: score &lt;- function(symbols) { diamonds &lt;- sum(symbols == &quot;DD&quot;) cherries &lt;- sum(symbols == &quot;C&quot;) # identify case # since diamonds are wild, only nondiamonds # matter for three of a kind and all bars slots &lt;- symbols[symbols != &quot;DD&quot;] same &lt;- length(unique(slots)) == 1 bars &lt;- slots %in% c(&quot;B&quot;, &quot;BB&quot;, &quot;BBB&quot;) # assign prize if (diamonds == 3) { prize &lt;- 100 } else if (same) { payouts &lt;- c(&quot;7&quot; = 80, &quot;BBB&quot; = 40, &quot;BB&quot; = 25, &quot;B&quot; = 10, &quot;C&quot; = 10, &quot;0&quot; = 0) prize &lt;- unname(payouts[slots[1]]) } else if (all(bars)) { prize &lt;- 5 } else if (cherries &gt; 0) { # diamonds count as cherries # so long as there is one real cherry prize &lt;- c(0, 2, 5)[cherries + diamonds + 1] } else { prize &lt;- 0 } # double for each diamond prize * 2^diamonds } Exercise 12.7 (Calculate the Expected Value) Calculate the expected value of the slot machine when it uses the new score function. You can use the existing combos data frame, but you will need to build a for loop to recalculate combos$prize. To update the expected value, just update combos$prize: for (i in 1:nrow(combos)) { symbols &lt;- c(combos[i, 1], combos[i, 2], combos[i, 3]) combos$prize[i] &lt;- score(symbols) } Then recompute the expected value: sum(combos$prize * combos$prob) ## 0.934356 This result vindicates the manufacturer’s claim. If anything, the slot machines seem more generous than the manufacturer stated. 12.4 while Loops R has two companions to the for loop: the while loop and the repeat loop. A while loop reruns a chunk while a certain condition remains TRUE. To create a while loop, follow while by a condition and a chunk of code, like this: while (condition) { code } while will rerun condition, which should be a logical test, at the start of each loop. If condition evaluates to TRUE, while will run the code between its braces. If condition evaluates to FALSE, while will finish the loop. Why might condition change from TRUE to FALSE? Presumably because the code inside your loop has changed whether the condition is still TRUE. If the code has no relationship to the condition, a while loop will run until you stop it. So be careful. You can stop a while loop by hitting Escape or by clicking on the stop-sign icon at the top of the RStudio console pane. The icon will appear once the loop begins to run. Like for loops, while loops do not return a result, so you must think about what you want the loop to return and save it to an object during the loop. You can use while loops to do things that take a varying number of iterations, like calculating how long it takes to go broke playing slots (as follows). However, in practice, while loops are much less common than for loops in R: plays_till_broke &lt;- function(start_with) { cash &lt;- start_with n &lt;- 0 while (cash &gt; 0) { cash &lt;- cash - 1 + play() n &lt;- n + 1 } n } plays_till_broke(100) ## 260 12.5 repeat Loops repeat loops are even more basic than while loops. They will repeat a chunk of code until you tell them to stop (by hitting Escape) or until they encounter the command break, which will stop the loop. You can use a repeat loop to recreate plays_till_broke, my function that simulates how long it takes to lose money while playing slots: plays_till_broke &lt;- function(start_with) { cash &lt;- start_with n &lt;- 0 repeat { cash &lt;- cash - 1 + play() n &lt;- n + 1 if (cash &lt;= 0) { break } } n } plays_till_broke(100) ## 237 12.6 Summary You can repeat tasks in R with for, while, and repeat loops. To use for, give it a chunk of code to run and a set of objects to loop through. for will run the code chunk once for each object. If you wish to save the output of your loop, you can assign it to an object that exists outside of the loop. Repetition plays an important role in data science. It is the basis for simulation, as well as for estimates of variance and probability. Loops are not the only way to create repetition in R (consider replicate for example), but they are one of the most popular ways. Unfortunately, loops in R can sometimes be slower than loops in other languages. As a result, R’s loops get a bad rap. This reputation is not entirely deserved, but it does highlight an important issue. Speed is essential to data analysis. When your code runs fast, you can work with bigger data and do more to it before you run out of time or computational power. Speed will teach you how to write fast for loops and fast code in general with R. There, you will learn to write vectorized code, a style of lightning-fast code that takes advantage of all of R’s strengths. "],["speed.html", "13 Speed 13.1 Vectorized Code 13.2 How to Write Vectorized Code 13.3 How to Write Fast for Loops in R 13.4 Vectorized Code in Practice 13.5 Summary 13.6 Project 3 Wrap-up", " 13 Speed As a data scientist, you need speed. You can work with bigger data and do more ambitious tasks when your code runs fast. This chapter will show you a specific way to write fast code in R. You will then use the method to simulate 10 million plays of your slot machine. 13.1 Vectorized Code You can write a piece of code in many different ways, but the fastest R code will usually take advantage of three things: logical tests, subsetting, and element-wise execution. These are the things that R does best. Code that uses these things usually has a certain quality: it is vectorized; the code can take a vector of values as input and manipulate each value in the vector at the same time. To see what vectorized code looks like, compare these two examples of an absolute value function. Each takes a vector of numbers and transforms it into a vector of absolute values (e.g., positive numbers). The first example is not vectorized; abs_loop uses a for loop to manipulate each element of the vector one at a time: abs_loop &lt;- function(vec){ for (i in 1:length(vec)) { if (vec[i] &lt; 0) { vec[i] &lt;- -vec[i] } } vec } The second example, abs_set, is a vectorized version of abs_loop. It uses logical subsetting to manipulate every negative number in the vector at the same time: abs_sets &lt;- function(vec){ negs &lt;- vec &lt; 0 vec[negs] &lt;- vec[negs] * -1 vec } abs_set is much faster than abs_loop because it relies on operations that R does quickly: logical tests, subsetting, and element-wise execution. You can use the system.time function to see just how fast abs_set is. system.time takes an R expression, runs it, and then displays how much time elapsed while the expression ran. To compare abs_loop and abs_set, first make a long vector of positive and negative numbers. long will contain 10 million values: long &lt;- rep(c(-1, 1), 5000000) rep repeats a value, or vector of values, many times. To use rep, give it a vector of values and then the number of times to repeat the vector. R will return the results as a new, longer vector. You can then use system.time to measure how much time it takes each function to evaluate long: system.time(abs_loop(long)) ## user system elapsed ## 15.982 0.032 16.018 system.time(abs_sets(long)) ## user system elapsed ## 0.529 0.063 0.592 Don’t confuse system.time with Sys.time, which returns the current time. The first two columns of the output of system.time report how many seconds your computer spent executing the call on the user side and system sides of your process, a dichotomy that will vary from OS to OS. The last column displays how many seconds elapsed while R ran the expression. The results show that abs_set calculated the absolute value 30 times faster than abs_loop when applied to a vector of 10 million numbers. You can expect similar speed-ups whenever you write vectorized code. Exercise 13.1 (How fast is abs?) Many preexisting R functions are already vectorized and have been optimized to perform quickly. You can make your code faster by relying on these functions whenever possible. For example, R comes with a built-in absolute value function, abs. Check to see how much faster abs computes the absolute value of long than abs_loop and abs_set do. Solution. You can measure the speed of abs with system.time. It takes abs a lightning-fast 0.05 seconds to calculate the absolute value of 10 million numbers. This is 0.592 / 0.054 = 10.96 times faster than abs_set and nearly 300 times faster than abs_loop: system.time(abs(long)) ## user system elapsed ## 0.037 0.018 0.054 13.2 How to Write Vectorized Code Vectorized code is easy to write in R because most R functions are already vectorized. Code based on these functions can easily be made vectorized and therefore fast. To create vectorized code: Use vectorized functions to complete the sequential steps in your program. Use logical subsetting to handle parallel cases. Try to manipulate every element in a case at once. abs_loop and abs_set illustrate these rules. The functions both handle two cases and perform one sequential step, Figure 13.1. If a number is positive, the functions leave it alone. If a number is negative, the functions multiply it by negative one. Figure 13.1: abs_loop uses a for loop to sift data into one of two cases: negative numbers and nonnegative numbers. You can identify all of the elements of a vector that fall into a case with a logical test. R will execute the test in element-wise fashion and return a TRUE for every element that belongs in the case. For example, vec &lt; 0 identifies every value of vec that belongs to the negative case. You can use the same logical test to extract the set of negative values with logical subsetting: vec &lt;- c(1, -2, 3, -4, 5, -6, 7, -8, 9, -10) vec &lt; 0 ## FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE vec[vec &lt; 0] ## -2 -4 -6 -8 -10 The plan in Figure 13.1 now requires a sequential step: you must multiply each of the negative values by negative one. All of R’s arithmetic operators are vectorized, so you can use * to complete this step in vectorized fashion. * will multiply each number in vec[vec &lt; 0] by negative one at the same time: vec[vec &lt; 0] * -1 ## 2 4 6 8 10 Finally, you can use R’s assignment operator, which is also vectorized, to save the new set over the old set in the original vec object. Since &lt;- is vectorized, the elements of the new set will be paired up to the elements of the old set, in order, and then element-wise assignment will occur. As a result, each negative value will be replaced by its positive partner, as in Figure 13.2. Figure 13.2: Use logical subsetting to modify groups of values in place. R’s arithmetic and assignment operators are vectorized, which lets you manipulate and update multiple values at once. Exercise 13.2 (Vectorize a Function) The following function converts a vector of slot symbols to a vector of new slot symbols. Can you vectorize it? How much faster does the vectorized version work? change_symbols &lt;- function(vec){ for (i in 1:length(vec)){ if (vec[i] == &quot;DD&quot;) { vec[i] &lt;- &quot;joker&quot; } else if (vec[i] == &quot;C&quot;) { vec[i] &lt;- &quot;ace&quot; } else if (vec[i] == &quot;7&quot;) { vec[i] &lt;- &quot;king&quot; }else if (vec[i] == &quot;B&quot;) { vec[i] &lt;- &quot;queen&quot; } else if (vec[i] == &quot;BB&quot;) { vec[i] &lt;- &quot;jack&quot; } else if (vec[i] == &quot;BBB&quot;) { vec[i] &lt;- &quot;ten&quot; } else { vec[i] &lt;- &quot;nine&quot; } } vec } vec &lt;- c(&quot;DD&quot;, &quot;C&quot;, &quot;7&quot;, &quot;B&quot;, &quot;BB&quot;, &quot;BBB&quot;, &quot;0&quot;) change_symbols(vec) ## &quot;joker&quot; &quot;ace&quot; &quot;king&quot; &quot;queen&quot; &quot;jack&quot; &quot;ten&quot; &quot;nine&quot; many &lt;- rep(vec, 1000000) system.time(change_symbols(many)) ## user system elapsed ## 30.057 0.031 30.079 Solution. change_symbols uses a for loop to sort values into seven different cases, as demonstrated in Figure 13.3. To vectorize change_symbols, create a logical test that can identify each case: vec[vec == &quot;DD&quot;] ## &quot;DD&quot; vec[vec == &quot;C&quot;] ## &quot;C&quot; vec[vec == &quot;7&quot;] ## &quot;7&quot; vec[vec == &quot;B&quot;] ## &quot;B&quot; vec[vec == &quot;BB&quot;] ## &quot;BB&quot; vec[vec == &quot;BBB&quot;] ## &quot;BBB&quot; vec[vec == &quot;0&quot;] ## &quot;0&quot; Figure 13.3: change_many does something different for each of seven cases. Then write code that can change the symbols for each case: vec[vec == &quot;DD&quot;] &lt;- &quot;joker&quot; vec[vec == &quot;C&quot;] &lt;- &quot;ace&quot; vec[vec == &quot;7&quot;] &lt;- &quot;king&quot; vec[vec == &quot;B&quot;] &lt;- &quot;queen&quot; vec[vec == &quot;BB&quot;] &lt;- &quot;jack&quot; vec[vec == &quot;BBB&quot;] &lt;- &quot;ten&quot; vec[vec == &quot;0&quot;] &lt;- &quot;nine&quot; When you combine this into a function, you have a vectorized version of change_symbols that runs about 14 times faster: change_vec &lt;- function (vec) { vec[vec == &quot;DD&quot;] &lt;- &quot;joker&quot; vec[vec == &quot;C&quot;] &lt;- &quot;ace&quot; vec[vec == &quot;7&quot;] &lt;- &quot;king&quot; vec[vec == &quot;B&quot;] &lt;- &quot;queen&quot; vec[vec == &quot;BB&quot;] &lt;- &quot;jack&quot; vec[vec == &quot;BBB&quot;] &lt;- &quot;ten&quot; vec[vec == &quot;0&quot;] &lt;- &quot;nine&quot; vec } system.time(change_vec(many)) ## user system elapsed ## 1.994 0.059 2.051 Or, even better, use a lookup table. Lookup tables are a vectorized method because they rely on R’s vectorized selection operations: change_vec2 &lt;- function(vec){ tb &lt;- c(&quot;DD&quot; = &quot;joker&quot;, &quot;C&quot; = &quot;ace&quot;, &quot;7&quot; = &quot;king&quot;, &quot;B&quot; = &quot;queen&quot;, &quot;BB&quot; = &quot;jack&quot;, &quot;BBB&quot; = &quot;ten&quot;, &quot;0&quot; = &quot;nine&quot;) unname(tb[vec]) } system.time(change_vec(many)) ## user system elapsed ## 0.687 0.059 0.746 Here, a lookup table is 40 times faster than the original function. abs_loop and change_many illustrate a characteristic of vectorized code: programmers often write slower, nonvectorized code by relying on unnecessary for loops, like the one in change_many. I think this is the result of a general misunderstanding about R. for loops do not behave the same way in R as they do in other languages, which means you should write code differently in R than you would in other languages. When you write in languages like C and Fortran, you must compile your code before your computer can run it. This compilation step optimizes how the for loops in the code use your computer’s memory, which makes the for loops very fast. As a result, many programmers use for loops frequently when they write in C and Fortran. When you write in R, however, you do not compile your code. You skip this step, which makes programming in R a more user-friendly experience. Unfortunately, this also means you do not give your loops the speed boost they would receive in C or Fortran. As a result, your loops will run slower than the other operations we have studied: logical tests, subsetting, and element-wise execution. If you can write your code with the faster operations instead of a for loop, you should do so. No matter which language you write in, you should try to use the features of the language that run the fastest. if and for A good way to spot for loops that could be vectorized is to look for combinations of if and for. if can only be applied to one value at a time, which means it is often used in conjunction with a for loop. The for loop helps apply if to an entire vector of values. This combination can usually be replaced with logical subsetting, which will do the same thing but run much faster. This doesn’t mean that you should never use for loops in R. There are still many places in R where for loops make sense. for loops perform a basic task that you cannot always recreate with vectorized code. for loops are also easy to understand and run reasonably fast in R, so long as you take a few precautions. 13.3 How to Write Fast for Loops in R You can dramatically increase the speed of your for loops by doing two things to optimize each loop. First, do as much as you can outside of the for loop. Every line of code that you place inside of the for loop will be run many, many times. If a line of code only needs to be run once, place it outside of the loop to avoid repetition. Second, make sure that any storage objects that you use with the loop are large enough to contain all of the results of the loop. For example, both loops below will need to store one million values. The first loop stores its values in an object named output that begins with a length of one million: system.time({ output &lt;- rep(NA, 1000000) for (i in 1:1000000) { output[i] &lt;- i + 1 } }) ## user system elapsed ## 1.709 0.015 1.724 The second loop stores its values in an object named output that begins with a length of one. R will expand the object to a length of one million as it runs the loop. The code in this loop is very similar to the code in the first loop, but the loop takes 37 minutes longer to run than the first loop: system.time({ output &lt;- NA for (i in 1:1000000) { output[i] &lt;- i + 1 } }) ## user system elapsed ## 1689.537 560.951 2249.927 The two loops do the same thing, so what accounts for the difference? In the second loop, R has to increase the length of output by one for each run of the loop. To do this, R needs to find a new place in your computer’s memory that can contain the larger object. R must then copy the output vector over and erase the old version of output before moving on to the next run of the loop. By the end of the loop, R has rewritten output in your computer’s memory one million times. In the first case, the size of output never changes; R can define one output object in memory and use it for each run of the for loop. The authors of R use low-level languages like C and Fortran to write basic R functions, many of which use for loops. These functions are compiled and optimized before they become a part of R, which makes them quite fast. Whenever you see .Primitive, .Internal, or .Call written in a function’s definition, you can be confident the function is calling code from another language. You’ll get all of the speed advantages of that language by using the function. 13.4 Vectorized Code in Practice To see how vectorized code can help you as a data scientist, consider our slot machine project. In Loops, you calculated the exact payout rate for your slot machine, but you could have estimated this payout rate with a simulation. If you played the slot machine many, many times, the average prize over all of the plays would be a good estimate of the true payout rate. This method of estimation is based on the law of large numbers and is similar to many statistical simulations. To run this simulation, you could use a for loop: winnings &lt;- vector(length = 1000000) for (i in 1:1000000) { winnings[i] &lt;- play() } mean(winnings) ## 0.9366984 The estimated payout rate after 10 million runs is 0.937, which is very close to the true payout rate of 0.934. Note that I’m using the modified score function that treats diamonds as wilds. If you run this simulation, you will notice that it takes a while to run. In fact, the simulation takes 342,308 seconds to run, which is about 5.7 minutes. This is not particularly impressive, and you can do better by using vectorized code: system.time(for (i in 1:1000000) { winnings[i] &lt;- play() }) ## user system elapsed ## 342.041 0.355 342.308 The current score function is not vectorized. It takes a single slot combination and uses an if tree to assign a prize to it. This combination of an if tree with a for loop suggests that you could write a piece of vectorized code that takes many slot combinations and then uses logical subsetting to operate on them all at once. For example, you could rewrite get_symbols to generate n slot combinations and return them as an n x 3 matrix, like the one that follows. Each row of the matrix will contain one slot combination to be scored: get_many_symbols &lt;- function(n) { wheel &lt;- c(&quot;DD&quot;, &quot;7&quot;, &quot;BBB&quot;, &quot;BB&quot;, &quot;B&quot;, &quot;C&quot;, &quot;0&quot;) vec &lt;- sample(wheel, size = 3 * n, replace = TRUE, prob = c(0.03, 0.03, 0.06, 0.1, 0.25, 0.01, 0.52)) matrix(vec, ncol = 3) } get_many_symbols(5) ## [,1] [,2] [,3] ## [1,] &quot;B&quot; &quot;0&quot; &quot;B&quot; ## [2,] &quot;0&quot; &quot;BB&quot; &quot;7&quot; ## [3,] &quot;0&quot; &quot;0&quot; &quot;BBB&quot; ## [4,] &quot;0&quot; &quot;0&quot; &quot;B&quot; ## [5,] &quot;BBB&quot; &quot;0&quot; &quot;0&quot; You could also rewrite play to take a parameter, n, and return n prizes, in a data frame: play_many &lt;- function(n) { symb_mat &lt;- get_many_symbols(n = n) data.frame(w1 = symb_mat[,1], w2 = symb_mat[,2], w3 = symb_mat[,3], prize = score_many(symb_mat)) } This new function would make it easy to simulate a million, or even 10 million plays of the slot machine, which will be our goal. When we’re finished, you will be able to estimate the payout rate with: # plays &lt;- play_many(10000000)) # mean(plays$prize) Now you just need to write score_many, a vectorized (matix-ized?) version of score that takes an n x 3 matrix and returns n prizes. It will be difficult to write this function because score is already quite complicated. I would not expect you to feel confident doing this on your own until you have more practice and experience than we’ve been able to develop here. Should you like to test your skills and write a version of score_many, I recommend that you use the function rowSums within your code. It calculates the sum of each row of numbers (or logicals) in a matrix. If you would like to test yourself in a more modest way, I recommend that you study the following model score_many function until you understand how each part works and how the parts work together to create a vectorized function. To do this, it will be helpful to create a concrete example, like this: symbols &lt;- matrix( c(&quot;DD&quot;, &quot;DD&quot;, &quot;DD&quot;, &quot;C&quot;, &quot;DD&quot;, &quot;0&quot;, &quot;B&quot;, &quot;B&quot;, &quot;B&quot;, &quot;B&quot;, &quot;BB&quot;, &quot;BBB&quot;, &quot;C&quot;, &quot;C&quot;, &quot;0&quot;, &quot;7&quot;, &quot;DD&quot;, &quot;DD&quot;), nrow = 6, byrow = TRUE) symbols ## [,1] [,2] [,3] ## [1,] &quot;DD&quot; &quot;DD&quot; &quot;DD&quot; ## [2,] &quot;C&quot; &quot;DD&quot; &quot;0&quot; ## [3,] &quot;B&quot; &quot;B&quot; &quot;B&quot; ## [4,] &quot;B&quot; &quot;BB&quot; &quot;BBB&quot; ## [5,] &quot;C&quot; &quot;C&quot; &quot;0&quot; ## [6,] &quot;7&quot; &quot;DD&quot; &quot;DD&quot; Then you can run each line of score_many against the example and examine the results as you go. Exercise 13.3 (Test Your Understanding) Study the model score_many function until you are satisfied that you understand how it works and could write a similar function yourself. Exercise 13.4 (Advanced Challenge) Instead of examining the model answer, write your own vectorized version of score. Assume that the data is stored in an n × 3 matrix where each row of the matrix contains one combination of slots to be scored. You can use the version of score that treats diamonds as wild or the version of score that doesn’t. However, the model answer will use the version treating diamonds as wild. Solution. score_many is a vectorized version of score. You can use it to run the simulation at the start of this section in a little over 20 seconds. This is 17 times faster than using a for loop: # symbols should be a matrix with a column for each slot machine window score_many &lt;- function(symbols) { # Step 1: Assign base prize based on cherries and diamonds --------- ## Count the number of cherries and diamonds in each combination cherries &lt;- rowSums(symbols == &quot;C&quot;) diamonds &lt;- rowSums(symbols == &quot;DD&quot;) ## Wild diamonds count as cherries prize &lt;- c(0, 2, 5)[cherries + diamonds + 1] ## ...but not if there are zero real cherries ### (cherries is coerced to FALSE where cherries == 0) prize[!cherries] &lt;- 0 # Step 2: Change prize for combinations that contain three of a kind same &lt;- symbols[, 1] == symbols[, 2] &amp; symbols[, 2] == symbols[, 3] payoffs &lt;- c(&quot;DD&quot; = 100, &quot;7&quot; = 80, &quot;BBB&quot; = 40, &quot;BB&quot; = 25, &quot;B&quot; = 10, &quot;C&quot; = 10, &quot;0&quot; = 0) prize[same] &lt;- payoffs[symbols[same, 1]] # Step 3: Change prize for combinations that contain all bars ------ bars &lt;- symbols == &quot;B&quot; | symbols == &quot;BB&quot; | symbols == &quot;BBB&quot; all_bars &lt;- bars[, 1] &amp; bars[, 2] &amp; bars[, 3] &amp; !same prize[all_bars] &lt;- 5 # Step 4: Handle wilds --------------------------------------------- ## combos with two diamonds two_wilds &lt;- diamonds == 2 ### Identify the nonwild symbol one &lt;- two_wilds &amp; symbols[, 1] != symbols[, 2] &amp; symbols[, 2] == symbols[, 3] two &lt;- two_wilds &amp; symbols[, 1] != symbols[, 2] &amp; symbols[, 1] == symbols[, 3] three &lt;- two_wilds &amp; symbols[, 1] == symbols[, 2] &amp; symbols[, 2] != symbols[, 3] ### Treat as three of a kind prize[one] &lt;- payoffs[symbols[one, 1]] prize[two] &lt;- payoffs[symbols[two, 2]] prize[three] &lt;- payoffs[symbols[three, 3]] ## combos with one wild one_wild &lt;- diamonds == 1 ### Treat as all bars (if appropriate) wild_bars &lt;- one_wild &amp; (rowSums(bars) == 2) prize[wild_bars] &lt;- 5 ### Treat as three of a kind (if appropriate) one &lt;- one_wild &amp; symbols[, 1] == symbols[, 2] two &lt;- one_wild &amp; symbols[, 2] == symbols[, 3] three &lt;- one_wild &amp; symbols[, 3] == symbols[, 1] prize[one] &lt;- payoffs[symbols[one, 1]] prize[two] &lt;- payoffs[symbols[two, 2]] prize[three] &lt;- payoffs[symbols[three, 3]] # Step 5: Double prize for every diamond in combo ------------------ unname(prize * 2^diamonds) } system.time(play_many(10000000)) ## user system elapsed ## 20.942 1.433 22.367 13.4.1 Loops Versus Vectorized Code In many languages, for loops run very fast. As a result, programmers learn to use for loops whenever possible when they code. Often these programmers continue to rely on for loops when they begin to program in R, usually without taking the simple steps needed to optimize R’s for loops. These programmers may become disillusioned with R when their code does not work as fast as they would like. If you think that this may be happening to you, examine how often you are using for loops and what you are using them to do. If you find yourself using for loops for every task, there is a good chance that you are “speaking R with a C accent.” The cure is to learn to write and use vectorized code. This doesn’t mean that for loops have no place in R. for loops are a very useful feature; they can do many things that vectorized code cannot do. You also should not become a slave to vectorized code. Sometimes it would take more time to rewrite code in vectorized format than to let a for loop run. For example, would it be faster to let the slot simulation run for 5.7 minutes or to rewrite score? 13.5 Summary Fast code is an important component of data science because you can do more with fast code than you can do with slow code. You can work with larger data sets before computational constraints intervene, and you can do more computation before time constraints intervene. The fastest code in R will rely on the things that R does best: logical tests, subsetting, and element-wise execution. I’ve called this type of code vectorized code because code written with these operations will take a vector of values as input and operate on each element of the vector at the same time. The majority of the code written in R is already vectorized. If you use these operations, but your code does not appear vectorized, analyze the sequential steps and parallel cases in your program. Ensure that you’ve used vectorized functions to handle the steps and logical subsetting to handle the cases. Be aware, however, that some tasks cannot be vectorized. 13.6 Project 3 Wrap-up You have now written your first program in R, and it is a program that you should be proud of. play is not a simple hello world exercise, but a real program that does a real task in a complicated way. Writing new programs in R will always be challenging because programming depends so much on your own creativity, problem-solving ability, and experience writing similar types of programs. However, you can use the suggestions in this chapter to make even the most complicated program manageable: divide tasks into simple steps and cases, work with concrete examples, and describe possible solutions in English. This project completes the education you began in [The Very Basics]. You can now use R to handle data, which has augmented your ability to analyze data. You can: Load and store data in your computer—not on paper or in your mind Accurately recall and change individual values without relying on your memory Instruct your computer to do tedious, or complex, tasks on your behalf These skills solve an important logistical problem faced by every data scientist: how can you store and manipulate data without making errors? However, this is not the only problem that you will face as a data scientist. The next problem will appear when you try to understand the information contained in your data. It is nearly impossible to spot insights or to discover patterns in raw data. A third problem will appear when you try to use your data set to reason about reality, which includes things not contained in your data set. What exactly does your data imply about things outside of the data set? How certain can you be? I refer to these problems as the logistical, tactical, and strategic problems of data science, as shown in Figure 13.4. You’ll face them whenever you try to learn from data: A logistical problem: - How can you store and manipulate data without making errors? A tactical problem - How can you discover the information contained in your data? A strategic problem - How can you use the data to draw conclusions about the world at large? Figure 13.4: The three core skill sets of data science: computer programming, data comprehension, and scientific reasoning. A well-rounded data scientist will need to be able to solve each of these problems in many different situations. By learning to program in R, you have mastered the logistical problem, which is a prerequisite for solving the tactical and strategic problems. If you would like to learn how to reason with data, or how to transform, visualize, and explore your data sets with R tools, I recommend the book R for Data Science, the companion volume to this book. R for Data Science teaches a simple workflow for transforming, visualizing, and modeling data in R, as well as how to report results with the R Markdown package. "],["starting.html", "A Instalación de R y RStudio A.1 Cómo descargar e instalar R A.2 Usando R A.3 RStudio A.4 Abriendo R", " A Instalación de R y RStudio Para comenzar con R, debe adquirir su propia copia. Este apéndice le mostrará cómo descargar R así como RStudio, una aplicación de software que facilita el uso de R. Pasará de descargar R a abrir su primera sesión de R. Tanto R como RStudio son gratuitos y fáciles de descargar. A.1 Cómo descargar e instalar R R es mantenido por un equipo internacional de desarrolladores que hacen que el lenguaje esté disponible a través de la página web de The Comprehensive R Archive Network. La parte superior de la página web proporciona tres enlaces para descargar R. Siga el enlace que describe su sistema operativo: Windows, Mac o Linux. A.1.1 Windows Para instalar R en Windows, haga clic en el enlace “Download R for Windows”. Luego haga clic en el enlace “base”. A continuación, haga clic en el primer enlace en la parte superior de la nueva página. Este enlace debería decir algo como “Descargar R 3.0.3 para Windows”, excepto que la 3.0.3 será reemplazada por la versión más reciente de R. El enlace descarga un programa de instalación, que instala la versión más actualizada de R para Windows. Ejecute este programa y siga los pasos del asistente de instalación que aparece. El asistente instalará R en sus carpetas de archivos de programa y colocará un acceso directo en su menú Inicio. Tenga en cuenta que deberá tener todos los privilegios de administración apropiados para instalar software nuevo en su máquina. A.1.2 Mac Para instalar R en una Mac, haga clic en el enlace “Download R for Mac”. A continuación, haga clic en el enlace del paquete R-3.0.3 (o en el enlace del paquete para la versión más reciente de R). Se descargará un instalador para guiarlo a través del proceso de instalación, que es muy fácil. El instalador le permite personalizar su instalación, pero los valores predeterminados serán adecuados para la mayoría de los usuarios. Nunca he encontrado una razón para cambiarlos. Si su computadora requiere una contraseña antes de instalar nuevos programas, la necesitará aquí. Binarios versus Fuente R se puede instalar a partir de archivos binarios precompilados o compilarse desde el origen en cualquier sistema operativo. Para máquinas Windows y Mac, instalar R desde binarios es extremadamente fácil. El binario viene precargado en su propio instalador. Aunque puede compilar R desde el origen en estas plataformas, el proceso es mucho más complicado y no brindará muchos beneficios a la mayoría de los usuarios. Para los sistemas Linux, ocurre lo contrario. Se pueden encontrar binarios precompilados para algunos sistemas, pero es mucho más común compilar R a partir de archivos fuente cuando se instala en Linux. Las páginas de descarga en el sitio web de CRAN brindan información sobre la creación de R desde el origen para las plataformas Windows, Mac y Linux. A.1.3 Linux R viene preinstalado en muchos sistemas Linux, pero querrá la versión más reciente de R si la suya no está actualizada. El sitio web de CRAN proporciona archivos para compilar R desde la fuente en los sistemas Debian, Redhat, SUSE y Ubuntu en el enlace “Descargar R para Linux”. Haga clic en el enlace y luego siga el rastro del directorio hasta la versión de Linux en la que desea instalar. El procedimiento de instalación exacto variará según el sistema Linux que utilice. CRAN guía el proceso agrupando cada conjunto de archivos fuente con documentación o archivos README que explican cómo instalar en su sistema. 32-bit Versus 64-bit R viene en versiones de 32 y 64 bits. ¿Cuál deberías usar? En la mayoría de los casos, no importará. Ambas versiones usan números enteros de 32 bits, lo que significa que calculan números con la misma precisión numérica. La diferencia ocurre en la forma en que cada versión administra la memoria. R de 64 bits usa punteros de memoria de 64 bits y R de 32 bits usa punteros de memoria de 32 bits. Esto significa que R de 64 bits tiene un espacio de memoria más grande para usar (y buscar). Como regla general, las compilaciones de R de 32 bits son más rápidas que las compilaciones de 64 bits, aunque no siempre. Por otro lado, las compilaciones de 64 bits pueden manejar archivos y conjuntos de datos más grandes con menos problemas de administración de memoria. En cualquiera de las versiones, el tamaño de vector máximo permitido alcanza un máximo de alrededor de 2 mil millones de elementos. Si su sistema operativo no es compatible con programas de 64 bits, o su memoria RAM es inferior a 4 GB, la versión R de 32 bits es para usted. Los instaladores de Windows y Mac instalarán automáticamente ambas versiones si su sistema es compatible con R de 64 bits. A.2 Usando R R no es un programa que pueda abrir y comenzar a usar, como Microsoft Word o Internet Explorer. En cambio, R es un lenguaje de programación, como C, C++ o UNIX. Usas R escribiendo comandos en el lenguaje R y pidiéndole a tu computadora que los interprete. En los viejos tiempos, la gente ejecutaba código R en una ventana de terminal UNIX, como si fueran piratas informáticos en una película de los años ochenta. Ahora casi todo el mundo usa R con una aplicación llamada RStudio, y te recomiendo que tú también lo hagas. R y UNIX Todavía puede ejecutar R en una ventana de UNIX o BASH escribiendo el comando: R que abre un intérprete de R. Luego puede hacer su trabajo y cerrar el intérprete ejecutando q() cuando haya terminado. A.3 RStudio RStudio es una applicación como Microsoft Word—excepto que en lugar de ayudarlo a escribir texto convencional, RStudio lo ayuda a escribir en R. Uso RStudio en todo el libro porque hace que usar R sea mucho más fácil. Además, la interfaz de RStudio tiene el mismo aspecto para Windows, Mac OS y Linux. Eso me ayudará a relacionar el libro con su experiencia personal. Puede descargar RStudio de fomra gratuita. Simplemente haga clic en el botón “Download RStudio” y siga las instrucciones. Una vez que haya instalado RStudio, puede abrirlo como cualquier otro programa en su computadora—generalmente haciendo clic en un ícono en su escritorio. Las interfaces gráficas de usuario de R Los usuarios de Windows y Mac generalmente no programan desde una ventana de terminal, por lo que las descargas de Windows y Mac para R vienen con un programa simple que abre una ventana similar a una terminal para que pueda ejecutar el código R. Esto es lo que se abre cuando hace clic en el icono de R en su computadora con Windows o Mac. Estos programas hacen un poco más que la ventana de terminal básica, pero no mucho. Es posible que escuche que las personas se refieren a ellos como las interfarces gráficas de usuarios de R para Windows o Mac. Cuando abre RStudio, aparece una ventana con tres paneles, como en la Figura @ref(fig:layout). El panel más grande es una ventana de consola. Aquí es donde ejecutará su código R y verá los resultados. La ventana de la consola es exactamente lo que vería si ejecutara R desde una consola UNIX o las IGU de Windows o Mac. Todo lo demás que ve es exclusivo de RStudio. Ocultos en los otros paneles hay un editor de texto, una ventana de gráficos, un depurador, un administrador de archivos y mucho más. Aprenderá acerca de estos paneles a medida que se vuelvan útiles a lo largo de este libro. Figure A.1: El Entorno de Desarrollo Integrado de RStudio para R. ¿Todavía necesito descargar R? Incluso si usa RStudio, aún necesitará descargar R a su computadora. RStudio lo ayuda a usar la versión de R que vive en su computadora, pero no viene con una versión de R propia. A.4 Abriendo R Ahora que tiene R y RStudio en su computadora, puede comenzar a usar R abriendo el programa RStudio. Abra RStudio como lo haría con cualquier programa, haciendo clic en su icono o escribiendo “RStudio” en el indicador de ejecución de Windows. "],["packages2.html", "B Paquetes de R B.1 Instalando Paquetes B.2 Cargando Paquetes", " B Paquetes de R Muchas de las funciones más útiles de R no vienen precargadas cuando inicia R, sino que residen en paquetes que se pueden instalar encima de R. Los paquetes de R son similares a las bibliotecas en C, C++ y Javascript, los paquetes en Python y las gemas en Ruby. Un paquete de R agrupa funciones útiles, archivos de ayuda y conjuntos de datos. Puede usar estas funciones dentro de su propio código de R una vez que cargue el paquete en el que se encuentran. Por lo general, el contenido de un paquete de R está relacionado con un solo tipo de tarea, que el paquete ayuda a resolver. Los paquetes R le permitirán aprovechar las características más útiles de R: su gran comunidad de creadores de paquetes (muchos de los cuales son científicos de datos activos) y sus rutinas preescritas para manejar muchas tareas comunes (y exóticas) de ciencia de datos. R Básico Es posible que escuche a los usuarios de R (o a mí) referirse a “R básico” (o base R, en inglés). ¿Qué es R básico? Es solo la colección de funciones de R que se carga cada vez que inicia R. Estas funciones proporcionan los conceptos básicos del lenguaje, y no tiene que cargar un paquete antes de poder usarlas.. B.1 Instalando Paquetes Para usar un paquete de R, primero debe instalarlo en su computadora y luego cargarlo en su sesión de R actual. La forma más fácil de instalar un paquete de R es con la función de R install.packages. Abra R y escriba lo siguiente en la línea de comando: install.packages(&quot;&lt;nombre del paquete&gt;&quot;) Esto buscará el paquete especificado en la colección de paquetes alojados en el sitio CRAN. Cuando R encuentre el paquete, lo descargará en una carpeta de bibliotecas en su computadora. R puede acceder al paquete aquí en futuras sesiones de R sin reinstalarlo. Cualquiera puede escribir un paquete R y distribuirlo como quiera; sin embargo, casi todos los paquetes de R se publican a través del sitio web de CRAN. CRAN prueba cada paquete R antes de publicarlo. Esto no elimina todos los errores dentro de un paquete, pero significa que puede confiar en que un paquete en CRAN se ejecutará en la versión actual de R en su sistema operativo. Puede instalar varios paquetes a la vez vinculando sus nombres con la función de concatenación de R, c. Por ejemplo, para instalar los paquetes ggplot2, reshape2 y dplyr, ejecute: install.packages(c(&quot;ggplot2&quot;, &quot;reshape2&quot;, &quot;dplyr&quot;)) Si es la primera vez que instala un paquete, R le pedirá que elija un espejo en línea para instalarlo. Los espejos se enumeran por ubicación. Sus descargas deberían ser más rápidas si selecciona un espejo que esté cerca de usted. Si desea descargar un nuevo paquete, pruebe primero el espejo de Austria. Este es el repositorio principal de CRAN y, a veces, los nuevos paquetes pueden tardar un par de días en llegar a todos los demás espejos. B.2 Cargando Paquetes La instalación de un paquete no pone inmediatamente sus funciones al alcance de su mano. Simplemente los coloca en su computadora. Para usar un paquete de R, luego debe cargarlo en su sesión de R con el comando: library(&lt;nombre del paquete&gt;) Observe que las comillas han desaparecido. Puede usarlos si lo desea, pero las comillas son opcionales para el comando library. (Esto no es cierto para el comando install.packages). library pondrá a su disposición todas las funciones, conjuntos de datos y archivos de ayuda del paquete hasta que cierre su sesión de R actual. La próxima vez que inicie una sesión de R, deberá volver a cargar el paquete con library si desea utilizarlo, pero no tendrá que volver a instalarlo. Solo tiene que instalar cada paquete una vez. Después de eso, una copia del paquete vivirá en su biblioteca de R. Para ver qué paquetes tiene actualmente en su biblioteca de R, ejecute: library() library() también muestra la ruta a su biblioteca de R actual, que es la carpeta que contiene sus paquetes de R. Puede notar muchos paquetes que no recuerda haber instalado. Esto se debe a que R descarga automáticamente un conjunto de paquetes útiles cuando instala R por primera vez. Instalar paquetes desde (casi) cualquier sitio El paquete devtools de R facilita la instalación de paquetes desde ubicaciones distintas al sitio web de CRAN. devtools proporciona funciones como install_github, install_gitorious, install_bitbucket e install_url. Estos funcionan de manera similar a install.packages, pero buscan nuevas ubicaciones para paquetes de R. install_github es especialmente útil porque muchos desarrolladores de R proporcionan versiones de desarrollo de sus paquetes en GitHub. La versión de desarrollo de un paquete contendrá un adelanto de nuevas funciones y parches, pero puede que no sea tan estable o libre de errores como la versión CRAN. ¿Por qué R hace que te molestes en instalar y cargar paquetes? Puede imaginar una versión de R en la que todos los paquetes vengan precargados, pero este sería un programa muy grande y lento. A fecha del 6 de mayo de 2014, el sitio web de CRAN albergaba 5511 paquetes. Es más simple instalar y cargar solo los paquetes que desea usar cuando desea usarlos. Esto mantiene su copia de R rápida porque tiene menos funciones y páginas de ayuda para buscar en cualquier momento. Esto también tiene otros beneficios, por ejemplo, es posible actualizar su copia de un paquete de R sin actualizar toda su copia de R. ¿Cuál es la mejor manera de aprender sobre los paquetes de R? Es difícil usar un paquete de R si no sabe que existe. Puede ir al sitio web de CRAN y hacer clic en el enlace Paquetes para ver una lista de paquetes disponibles, pero tendrá que leer miles de ellos. Además, muchos paquetes de R hacen lo mismo. ¿Cómo sabe qué paquete los hace mejor? Los paquetes de R lista de correo es un lugar para comenzar. Envía anuncios de nuevos paquetes y mantiene un archivo de anuncios antiguos.Los blogs que agregan publicaciones sobre R también pueden proporcionar pistas valiosas, recomiendo R-bloggers. Posit mantiene una lista de algunos de los paquetes R más útiles en la sección de Getting Started de https://support.posit.co/. Finalmente, CRAN agrupa algunos de los paquetes más útiles y más respetados por área temática. Este es un excelente lugar para conocer los paquetes diseñados para su área de trabajo. "],["updating.html", "C Updating R and Its Packages C.1 R Packages", " C Updating R and Its Packages The R Core Development Team continuously hones the R language by catching bugs, improving performance, and updating R to work with new technologies. As a result, new versions of R are released several times a year. The easiest way to stay current with R is to periodically check the CRAN website. The website is updated for each new release and makes the release available for download. You’ll have to install the new release. The process is the same as when you first installed R. Don’t worry if you’re not interested in staying up-to-date on R Core’s doings. R changes only slightly between releases, and you’re not likely to notice the differences. However, updating to the current version of R is a good place to start if you ever encounter a bug that you can’t explain. RStudio also constantly improves its product. You can acquire the newest updates just by downloading them from RStudio. C.1 R Packages Package authors occasionally release new versions of their packages to add functions, fix bugs, or improve performance. The update.packages command checks whether you have the most current version of a package and installs the most current version if you do not. The syntax for update.packages follows that of install.packages. If you already have ggplot2, reshape2, and dplyr on your computer, it’d be a good idea to check for updates before you use them: update.packages(c(&quot;ggplot2&quot;, &quot;reshape2&quot;, &quot;dplyr&quot;)) You should start a new R session after updating packages. If you have a package loaded when you update it, you’ll have to close your R session and open a new one to begin using the updated version of the package. "],["dataio.html", "D Loading and Saving Data in R D.1 Data Sets in Base R D.2 Working Directory D.3 Plain-text Files D.4 R Files D.5 Excel Spreadsheets D.6 Loading Files from Other Programs", " D Loading and Saving Data in R This appendix will show you how to load and save data into R from plain-text files, R files, and Excel spreadsheets. It will also show you the R packages that you can use to load data from databases and other common programs, like SAS and MATLAB. D.1 Data Sets in Base R R comes with many data sets preloaded in the datasets package, which comes with base R. These data sets are not very interesting, but they give you a chance to test code or make a point without having to load a data set from outside R. You can see a list of R’s data sets as well as a short description of each by running: help(package = &quot;datasets&quot;) To use a data set, just type its name. Each data set is already presaved as an R object. For example: iris ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa However, R’s data sets are no substitute for your own data, which you can load into R from a wide variety of file formats. But before you load any data files into R, you’ll need to determine where your working directory is. D.2 Working Directory Each time you open R, it links itself to a directory on your computer, which R calls the working directory. This is where R will look for files when you attempt to load them, and it is where R will save files when you save them. The location of your working directory will vary on different computers. To determine which directory R is using as your working directory, run: getwd() ## &quot;/Users/garrettgrolemund&quot; You can place data files straight into the folder that is your working directory, or you can move your working directory to where your data files are. You can move your working directory to any folder on your computer with the function setwd. Just give setwd the file path to your new working directory. I prefer to set my working directory to a folder dedicated to whichever project I am currently working on. That way I can keep all of my data, scripts, graphs, and reports in the same place. For example: setwd(&quot;~/Users/garrettgrolemund/Documents/Book_Project&quot;) If the file path does not begin with your root directory, R will assume that it begins at your current working directory. You can also change your working directory by clicking on Session &gt; Set Working Directory &gt; Choose Directory in the RStudio menu bar. The Windows and Mac GUIs have similar options. If you start R from a UNIX command line (as on Linux machines), the working directory will be whichever directory you were in when you called R. You can see what files are in your working directory with list.files(). If you see the file that you would like to open in your working directory, then you are ready to proceed. How you open files in your working directory will depend on which type of file you would like to open. D.3 Plain-text Files Plain-text files are one of the most common ways to save data. They are very simple and can be read by many different computer programs—even the most basic text editors. For this reason, public data often comes as plain-text files. For example, the Census Bureau, the Social Security Administration, and the Bureau of Labor Statistics all make their data available as plain-text files. Here’s how the royal flush data set from [R Objects] would appear as a plain-text file (I’ve added a value column): &quot;card&quot;, &quot;suit&quot;, &quot;value&quot; &quot;ace&quot;, &quot;spades&quot;, 14 &quot;king&quot;, &quot;spades&quot;, 13 &quot;queen&quot;, &quot;spades&quot;, 12 &quot;jack&quot;, &quot;spades&quot;, 11 &quot;ten&quot;, &quot;spades&quot;, 10 A plain-text file stores a table of data in a text document. Each row of the table is saved on its own line, and a simple convention is used to separate the cells within a row. Often cells are separated by a comma, but they can also be separated by a tab, a pipe delimiter (i.e., | ), or any other character. Each file only uses one method of separating cells, which minimizes confusion. Within each cell, data appears as you’d expect to see it, as words and numbers. All plain-text files can be saved with the extension .txt (for text), but sometimes a file will receive a special extension that advertises how it separates data-cell entries. Since entries in the data set mentioned earlier are separated with a comma, this file would be a comma-separated-values file and would usually be saved with the extension .csv. D.3.1 read.table To load a plain-text file, use read.table. The first argument of read.table should be the name of your file (if it is in your working directory), or the file path to your file (if it is not in your working directory). If the file path does not begin with your root directory, R will append it to the end of the file path that leads to your working directory.You can give read.table other arguments as well. The two most important are sep and header. If the royal flush data set was saved as a file named poker.csv in your working directory, you could load it with: poker &lt;- read.table(&quot;poker.csv&quot;, sep = &quot;,&quot;, header = TRUE) D.3.1.1 sep Use sep to tell read.table what character your file uses to separate data entries. To find this out, you might have to open your file in a text editor and look at it. If you don’t specify a sep argument, read.table will try to separate cells whenever it comes to white space, such as a tab or space. R won’t be able to tell you if read.table does this correctly or not, so rely on it at your own risk. D.3.1.2 header Use header to tell read.table whether the first line of the file contains variable names instead of values. If the first line of the file is a set of variable names, you should set header = TRUE. D.3.1.3 na.strings Oftentimes data sets will use special symbols to represent missing information. If you know that your data uses a certain symbol to represent missing entries, you can tell read.table (and the preceding functions) what the symbol is with the na.strings argument. read.table will convert all instances of the missing information symbol to NA, which is R’s missing information symbol (see Missing Information). For example, your poker data set contained missing values stored as a ., like this: ## &quot;card&quot;,&quot;suit&quot;,&quot;value&quot; ## &quot;ace&quot;,&quot; spades&quot;,&quot; 14&quot; ## &quot;king&quot;,&quot; spades&quot;,&quot; 13&quot; ## &quot;queen&quot;,&quot;.&quot;,&quot;.&quot; ## &quot;jack&quot;,&quot;.&quot;,&quot;.&quot; ## &quot;ten&quot;,&quot;.&quot;,&quot;.&quot; You could read the data set into R and convert the missing values into NAs as you go with the command: poker &lt;- read.table(&quot;poker.csv&quot;, sep = &quot;,&quot;, header = TRUE, na.string = &quot;.&quot;) R would save a version of poker that looks like this: ## card suit value ## ace spades 14 ## king spades 13 ## queen &lt;NA&gt; NA ## jack &lt;NA&gt; NA ## ten &lt;NA&gt; NA D.3.1.4 skip and nrow Sometimes a plain-text file will come with introductory text that is not part of the data set. Or, you may decide that you only wish to read in part of a data set. You can do these things with the skip and nrow arguments. Use skip to tell R to skip a specific number of lines before it starts reading in values from the file. Use nrow to tell R to stop reading in values after it has read in a certain number of lines. For example, imagine that the complete royal flush file looks like this: This data was collected by the National Poker Institute. We accidentally repeated the last row of data. &quot;card&quot;, &quot;suit&quot;, &quot;value&quot; &quot;ace&quot;, &quot;spades&quot;, 14 &quot;king&quot;, &quot;spades&quot;, 13 &quot;queen&quot;, &quot;spades&quot;, 12 &quot;jack&quot;, &quot;spades&quot;, 11 &quot;ten&quot;, &quot;spades&quot;, 10 &quot;ten&quot;, &quot;spades&quot;, 10 You can read just the six lines that you want (five rows plus a header) with: read.table(&quot;poker.csv&quot;, sep = &quot;,&quot;, header = TRUE, skip = 3, nrow = 5) ## card suit value ## 1 ace spades 14 ## 2 king spades 13 ## 3 queen spades 12 ## 4 jack spades 11 ## 5 ten spades 10 Notice that the header row doesn’t count towards the total rows allowed by nrow. D.3.1.5 stringsAsFactors R reads in numbers just as you’d expect, but when R comes across character strings (e.g., letters and words) it begins to act strangely. R wants to convert every character string into a factor. This is R’s default behavior, but I think it is a mistake. Sometimes factors are useful. At other times, they’re clearly the wrong data type for the job. Also factors cause weird behavior, especially when you want to display data. This behavior can be surprising if you didn’t realize that R converted your data to factors. In general, you’ll have a smoother R experience if you don’t let R make factors until you ask for them. Thankfully, it is easy to do this. Setting the argument stringsAsFactors to FALSE will ensure that R saves any character strings in your data set as character strings, not factors. To use stringsAsFactors, you’d write: read.table(&quot;poker.csv&quot;, sep = &quot;,&quot;, header = TRUE, stringsAsFactors = FALSE) If you will be loading more than one data file, you can change the default factoring behavior at the global level with: options(stringsAsFactors = FALSE) This will ensure that all strings will be read as strings, not as factors, until you end your R session, or rechange the global default by running: options(stringsAsFactors = TRUE) D.3.2 The read Family R also comes with some prepackaged short cuts for read.table, shown in Table D.1. Table D.1: R’s read functions. You can overwrite any of the default arguments as necessary. Function Defaults Use read.table sep = ” “, header = FALSE General-purpose read function read.csv sep = “,”, header = TRUE Comma-separated-variable (CSV) files read.delim sep = “, header = TRUE Tab-delimited files read.csv2 sep = “;”, header = TRUE, dec = “,” CSV files with European decimal format read.delim2 sep = “, header = TRUE, dec =”,” Tab-delimited files with European decimal format The first shortcut, read.csv, behaves just like read.table but automatically sets sep = \",\" and header = TRUE, which can save you some typing: poker &lt;- read.csv(&quot;poker.csv&quot;) read.delim automatically sets sep to the tab character, which is very handy for reading tab delimited files. These are files where each cell is separated by a tab. read.delim also sets header = TRUE by default. read.delim2 and read.csv2 exist for European R users. These functions tell R that the data uses a comma instead of a period to denote decimal places. (If you’re wondering how this works with CSV files, CSV2 files usually separate cells with a semicolon, not a comma.) Import Dataset You can also load plain text files with RStudio’s Import Dataset button, as described in Loading Data. Import Dataset provides a GUI version of read.table. D.3.3 read.fwf One type of plain-text file defies the pattern by using its layout to separate data cells. Each row is placed in its own line (as with other plain-text files), and then each column begins at a specific number of characters from the lefthand side of the document. To achieve this, an arbitrary number of character spaces is added to the end of each entry to correctly position the next entry. These documents are known as fixed-width files and usually end with the extension .fwf. Here’s one way the royal flush data set could look as a fixed-width file. In each row, the suit entry begins exactly 10 characters from the start of the line. It doesn’t matter how many characters appeared in the first cell of each row: card suit value ace spades 14 king spades 13 queen spades 12 jack spades 11 10 spades 10 Fixed-width files look nice to human eyes (but no better than a tab-delimited file); however, they can be difficult to work with. Perhaps because of this, R comes with a function for reading fixed-width files, but no function for saving them. Unfortunately, US government agencies seem to like fixed-width files, and you’ll likely encounter one or more during your career. You can read fixed-width files into R with the function read.fwf. The function takes the same arguments as read.table but requires an additional argument, widths, which should be a vector of numbers. Each _i_th entry of the widths vector should state the width (in characters) of the _i_th column of the data set. If the aforementioned fixed-width royal flush data was saved as poker.fwf in your working directory, you could read it with: poker &lt;- read.fwf(&quot;poker.fwf&quot;, widths = c(10, 7, 6), header = TRUE) D.3.4 HTML Links Many data files are made available on the Internet at their own web address. If you are connected to the Internet, you can open these files straight into R with read.table, read.csv, etc. You can pass a web address into the file name argument for any of R’s data-reading functions. As a result, you could read in the poker data set from a web address like http://…/poker.csv with: poker &lt;- read.csv(&quot;http://.../poker.csv&quot;) That’s obviously not a real address, but here’s something that would work—if you can manage to type it! deck &lt;- read.csv(&quot;https://gist.githubusercontent.com/garrettgman/9629323/raw/ee5dfc039fd581cb467cc69c226ea2524913c3d8/deck.csv&quot;) Just make sure that the web address links directly to the file and not to a web page that links to the file. Usually, when you visit a data file’s web address, the file will begin to download or the raw data will appear in your browser window. Note that websites that begin with _https://_ are secure websites, which means R may not be able to access the data provided at these links. D.3.5 Saving Plain-Text Files Once your data is in R, you can save it to any file format that R supports. If you’d like to save it as a plain-text file, you can use the +write+ family of functions. The three basic write functions appear in Table D.2. Use write.csv to save your data as a .csv file and write.table to save your data as a tab delimited document or a document with more exotic separators. Table D.2: R saves data sets to plain-text files with the write family of functions File format Function and syntax .csv write.csv(r_object, file = filepath, row.names = FALSE) .csv (with European decimal notation) write.csv2(r_object, file = filepath, row.names = FALSE) tab delimited write.table(r_object, file = filepath, sep = \"\\t\", row.names=FALSE) The first argument of each function is the R object that contains your data set. The file argument is the file name (including extension) that you wish to give the saved data. By default, each function will save your data into your working directory. However, you can supply a file path to the file argument. R will oblige by saving the file at the end of the file path. If the file path does not begin with your root directory, R will append it to the end of the file path that leads to your working directory. For example, you can save the (hypothetical) poker data frame to a subdirectory named data within your working directory with the command: write.csv(poker, &quot;data/poker.csv&quot;, row.names = FALSE) Keep in mind that write.csv and write.table cannot create new directories on your computer. Each folder in the file path must exist before you try to save a file with it. The row.names argument prevents R from saving the data frame’s row names as a column in the plain-text file. You might have noticed that R automatically names each row in a data frame with a number. For example, each row in our poker data frame appears with a number next to it: poker ## card suit value ## 1 ace spades 14 ## 2 king spades 13 ## 3 queen spades 12 ## 4 jack spades 11 ## 5 10 spades 10 These row numbers are helpful, but can quickly accumulate if you start saving them. R will add a new set of numbers by default each time you read the file back in. Avoid this by always setting row.names = FALSE when you use a function in the write family. D.3.6 Compressing Files To compress a plain-text file, surround the file name or file path with the function bzfile, gzfile, or xzfile. For example: write.csv(poker, file = bzfile(&quot;data/poker.csv.bz2&quot;), row.names = FALSE) Each of these functions will compress the output with a different type of compression format, shown in Table D.3. Table D.3: R comes with three helper functions for compressing files Function Compression type bzfile bzip2 gzfile gnu zip (gzip) xzfile xz compression It is a good idea to adjust your file’s extension to reflect the compression. R’s read functions will open plain-text files compressed in any of these formats. For example, you could read a compressed file named poker.csv.bz2 with: read.csv(&quot;poker.csv.bz2&quot;) or: read.csv(&quot;data/poker.csv.bz2&quot;) depending on where the file is saved. D.4 R Files R provides two file formats of its own for storing data, .RDS and .RData. RDS files can store a single R object, and RData files can store multiple R objects. You can open a RDS file with readRDS. For example, if the royal flush data was saved as poker.RDS, you could open it with: poker &lt;- readRDS(&quot;poker.RDS&quot;) Opening RData files is even easier. Simply run the function load with the file: load(&quot;file.RData&quot;) There’s no need to assign the output to an object. The R objects in your RData file will be loaded into your R session with their original names. RData files can contain multiple R objects, so loading one may read in multiple objects. load doesn’t tell you how many objects it is reading in, nor what their names are, so it pays to know a little about the RData file before you load it. If worse comes to worst, you can keep an eye on the environment pane in RStudio as you load an RData file. It displays all of the objects that you have created or loaded during your R session. Another useful trick is to put parentheses around your load command like so, (load(\"poker.RData\")). This will cause R to print out the names of each object it loads from the file. Both readRDS and load take a file path as their first argument, just like R’s other read and write functions. If your file is in your working directory, the file path will be the file name. D.4.1 Saving R Files You can save an R object like a data frame as either an RData file or an RDS file. RData files can store multiple R objects at once, but RDS files are the better choice because they foster reproducible code. To save data as an RData object, use the save function. To save data as a RDS object, use the saveRDS function. In each case, the first argument should be the name of the R object you wish to save. You should then include a file argument that has the file name or file path you want to save the data set to. For example, if you have three R objects, a, b, and c, you could save them all in the same RData file and then reload them in another R session: a &lt;- 1 b &lt;- 2 c &lt;- 3 save(a, b, c, file = &quot;stuff.RData&quot;) load(&quot;stuff.RData&quot;) However, if you forget the names of your objects or give your file to someone else to use, it will be difficult to determine what was in the file—even after you (or they) load it. The user interface for RDS files is much more clear. You can save only one object per file, and whoever loads it can decide what they want to call their new data. As a bonus, you don’t have to worry about load overwriting any R objects that happened to have the same name as the objects you are loading: saveRDS(a, file = &quot;stuff.RDS&quot;) a &lt;- readRDS(&quot;stuff.RDS&quot;) Saving your data as an R file offers some advantages over saving your data as a plain-text file. R automatically compresses the file and will also save any R-related metadata associated with your object. This can be handy if your data contains factors, dates and times, or class attributes. You won’t have to reparse this information into R the way you would if you converted everything to a text file. On the other hand, R files cannot be read by many other programs, which makes them inefficient for sharing. They may also create a problem for long-term storage if you don’t think you’ll have a copy of R when you reopen the files. D.5 Excel Spreadsheets Microsoft Excel is a popular spreadsheet program that has become almost industry standard in the business world. There is a good chance that you will need to work with an Excel spreadsheet in R at least once in your career. You can read spreadsheets into R and also save R data as a spreadsheet in a variety of ways. D.5.1 Export from Excel The best method for moving data from Excel to R is to export the spreadsheet from Excel as a .csv or .txt file. Not only will R be able to read the text file, so will any other data analysis software. Text files are the lingua franca of data storage. Exporting the data solves another difficulty as well. Excel uses proprietary formats and metadata that will not easily transfer into R. For example, a single Excel file can include multiple spreadsheets, each with their own columns and macros. When Excel exports the file as a .csv or .txt, it makes sure this format is transferred into a plain-text file in the most appropriate way. R may not be able to manage the conversion as efficiently. To export data from Excel, open the Excel spreadsheet and then go to Save As in the Microsoft Office Button menu. Then choose CSV in the Save as type box that appears and save the files. You can then read the file into R with the read.csv function. D.5.2 Copy and Paste You can also copy portions of an Excel spreadsheet and paste them into R. To do this, open the spreadsheet and select the cells you wish to read into R. Then select Edit &gt; Copy in the menu bar—or use a keyboard shortcut—to copy the cells to your clipboard. On most operating systems, you can read the data stored in your clipboard into R with: read.table(&quot;clipboard&quot;) On Macs you will need to use: read.table(pipe(&quot;pbpaste&quot;)) If the cells contain values with spaces in them, this will disrupt read.table. You can try another read function (or just formally export the data from Excel) before reading it into R. D.5.3 XLConnect Many packages have been written to help you read Excel files directly into R. Unfortunately, many of these packages do not work on all operating systems. Others have been made out of date by the .xlsx file format. One package that does work on all file systems (and gets good reviews) is the XLConnect package. To use it, you’ll need to install and load the package: install.packages(&quot;XLConnect&quot;) library(XLConnect) XLConnect relies on Java to be platform independent. So when you first open XLConnect, RStudio may ask to download a Java Runtime Environment if you do not already have one. D.5.4 Reading Spreadsheets You can use XLConnect to read in an Excel spreadsheet with either a one- or a two-step process. I’ll start with the two-step process. First, load an Excel workbook with loadWorkbook. loadWorkbook can load both .xls and .xlsx files. It takes one argument: the file path to your Excel workbook (this will be the name of the workbook if it is saved in your working directory): wb &lt;- loadWorkbook(&quot;file.xlsx&quot;) Next, read a spreadsheet from the workbook with readWorksheet, which takes several arguments. The first argument should be a workbook object created with loadWorkbook. The next argument, sheet, should be the name of the spreadsheet in the workbook that you would like to read into R. This will be the name that appears on the bottom tab of the spreadsheet. You can also give sheet a number, which specifies the sheet that you want to read in (one for the first sheet, two for the second, and so on). readWorksheet then takes four arguments that specify a bounding box of cells to read in: startRow, startCol, endRow, and endCol. Use startRow and startCol to describe the cell in the top-left corner of the bounding box of cells that you wish to read in. Use endRow and endCol to specify the cell in the bottom-right corner of the bounding box. Each of these arguments takes a number. If you do not supply bounding arguments, readWorksheet will read in the rectangular region of cells in the spreadsheet that appears to contain data. readWorksheet will assume that this region contains a header row, but you can tell it otherwise with header = FALSE. So to read in the first worksheet from wb, you could use: sheet1 &lt;- readWorksheet(wb, sheet = 1, startRow = 0, startCol = 0, endRow = 100, endCol = 3) R will save the output as a data frame. All of the arguments in readWorkbook except the first are vectorized, so you can use it to read in multiple sheets from the same workbook at once (or multiple cell regions from a single worksheet). In this case, readWorksheet will return a list of data frames. You can combine these two steps with readWorksheetFromFile. It takes the file argument from loadWorkbook and combines it with the arguments from readWorksheet. You can use it to read one or more sheets straight from an Excel file: sheet1 &lt;- readWorksheetFromFile(&quot;file.xlsx&quot;, sheet = 1, startRow = 0, startCol = 0, endRow = 100, endCol = 3) D.5.5 Writing Spreadsheets Writing to an Excel spreadsheet is a four-step process. First, you need to set up a workbook object with loadWorkbook. This works just as before, except if you are not using an existing Excel file, you should add the argument create = TRUE. XLConnect will create a blank workbook. When you save it, XLConnect will write it to the file location that you specified here with loadWorkbook: wb &lt;- loadWorkbook(&quot;file.xlsx&quot;, create = TRUE) Next, you need to create a worksheet inside your workbook object with createSheet. Tell createSheet which workbook to place the sheet in and which to use for the sheet. createSheet(wb, &quot;Sheet 1&quot;) Then you can save your data frame or matrix to the sheet with writeWorksheet. The first argument of writeWorksheet, object, is the workbook to write the data to. The second argument, data, is the data to write. The third argument, sheet, is the name of the sheet to write it to. The next two arguments, startRow and startCol, tell R where in the spreadsheet to place the upper-left cell of the new data. These arguments each default to 1. Finally, you can use header to tell R whether your column names should be written with the data: writeWorksheet(wb, data = poker, sheet = &quot;Sheet 1&quot;) Once you have finished adding sheets and data to your workbook, you can save it by running saveWorkbook on the workbook object. R will save the workbook to the file name or path you provided in loadWorkbook. If this leads to an existing Excel file, R will overwrite it. If it leads to a new file, R will create it. You can also collapse these steps into a single call with writeWorksheetToFile, like this: writeWorksheetToFile(&quot;file.xlsx&quot;, data = poker, sheet = &quot;Sheet 1&quot;, startRow = 1, startCol = 1) The XLConnect package also lets you do more advanced things with Excel spreadsheets, such as writing to a named region in a spreadsheet, working with formulas, and assigning styles to cells. You can read about these features in XLConnect’s vignette, which is accessible by loading XLConnect and then running: vignette(&quot;XLConnect&quot;) D.6 Loading Files from Other Programs You should follow the same advice I gave you for Excel files whenever you wish to work with file formats native to other programs: open the file in the original program and export the data as a plain-text file, usually a CSV. This will ensure the most faithful transcription of the data in the file, and it will usually give you the most options for customizing how the data is transcribed. Sometimes, however, you may acquire a file but not the program it came from. As a result, you won’t be able to open the file in its native program and export it as a text file. In this case, you can use one of the functions in Table D.4 to open the file. These functions mostly come in R’s foreign package. Each attempts to read in a different file format with as few hiccups as possible. Table D.4: A number of functions will attempt to read the file types of other data-analysis programs File format Function Library ERSI ArcGIS read.shapefile shapefiles Matlab readMat R.matlab minitab read.mtp foreign SAS (permanent data set) read.ssd foreign SAS (XPORT format) read.xport foreign SPSS read.spss foreign Stata read.dta foreign Systat read.systat foreign D.6.1 Connecting to Databases You can also use R to connect to a database and read in data. Use the RODBC package to connect to databases through an ODBC connection. Use the DBI package to connect to databases through individual drivers. The DBI package provides a common syntax for working with different databases. You will have to download a database-specific package to use in conjunction with DBI. These packages provide the API for the native drivers of different database programs. For MySQL use RMySQL, for SQLite use RSQLite, for Oracle use ROracle, for PostgreSQL use RPostgreSQL, and for databases that use drivers based on the Java Database Connectivity (JDBC) API use RJDBC. Once you have loaded the appropriate driver package, you can use the commands provided by DBI to access your database. "],["debug.html", "E Debugging R Code E.1 traceback E.2 browser E.3 Break Points E.4 debug E.5 trace E.6 recover", " E Debugging R Code This appendix refers to environments, the topic of Environments, and uses examples from Programs and S3. You should read through these chapters first to get the most out of this appendix. R comes with a simple set of debugging tools that RStudio amplifies. You can use these tools to better understand code that produces an error or returns an unexpected result. Usually this will be your own code, but you can also examine the functions in R or one of its packages. Debugging code can take as much creativity and insight as writing code. There is no guarantee that you will find a bug or be able to fix it when you do. However, you can help yourself by using R’s debugging tools. These include the traceback, browser, debug, debugonce, trace, and recover functions. Using these tools is usually a two-step process. First, you locate where an error occurred. Then you try to determine why it occurred. You can do the first step with R’s traceback function. E.1 traceback The traceback tool pinpoints the location of an error. Many R functions call other R functions, which call other functions, and so on. When an error occurs, it may not be clear which of these functions went wrong. Let’s consider an example. The following functions call one another, and the last function creates an error (you’ll see why in a second): first &lt;- function() second() second &lt;- function() third() third &lt;- function() fourth() fourth &lt;- function() fifth() fifth &lt;- function() bug() When you run first, it will call second, which will call third, which will call fourth, which will call fifth, which will call bug, a function that does not exist. Here’s what that will look like at the command line: first() ## Error in fifth() : could not find function &quot;bug&quot; The error report tells us that the error occurred when R tried to run fifth. It also tells us the nature of the error (there is no function called bug). Here, it is obvious why R calls fifth, but it might not be so obvious why R calls a function when an error occurs in the wild. You can see the path of functions that R called before it hit an error by typing traceback() at the command line. traceback will return a call stack, a list of the functions that R called in the order that it called them. The bottom function will be the command that you entered in the command line. The top function will be the function that caused the error: traceback() ## 5: fifth() at #1 ## 4: fourth() at #1 ## 3: third() at #1 ## 2: second() at #1 ## 1: first() traceback will always refer to the last error you encountered. If you would like to look at a less recent error, you will need to recreate it before running traceback. How can this help you? First, traceback returns a list of suspects. One of these functions caused the error, and each function is more suspicious than the ones below it. Chances are that our bug came from fifth (it did), but it is also possible that an earlier function did something odd—like call fifth when it shouldn’t have. Second, traceback can show you if R stepped off the path that you expected it to take. If this happened, look at the last function before things went wrong. Third, traceback can reveal the frightening extent of infinite recursion errors. For example, if you change fifth so that it calls second, the functions will make a loop: second will call third, which will call fourth, which will call fifth, which will call second and start the loop over again. It is easier to do this sort of thing in practice than you might think: fifth &lt;- function() second() When you call first(), R will start to run the functions. After awhile, it will notice that it is repeating itself and will return an error. traceback will show just what R was doing: first() ## Error: evaluation nested too deeply: infinite recursion/options(expressions=)? traceback() ## 5000: fourth() at #1 ## 4999: third() at #1 ## 4998: second() at #1 ## 4997: fifth() at #1 ## 4996: fourth() at #1 ## 4995: third() at #1 ## 4994: second() at #1 ## 4993: fifth() at #1 ## ... Notice that there are 5,000 lines of output in this traceback. If you are using RStudio, you will not get to see the traceback of an infinite recursion error (I used the Mac GUI to get this output). RStudio represses the traceback for infinite recursion errors to prevent the large call stacks from pushing your console history out of R’s memory buffer. With RStudio, you will have to recognize the infinite recursion error by its error message. However, you can still see the imposing traceback by running things in a UNIX shell or the Windows or Mac GUIs. RStudio makes it very easy to use traceback. You do not even need to type in the function name. Whenever an error occurs, RStudio will display it in a gray box with two options. The first is Show Traceback, shown in Figure E.1. Figure E.1: RStudio’s Show Traceback option. If you click Show Traceback, RStudio will expand the gray box and display the traceback call stack, as in Figure E.2. The Show Traceback option will persist beside an error message in your console, even as you write new commands. This means that you can go back and look at the call stacks for all errors—not just the most recent error. Imagine that you’ve used traceback to pinpoint a function that you think might cause a bug. Now what should you do? You should try to figure out what the function did to cause an error while it ran (if it did anything). You can examine how the function runs with browser. Figure E.2: RStudio’s Traceback display. E.2 browser You can ask R to pause in the middle of running a function and give control back to you with browser. This will let you enter new commands at the command line. The active environment for these commands will not be the global environment (as usual); it will be the runtime environment of the function that you have paused. As a result, you can look at the objects that the function is using, look up their values with the same scoping rules that the function would use, and run code under the same conditions that the function would run it in. This arrangement provides the best chance for spotting the source of bugs in a function. To use browser, add the call browser() to the body of a function and then resave the function. For example, if I wanted to pause in the middle of the score function from Programs, I could add browser() to the body of score and then rerun the following code, which defines score: score &lt;- function (symbols) { # identify case same &lt;- symbols[1] == symbols[2] &amp;&amp; symbols[2] == symbols[3] bars &lt;- symbols %in% c(&quot;B&quot;, &quot;BB&quot;, &quot;BBB&quot;) # get prize if (same) { payouts &lt;- c(&quot;DD&quot; = 100, &quot;7&quot; = 80, &quot;BBB&quot; = 40, &quot;BB&quot; = 25, &quot;B&quot; = 10, &quot;C&quot; = 10, &quot;0&quot; = 0) prize &lt;- unname(payouts[symbols[1]]) } else if (all(bars)) { prize &lt;- 5 } else { cherries &lt;- sum(symbols == &quot;C&quot;) prize &lt;- c(0, 2, 5)[cherries + 1] } browser() # adjust for diamonds diamonds &lt;- sum(symbols == &quot;DD&quot;) prize * 2 ^ diamonds } Now whenever R runs score, it will come to the call browser(). You can see this with the play function from Programs. If you don’t have play handy, you can access it by running this code: get_symbols &lt;- function() { wheel &lt;- c(&quot;DD&quot;, &quot;7&quot;, &quot;BBB&quot;, &quot;BB&quot;, &quot;B&quot;, &quot;C&quot;, &quot;0&quot;) sample(wheel, size = 3, replace = TRUE, prob = c(0.03, 0.03, 0.06, 0.1, 0.25, 0.01, 0.52)) } play &lt;- function() { symbols &lt;- get_symbols() structure(score(symbols), symbols = symbols, class = &quot;slots&quot;) } When you run play, play will call get_symbols and then score. As R works through score, it will come across the call to browser and run it. When R runs this call, several things will happen, as in Figure E.3. First, R will stop running score. Second, the command prompt will change to browser[1]&gt; and R will give me back control; I can now type new commands in at the new command prompt. Third, three buttons will appear above the console pane: Next, Continue, and Stop. Fourth, RStudio will display the source code for score in the scripts pane, and it will highlight the line that contains browser(). Fifth, the environments tab will change. Instead of revealing the objects that are saved in the global environment, it will reveal the objects that are saved in the runtime environment of score (see Environments for an explanation of R’s environment system). Sixth, RStudio will open a new Traceback pane, which shows the call stack RStudio took to get to browser. The most recent function, score, will be highlighted. I’m now in a new R mode, called browser mode. Browser mode is designed to help you uncover bugs, and the new display in RStudio is designed to help you navigate this mode. Any command that you run in browser mode will be evaluated in the context of the runtime environment of the function that called browser. This will be the function that is highlighted in the new Traceback pane. Here, that function is score. So while we are in browser mode, the active environment will be score’s runtime environment. This lets you do two things. Figure E.3: RStudio updates its display whenever you enter browser mode to help you navigate the mode. First, you can inspect the objects that score uses. The updated Environments pane shows you which objects score has saved in its local environment. You can inspect any of them by typing their name at the browser prompt. This gives you a way to see the values of runtime variables that you normally would not be able to access. If a value looks clearly wrong, you may be close to finding a bug: Browse[1]&gt; symbols ## [1] &quot;B&quot; &quot;B&quot; &quot;0&quot; Browse[1]&gt; same ## [1] FALSE Second, you can run code and see the same results that score would see. For example, you could run the remaining lines of the score function and see if they do anything unusual. You could run these lines by typing them into the command prompt, or you could use the three navigation buttons that now appear above the prompt, as in Figure E.4. The first button, Next, will run the next line of code in score. The highlighted line in the scripts pane will advance by one line to show you your new location in the score function. If the next line begins a code chunk, like a for loop or an if tree, R will run the whole chunk and will highlight the whole chunk in the script window. The second button, Continue, will run all of the remaining lines of score and then exit the browser mode. The third button, Stop, will exit browser mode without running any more lines of score. Figure E.4: You can navigate browser mode with the three buttons at the top of the console pane. You can do the same things by typing the commands n, c, and Q into the browser prompt. This creates an annoyance: what if you want to look up an object named n, c, or Q? Typing in the object name will not work, R will either advance, continue, or quit the browser mode. Instead you will have to look these objects up with the commands get(\"n\"), get(\"c\"), and get(\"Q\"). cont is a synonym for c in browser mode and where prints the call stack, so you’ll have to look up these objects with get as well. Browser mode can help you see things from the perspective of your functions, but it cannot show you where the bug lies. However, browser mode can help you test hypotheses and investigate function behavior. This is usually all you need to spot and fix a bug. The browser mode is the basic debugging tool of R. Each of the following functions just provides an alternate way to enter the browser mode. Once you fix the bug, you should resave your function a third time—this time without the browser() call. As long as the browser call is in there, R will pause each time you, or another function, calls score. E.3 Break Points RStudio’s break points provide a graphical way to add a browser statement to a function. To use them, open the script where you’ve defined a function. Then click to the left of the line number of the line of code in the function body where you’d like to add the browser statement. A hollow red dot will appear to show you where the break point will occur. Then run the script by clicking the Source button at the top of the Scripts pane. The hollow dot will turn into a solid red dot to show that the function has a break point (see Figure E.5). R will treat the break point like a browser statement, going into browser mode when it encounters it. You can remove a break point by clicking on the red dot. The dot will disappear, and the break point will be removed. Figure E.5: Break points provide the graphical equivalent of a browser statement. Break points and browser provide a great way to debug functions that you have defined. But what if you want to debug a function that already exists in R? You can do that with the debug function. E.4 debug You can “add” a browser call to the very start of a preexisting function with debug. To do this, run debug on the function. For example, you can run debug on sample with: debug(sample) Afterward, R will act as if there is a browser() statement in the first line of the function. Whenever R runs the function, it will immediately enter browser mode, allowing you to step through the function one line at a time. R will continue to behave this way until you “remove” the browser statement with undebug: undebug(sample) You can check whether a function is in “debugging” mode with isdebugged. This will return TRUE if you’ve ran debug on the function but have yet to run undebug: isdebugged(sample) ## FALSE If this is all too much of a hassle, you can do what I do and use debugonce instead of debug. R will enter browser mode the very next time it runs the function but will automatically undebug the function afterward. If you need to browse through the function again, you can just run debugonce on it a second time. You can recreate debugonce in RStudio whenever an error occurs. “Rerun with debug” will appear in the grey error box beneath Show Traceback (Figure E.1). If you click this option, RStudio will rerun the command as if you had first run debugonce on it. R will immediately go into browser mode, allowing you to step through the code. The browser behavior will only occur on this run of the code. You do not need to worry about calling undebug when you are done. E.5 trace You can add the browser statement further into the function, and not at the very start, with trace. trace takes the name of a function as a character string and then an R expression to insert into the function. You can also provide an at argument that tells trace at which line of the function to place the expression. So to insert a browser call at the fourth line of sample, you would run: trace(&quot;sample&quot;, browser, at = 4) You can use trace to insert other R functions (not just browser) into a function, but you may need to think of a clever reason for doing so. You can also run trace on a function without inserting any new code. R will prints trace:&lt;the function&gt; at the command line every time R runs the function. This is a great way to test a claim I made in S3, that R calls print every time it displays something at the command line: trace(print) first ## trace: print(function () second()) ## function() second() head(deck) ## trace: print ## face suit value ## 1 king spades 13 ## 2 queen spades 12 ## 3 jack spades 11 ## 4 ten spades 10 ## 5 nine spades 9 ## 6 eight spades 8 You can revert a function to normal after calling trace on it with untrace: untrace(sample) untrace(print) E.6 recover The recover function provides one final option for debugging. It combines the call stack of traceback with the browser mode of browser. You can use recover just like browser, by inserting it directly into a function’s body. Let’s demonstrate recover with the fifth function: fifth &lt;- function() recover() When R runs recover, it will pause and display the call stack, but that’s not all. R gives you the option of opening a browser mode in any of the functions that appear in the call stack. Annoyingly, the call stack will be displayed upside down compared to traceback. The most recent function will be on the bottom, and the original function will be on the top: first() ## ## Enter a frame number, or 0 to exit ## ## 1: first() ## 2: #1: second() ## 3: #1: third() ## 4: #1: fourth() ## 5: #1: fifth() To enter a browser mode, type in the number next to the function in whose runtime environment you would like to browse. If you do not wish to browse any of the functions, type 0: 3 ## Selection: 3 ## Called from: fourth() ## Browse[1]&gt; You can then proceed as normal. recover gives you a chance to inspect variables up and down your call stack and is a powerful tool for uncovering bugs. However, adding recover to the body of an R function can be cumbersome. Most R users use it as a global option for handling errors. If you run the following code, R will automatically call recover() whenever an error occurs: options(error = recover) This behavior will last until you close your R session, or reverse the behavior by calling: options(error = NULL) "]]
