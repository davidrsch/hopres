[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Programación práctica con R",
    "section": "",
    "text": "Bienvenido\nEste es el sitio web para la versión en español de “Hands-On Programming with R” (en lo adelante “Programación Práctica con R”) de Garrett Grolemund. Este libro le enseñará cómo programar en R, con ejemplos prácticos. Fue escrito para personas que no son programadores con el objetivo de proporcionar una introducción amigable al lenguaje R. Aprenderá a cargar datos, ensamblar y desensamblar objetos de datos, navegar por el sistema de entorno de R, escribir sus propias funciones y utilizar todas las herramientas de programación de R. A lo largo del libro, utilizará sus nuevas habilidades para resolver problemas prácticos de ciencia de datos.\nSi ya se siente cómodo con R y le gustaría enfocarse en cómo analizar datos usando los paquetes Tidyverse de R, se recomienda R para la Ciencia de Datos, un libro de Garrett Grolemund y Hadley Wickham.",
    "crumbs": [
      "Bienvenido"
    ]
  },
  {
    "objectID": "index.html#sobre-la-traducción",
    "href": "index.html#sobre-la-traducción",
    "title": "Programación práctica con R",
    "section": "Sobre la traducción",
    "text": "Sobre la traducción\n Esta traducción de “Programación práctica con R” es un proyecto personal de David Díaz Rodríguez con el objetivo de facilitar el estudio del lenguje de programación R, tanto al propio traductor como a todas aquellas personas de habla hispana que deseen aprender a programar con R.\nSeñalar que esta es una traducción textual del libro por lo que en lo adelante cuando el autor se refiere así mismo en primera persona, será Garrett Grolemund y no el traductor, a excepción del prefacio que fue escrito por Hadley Wickham.\nLa traducción fue realizada usando Google Translate y fueron corregidos algunos errores gramaticales y de coherencia. Si detecta algún error relacionado con contenido de la traducción, siéntase libre de abrir un issue o un pull request en este repositorio.",
    "crumbs": [
      "Bienvenido"
    ]
  },
  {
    "objectID": "index.html#sobre-la-versión-original-en-inglés",
    "href": "index.html#sobre-la-versión-original-en-inglés",
    "title": "Programación práctica con R",
    "section": "Sobre la versión original en inglés",
    "text": "Sobre la versión original en inglés\nPuede consultar la versión original del libro en Hands-On Programming with R. Si desea una copia física del libro, puede solicitarla en amazon; fue publicado por O’Reilly en julio de 2014.\nSi desea retribuir, considere informar un error tipográfico o realizar un pull request en github.com/rstudio-education/hopr para la versión original y en github.com/davidrsch/hopres para esta traducción.\nEste sitio web es (y siempre será) de uso gratuito y está licenciado bajo la licencia Creative Commons Attribution-NonCommercial-NoDerivs 4.0.\nEl libro original fue escrito en RMarkdown con bookdown. Esta traducción esta hecha con Quarto.",
    "crumbs": [
      "Bienvenido"
    ]
  },
  {
    "objectID": "preface.html",
    "href": "preface.html",
    "title": "Prefacio",
    "section": "",
    "text": "Convenciones Usadas en Este Libro\nEste libro le enseñará cómo programar en R. Pasará de cargar datos a escribir sus propias funciones (que superarán las funciones de otros usuarios de R). Pero esta no es una introducción típica a R. Quiero ayudarlo a convertirse en científico de datos, así como en informático, por lo que este libro se centrará en las habilidades de programación que están más relacionadas con la ciencia de datos.\nLos capítulos del libro están ordenados de acuerdo con tres proyectos prácticos; dado que son proyectos bastante sustanciales, abarcan varios capítulos. Elegí estos proyectos por dos razones. Primero, cubren la amplitud del lenguaje R. Aprenderá a cargar datos, ensamblar y desensamblar objetos de datos, navegar por el sistema de entorno de R, escribir sus propias funciones y utilizar todas las herramientas de programación de R, como declaraciones if else, bucles, clases S3, sistema de paquetes de R, y las herramientas de depuración de R. Los proyectos también le enseñarán cómo escribir código R vectorizado, un estilo de código ultrarrápido que aprovecha todas las cosas que R hace mejor.\nPero, lo que es más importante, los proyectos le enseñarán cómo resolver los problemas logísticos de la ciencia de datos—y hay muchos problemas logísticos. Cuando trabaje con datos, deberá almacenar, recuperar y manipular grandes conjuntos de valores sin introducir errores. A medida que avance en el libro, le enseñaré no solo cómo programar con R, sino también cómo usar las habilidades de programación para respaldar su trabajo como científico de datos.\nNo todos los programadores necesitan ser científicos de datos, por lo que no todos los programadores encontrarán útil este libro. Encontrará este libro útil si se encuentra en una de las siguientes categorías:\nUna de las mayores sorpresas de este libro es que no cubro las aplicaciones tradicionales de R, como modelos y gráficos; en cambio, trato a R puramente como un lenguaje de programación. ¿Por qué este enfoque estrecho? R está diseñado para ser una herramienta que ayude a los científicos a analizar datos. Tiene muchas funciones excelentes que hacen gráficos y ajustan modelos a los datos. Como resultado, muchos estadísticos aprenden a usar R como si fuera una pieza de software: aprenden qué funciones hacen lo que quieren e ignoran el resto.\nEste es un enfoque comprensible para aprender R. La visualización y el modelado de datos son habilidades complicadas que requieren toda la atención de un científico. Se necesita experiencia, juicio y enfoque para extraer información confiable de un conjunto de datos. No recomendaría que ningún científico de datos se distraiga con la programación de computadoras hasta que se sienta cómodo con la teoría y la práctica básicas de su oficio. Si desea aprender el oficio de la ciencia de datos, le recomiendo el libro R para la Ciencia de Datos, mi volumen complementario a este libro, coescrito con Hadley Wickham.\nSin embargo, aprender a programar debería estar en la lista de tareas de todos los científicos de datos. Saber programar lo convertirá en un analista más flexible y aumentará su dominio de la ciencia de datos en todos los sentidos. Mi metáfora favorita para describir esto fue presentada por Greg Snow en la lista de correo de ayuda de R en mayo de 2006. Usar funciones en R es como viajar en autobús. Escribir funciones en R es como conducir un coche.\nGreg compara R con SPSS, pero asume que usa todos los poderes de R; es decir, que aprendas a programar en R. Si solo usas funciones que ya existen en R, estás usando R como SPSS: es un bus que solo te puede llevar a ciertos lugares.\nEsta flexibilidad es importante para los científicos de datos. Los detalles exactos de un método o simulación cambiarán de un problema a otro. Si no puede crear un método adaptado a su situación, puede verse tentado a hacer suposiciones poco realistas solo para poder utilizar un método inadecuado que ya existe.\nEste libro te ayudará a dar el salto del autobús al automóvil. Lo he escrito para programadores principiantes. No hablo de la teoría de las ciencias de la computación—no hay discusiones sobre la gran O() y la pequeña o() en estas páginas. Tampoco entro en detalles avanzados como el funcionamiento de la evaluación concisa. Estas aspectos son interesantes si piensas en informática a nivel teórico, pero son una distracción cuando aprendes a programar por primera vez.\nEn su lugar, te enseño a programar en R con tres ejemplos concretos. Estos ejemplos son cortos, fáciles de entender y cubren todo lo que necesita saber.\nHe enseñado este material muchas veces en mi trabajo como Master Instructor en RStudio. Como docente, he descubierto que los estudiantes aprenden conceptos abstractos mucho más rápido cuando se ilustran con ejemplos concretos. Los ejemplos también tienen una segunda ventaja: proporcionan una práctica inmediata. Aprender a programar es como aprender a hablar otro idioma—yprogresas más rápido cuando practicas. De hecho, aprender a programar es aprender a hablar otro idioma. Obtendrá los mejores resultados si sigue los ejemplos del libro y experimenta cada vez que se le ocurre una idea.\nEl libro es un complemento de R para la Ciencia de Datos. En ese libro, Hadley Wickham y yo explicamos cómo usar R para hacer diagramas, modelar datos y escribir informes. Ese libro enseña estas tareas como habilidades de ciencia de datos, que requieren juicio y experiencia—no como ejercicios de programación, que también lo son. Este libro le enseñará a programar en R. No se supone que haya dominado las habilidades de ciencia de datos que se enseñan en R para la Ciencia de Datos (ni que tenga la intención de hacerlo). Sin embargo, este conjunto de habilidades amplifica ese. Y si domina ambos, será un científico de datos con conocimientos de informática, apto para obtener un salario alto e influir en el diálogo científico.\nEn este libro se utilizan las siguientes convenciones tipográficas:\nCursiva:: Indica nuevos términos, URL, direcciones de correo electrónico, nombres de archivo y extensiones de archivo.\nAncho contante:: se utiliza para listas de programas, así como dentro de párrafos para referirse a elementos de programas como nombres de variables o funciones, bases de datos, tipos de datos, variables de entorno, declaraciones y palabras clave.\nNegrita de ancho constante:: muestra comandos u otro texto que el usuario debe escribir literalmente.\nCursiva de ancho constante:: muestra texto que debe reemplazarse con valores proporcionados por el usuario o por valores determinados por el contexto.\nPara comentar o hacer preguntas técnicas sobre este libro, presente un issue en github.com/rstudio-education/hopr.",
    "crumbs": [
      "Prefacio"
    ]
  },
  {
    "objectID": "preface.html#reconocimientos",
    "href": "preface.html#reconocimientos",
    "title": "Prefacio",
    "section": "Reconocimientos",
    "text": "Reconocimientos\nMuchas personas excelentes me han ayudado a escribir este libro, desde mis dos editoras, Courtney Nash y Julie Steele, hasta el resto del equipo de O’Reilly, quienes diseñaron, corrigieron e indexaron el libro. Además, Greg Snow me permitió generosamente citarlo en este prefacio. Les ofrezco todo mi más sincero agradecimiento.\nTambién me gustaría agradecer a Hadley Wickham, quien ha moldeado la forma en que pienso y enseño R. Muchas de las ideas de este libro provienen de Estadística 405, un curso que ayudé a enseñar a Hadley cuando era estudiante de doctorado en la Universidad de Rice.\nMás ideas provinieron de los estudiantes y profesores de Introducción a la ciencia de datos con R, un taller que enseño en nombre de RStudio. Gracias a todos ustedes. Me gustaría agradecer especialmente a mis asistentes de enseñanza Josh Paulson, Winston Chang, Jaime Ramos, Jay Emerson y Vivian Zhang.\nGracias también a JJ Allaire y al resto de mis colegas de RStudio que proporcionan el IDE de RStudio, una herramienta que hace que sea mucho más fácil usar, enseñar y escribir sobre R.\nFinalmente, quisiera agradecer a mi esposa, Kristin, por su apoyo y comprensión mientras escribía este libro.",
    "crumbs": [
      "Prefacio"
    ]
  },
  {
    "objectID": "dice.html",
    "href": "dice.html",
    "title": "Proyecto 1: Dados Ponderados",
    "section": "",
    "text": "Las computadoras le permiten ensamblar, manipular y visualizar conjuntos de datos, todo a velocidades que habrían asombrado a los científicos de ayer. En resumen, ¡las computadoras te dan superpoderes científicos! Pero si desea usarlos, deberá adquirir algunas habilidades de programación.\nComo científico de datos que sabe programar, mejorará su capacidad para:\n\nMemorizar (almacenar) conjuntos de datos completos\nRecuperar valores de datos demandados\nRealizar cálculos complejos con grandes cantidades de datos\nRealizar tareas repetitivas sin descuidarse ni aburrirse\n\nLas computadoras pueden hacer todas estas cosas rápidamente y sin errores, lo que le permite a su mente hacer lo que mejor hace bien: tomar decisiones y asignar significado.\n¿Suena emocionante? ¡Estupendo! Vamos a empezar.\nCuando era estudiante universitario, a veces soñaba despierto con ir a Las Vegas. Pensé que saber estadísticas podría ayudarme a ganar a lo grande. Si eso es lo que te llevó a la ciencia de datos, será mejor que te sientes; tengo algunas malas noticias. Incluso un estadístico perderá dinero en un casino a largo plazo. Esto se debe a que las probabilidades de cada juego siempre están a favor del casino, sin embargo, hay una laguna en esta regla. Puede ganar dinero–y también de manera confiable. Todo lo que tienes que hacer es ser el casino.\nLo creas o no, R puede ayudarte a hacerlo. A lo largo del libro, usará R para construir tres objetos virtuales: un par de dados que puede lanzar para generar números aleatorios, una baraja de cartas que puede barajar y repartir, y una máquina tragamonedas inspirada en máquinas reales. Después de eso, solo necesitará agregar algunos gráficos de video y una cuenta bancaria (y tal vez obtener algunas licencias gubernamentales), y estará en el negocio. Te dejo esos detalles a ti.\nEstos proyectos son ligeros, pero también profundos. A medida que los complete, se convertirá en un experto en las habilidades que necesita para trabajar con datos como científico de datos. Aprenderá cómo almacenar datos en la memoria de su computadora, cómo acceder a los datos que ya están allí y cómo transformar los valores de los datos en la memoria cuando sea necesario. También aprenderá a escribir sus propios programas en R que puede usar para analizar datos y ejecutar simulaciones.\nSi simular una máquina tragamonedas (o dados o cartas) parece frívolo, piénselo de esta manera: jugar en una máquina tragamonedas es un proceso. Una vez que pueda simularlo, podrá simular otros procesos, como el muestreo de arranque, la cadena de Markov Monte Carlo y otros procedimientos de análisis de datos. Además, estos proyectos brindan ejemplos concretos para aprender todos los componentes de la programación R: objetos, tipos de datos, clases, notación, funciones, entornos, árboles if, bucles y vectorización. Este primer proyecto facilitará el estudio de estas cosas al enseñarle los conceptos básicos de R.\nSu primera misión es simple: ensamblar código R que simulará lanzar un par de dados, como en una mesa de dados. Una vez que haya hecho eso, ponderaremos un poco los dados a su favor, solo para mantener las cosas interesantes.\nEn este proyecto, aprenderá cómo:\n\nUtilizar las interfaces R y RStudio\nEjecutar comandos R\nCrear objetos R\nEscribir sus propias funciones y scripts de R\nCargar y usar paquetes R\nGenerar muestras aleatorias\nCrear gráficos de manera rápida\nObtener ayuda cuando la necesite\n\nNo se preocupe si parece que cubrimos mucho terreno de manera rápido. Este proyecto está diseñado para brindarle una descripción general concisa del lenguaje R. Regresará a muchos de los conceptos que aprederá en los proyectos 2 y 3, donde examinará los conceptos en profundidad.\nDeberá tener R y RStudio instalados en su computadora antes de poder usarlos. Ambos son gratuitos y fáciles de descargar. Consulte el Apéndice A para obtener instrucciones completas. Si está listo para comenzar, abra RStudio en su computadora y siga leyendo.",
    "crumbs": [
      "Proyecto 1: Dados Ponderados"
    ]
  },
  {
    "objectID": "basics.html",
    "href": "basics.html",
    "title": "1  Lo Más Básico",
    "section": "",
    "text": "1.1 La Interfaz de Usuario de R\nEste capítulo proporciona una descripción general amplia del lenguaje R que lo ayudará a programar de inmediato. En él, construirás un par de dados virtuales que puedes usar para generar números aleatorios. No se preocupe si nunca ha programado antes; el capítulo le enseñará todo lo que necesita saber.\nPara simular un par de dados, tendrás que destilar cada dado en sus características esenciales. No puede colocar un objeto físico, como un dado, en una computadora (bueno, no sin destornillar algunos tornillos), pero puede guardar información sobre el objeto en la memoria de su computadora.\n¿Qué información debe guardar? En general, un dado tiene seis piezas importantes de información: cuando tiras un dado, solo puede dar como resultado uno de los seis números: 1, 2, 3, 4, 5 y 6. Puedes capturar las características esenciales de un dado guardando los números 1, 2, 3, 4, 5 y 6 como un grupo de valores en la memoria de su computadora.\nTrabajemos primero en guardar estos números y luego consideremos un método para “lanzar” nuestro dado.\nAntes de que pueda pedirle a su computadora que guarde algunos números, necesitará saber cómo hablarle. Ahí es donde entran R y RStudio. RStudio le brinda una manera de comunicarse con su computadora. R le brinda un idioma para hablar. Para comenzar, abra RStudio tal como abriría cualquier otra aplicación en su computadora. Cuando lo haga, debería aparecer una ventana en su pantalla como la que se muestra en la Figura Figura 1.1.\nFigura 1.1: Su computadora cumple con sus órdenes cuando escribe comandos R en el indicador en la línea inferior del panel de la consola. No olvides presionar la tecla Enter. Cuando abre RStudio por primera vez, la consola aparece en el panel de su izquierda, pero puede cambiar esto con File &gt; Preferences en la barra de menú.\nLa interfaz de RStudio es simple. Escriba el código R en la línea inferior del panel de la consola de RStudio y luego haga clic en Entrar para ejecutarlo. El código que escribe se llama comando, porque ordenará a su computadora que haga algo por usted. La línea en la que lo escribe se llama línea de comando.\nCuando escribe un comando en la consola y presiona Enter, su computadora ejecuta el comando y le muestra los resultados. Luego, RStudio muestra un mensaje nuevo para su próximo comando. Por ejemplo, si escribe 1 + 1 y pulsa Enter, RStudio mostrará:\nNotarás que aparece un [1] al lado de tu resultado. R solo le informa que esta línea comienza con el primer valor en su resultado. Algunos comandos devuelven más de un valor y sus resultados pueden llenar varias líneas. Por ejemplo, el comando 100:130 devuelve 31 valores; crea una secuencia de números enteros del 100 al 130. Observe que aparecen nuevos números entre corchetes al comienzo de la segunda y tercera líneas de salida. Estos números solo significan que la segunda línea comienza con el valor 14 en el resultado y la tercera línea comienza con el valor 25. En su mayoría, puede ignorar los números que aparecen entre corchetes:\nSi escribe un comando incompleto y presiona Enter, R mostrará un + en la consola, lo que significa que R está esperando que escriba el resto de su comando. Termina el comando o presiona Escape para comenzar de nuevo:\nSi escribe un comando que R no reconoce, R devolverá un mensaje de error. Si alguna vez ve un mensaje de error, no entre en pánico. R solo le está diciendo que su computadora no pudo entender o hacer lo que le pidió que hiciera. Luego puede probar un comando diferente en la siguiente línea:\nUna vez que domines la línea de comando, puedes hacer fácilmente cualquier cosa en R que harías con una calculadora. Por ejemplo, podrías hacer algo de aritmética básica:\n¿Notaste algo diferente en este código? He dejado fuera los &gt; y [1]. Esto hará que el código sea más fácil de copiar y pegar si desea colocarlo en su propia consola.\nR trata el carácter del hashtag, #, de una manera especial; R no ejecutará nada que siga a un hashtag en una línea. Esto hace que los hashtags sean muy útiles para agregar comentarios y anotaciones a su código. Los humanos podrán leer los comentarios, pero su computadora los pasará por alto. El hashtag se conoce como símbolo de comentario en R.\nEn el resto del libro, usaré hashtags para mostrar los resultados de las lineas de código R. Usaré un solo hashtag para agregar mis propios comentarios y un hashtag doble, ##, para mostrar los resultados del código. Evitaré mostrar &gt; y [1] a menos que quiera que los mires.\nEjercicio 2.1 (Magia con Numeros) Esa es la interfaz básica para ejecutar código R en RStudio. ¿Crees que lo tienes? Si es así, intente realizar estas sencillas tareas. Si ejecuta todo correctamente, debería terminar con el mismo número con el que comenzó:\nA lo largo del libro, pondré ejercicios en partes, como el de arriba. Seguiré cada ejercicio con una respuesta modelo, como la siguiente.\nSolución. Puede comenzar con el número 10 y luego seguir los siguientes pasos:",
    "crumbs": [
      "Proyecto 1: Dados Ponderados",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Lo Más Básico</span>"
    ]
  },
  {
    "objectID": "basics.html#la-interfaz-de-usuario-de-r",
    "href": "basics.html#la-interfaz-de-usuario-de-r",
    "title": "1  Lo Más Básico",
    "section": "",
    "text": "Si aún no tiene R y RStudio instalados en su computadora–o no sabe de lo que estoy hablando– visite el Apéndice A. El apéndice le dará una descripción general de las dos herramientas gratuitas y le indicará cómo descargarlas.\n\n\n\n\n\n&gt; 1 + 1\n[1] 2\n&gt;\n\n&gt; 100:130\n [1] 100 101 102 103 104 105 106 107 108 109 110 111 112\n[14] 113 114 115 116 117 118 119 120 121 122 123 124 125\n[25] 126 127 128 129 130\n\n\n\n\n\n\nEl operador de dos puntos (:) devuelve todos los números enteros entre los dos números enteros especificados antes y después de los dos puntos. Es una manera fácil de crear una secuencia de números.\n\n\n\n\n\n\n\n\n\n¿R no es un idioma?\nEs posible que me escuche hablar de R en tercera persona. Por ejemplo, podría decir: “Dígale a R que haga esto” o “Dígale a R que haga aquello”, pero, por supuesto, R no puede hacer nada; es solo un idioma. Esta forma de hablar es una forma abreviada de decir: “Dígale a su computadora que haga esto escribiendo un comando en el lenguaje R en su consola RStudio”. Su computadora, y no R, hace el trabajo real.\n¿Es esta abreviatura confusa y un poco perezosa de usar? Sí. ¿Lo usa mucha gente? Todos los que conozco, probablemente porque es muy conveniente.\n\n\n\n\n\n\n\n\n\n¿Cuándo compilamos?\nEn algunos lenguajes, como C, Java y FORTRAN, debe compilar su código legible por humanos en un código legible por máquina (a menudo 1 y 0) antes de poder ejecutarlo. Si ha programado en un lenguaje de este tipo antes, puede preguntarse si tiene que compilar su código R antes de poder usarlo. La respuesta es no. R es un lenguaje de programación dinámico, lo que significa que R interpreta automáticamente su código a medida que lo ejecuta.\n\n\n\n\n&gt; 5 -\n+\n+ 1\n[1] 4\n\n&gt; 3 % 5\nError: unexpected input in \"3 % 5\"\n&gt;\n\n2 * 3   \n## 6\n\n4 - 1   \n## 3\n\n6 / (4 - 1)   \n## 2\n\n\n\n\n\n\n\n\n\nCancelar comandos\nAlgunos comandos de R pueden tardar mucho tiempo en ejecutarse. Puede cancelar un comando una vez que ha comenzado presionando ctrl + c. Tenga en cuenta que R también puede tardar mucho tiempo en cancelar el comando.\n\n\n\n\n\nElige cualquier número y súmale 2.\nMultiplica el resultado por 3.\nResta 6 de la respuesta.\nDivide lo que obtienes por 3.\n\n\n\n10 + 2\n## 12\n\n12 * 3\n## 36\n\n36 - 6\n## 30\n\n30 / 3\n## 10",
    "crumbs": [
      "Proyecto 1: Dados Ponderados",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Lo Más Básico</span>"
    ]
  },
  {
    "objectID": "basics.html#objetos",
    "href": "basics.html#objetos",
    "title": "1  Lo Más Básico",
    "section": "\n1.2 Objetos",
    "text": "1.2 Objetos\nAhora que sabes cómo usar R, usémoslo para hacer un dado virtual. El operador : de hace un par de páginas le brinda una buena manera de crear un grupo de números del uno al seis. El operador : devuelve sus resultados como un vector, un conjunto unidimensional de números:\n1:6\n## 1 2 3 4 5 6\n¡Eso es todo lo que hay sobre el aspecto de un dado virtual! Pero aún no has terminado. Ejecutar 1:6 generó un vector de números para que lo veas, pero no guardó ese vector en ninguna parte de la memoria de tu computadora. Lo que está viendo son básicamente las huellas de seis números que existieron brevemente y luego se fundieron de nuevo en la memoria RAM de tu computadora. Si desea volver a usar esos números, tendrá que pedirle a su computadora que los guarde en algún lugar. Puede hacerlo creando un objeto de R.\nR le permite guardar datos almacenándolos dentro de un objeto R. ¿Qué es un objeto? Solo un nombre que puede usar para recuperar datos almacenados. Por ejemplo, puede guardar datos en un objeto como a o b. Siempre que R encuentre el objeto, lo reemplazará con los datos guardados en su interior, así:\na &lt;- 1\na\n## 1\n\na + 2\n## 3\n\n\n\n\n\n\n¿Qué acaba de suceder?\n\nPara crear un objeto R, elija un nombre y luego use el símbolo menor que, &lt;, seguido de un signo menos, -, para guardar datos en él. Esta combinación parece una flecha, &lt;-. R creará un objeto, le dará su nombre y almacenará en él lo que siga a la flecha. Entonces a &lt;- 1 almacena 1 en un objeto llamado a.\nCuando le preguntas a R qué hay en a, R te dice en la siguiente línea.\nTambién puede usar su objeto en nuevos comandos R. Dado que a almacenó previamente el valor de 1, ahora está agregando 1 a 2.\n\n\n\n\nEntonces, para otro ejemplo, el siguiente código crearía un objeto llamado dado que contiene los números del uno al seis. Para ver lo que está almacenado en un objeto, simplemente escriba el nombre del objeto por sí mismo:\ndado &lt;- 1:6\n\ndado\n## 1 2 3 4 5 6\nCuando crea un objeto, el objeto aparecerá en el panel de Environment de RStudio, como se muestra en la Figura Figura 1.2. Este panel le mostrará todos los objetos que ha creado desde que abrió RStudio.\n\n\n\n\n\n\n\nFigura 1.2: El panel de Environment de RStudio realiza un seguimiento de los objetos R que crea.\n\n\n\n\nPuedes nombrar un objeto en R casi como quieras, pero hay algunas reglas. Primero, un nombre no puede comenzar con un número. Segundo, un nombre no puede usar algunos símbolos especiales, como ^, !, $, @, +, -, /, or *:\n\n\nBuenos nombres\nNombres que causan error\n\n\n\na\n1trial\n\n\nb\n$\n\n\nFOO\n^mean\n\n\nmy_var\n2nd\n\n\n.day\n!bad\n\n\n\n\n\n\n\n\n\nMayúsculas\nR distingue entre mayúsculas y minúsculas, por lo que nombre y Nombre se referirán a diferentes objetos:\nNombre &lt;- 1nombre &lt;- 0\nNombre + 1## 2\n\n\n\nFinalmente, R sobrescribirá cualquier información anterior almacenada en un objeto sin pedirle permiso. Por lo tanto, es una buena idea no usar nombres que ya están en uso:\nmy_number &lt;- 1\nmy_number \n## 1\n\nmy_number &lt;- 999\nmy_number\n## 999\nPuedes ver qué nombres de objetos ya has usado con la función ls:\nls()\n## \"a\"         \"dado\"       \"my_number\" \"nombre\"     \"Nombre\"     \nTambién puede ver qué nombres ha utilizado examinando el panel de environment de RStudio.\nAhora tiene un dado virtual que está almacenado en la memoria de su computadora. Puedes acceder a él cuando quieras escribiendo la palabra dado. Entonces, ¿qué puedes hacer con este dado? Bastante. R reemplazará un objeto con su contenido siempre que el nombre del objeto aparezca en un comando. Entonces, por ejemplo, puedes hacer todo tipo de operaciones matemáticas con el dado. Las matemáticas no son tan útiles para lanzar dados, pero la manipulación de conjuntos de números será su día a día como científico de datos. Así que echemos un vistazo a cómo hacer eso:\ndado - 1\n## 0 1 2 3 4 5\n\ndado / 2\n## 0.5 1.0 1.5 2.0 2.5 3.0\n\ndado * dado\n## 1  4  9 16 25 36\nSi eres un gran fanático del álgebra lineal (¿y quién no lo es?), puedes notar que R no siempre sigue las reglas de la multiplicación de matrices. En su lugar, R utiliza ejecución por elementos. Cuando manipulas un conjunto de números, R aplicará la misma operación a cada elemento del conjunto. Entonces, por ejemplo, cuando ejecuta dado - 1, R resta uno de cada elemento de dado.\nCuando usa dos o más vectores en una operación, R alineará los vectores y realizará una secuencia de operaciones individuales. Por ejemplo, cuando ejecuta dado * dado, R alinea los dos vectores dado y luego multiplica el primer elemento del vector 1 por el primer elemento del vector 2. R luego multiplica el segundo elemento del vector 1 por el segundo elemento del vector 2, y así sucesivamente, hasta que se hayan multiplicado todos los elementos. El resultado será un nuevo vector de la misma longitud que los dos primeros, como se muestra en la Figura Figura 1.3.\n\n\n\n\n\n\n\nFigura 1.3: Cuando R realiza una ejecución por elementos, hace coincidir los vectores y luego manipula cada par de elementos de forma independiente.\n\n\n\n\nSi le da a R dos vectores de longitudes desiguales, R repetirá el vector más corto hasta que sea tan largo como el vector más largo y luego hará los cálculos, como se muestra en la Figura Figura 1.4. Este no es un cambio permanente: el vector más corto tendrá su tamaño original después de que R haga los cálculos. Si la longitud del vector largo no es divisible equitativamente por el vctor corto, R devolverá un mensaje de advertencia. Este comportamiento se conoce como reciclado de vectores y ayuda a R a realizar operaciones por elementos:\n1:2\n## 1 2\n\n1:4\n## 1 2 3 4\n\ndado\n## 1 2 3 4 5 6\n\ndado + 1:2\n## 2 4 4 6 6 8\n\ndado + 1:4\n## 2 4 6 8 6 8\nWarning message:\nIn dado + 1:4 :\n  longer object length is not a multiple of shorter object length\n\n\n\n\n\n\n\nFigura 1.4: R repetirá un vector corto para realizar operaciones por elementos con dos vectores de longitud desigual.\n\n\n\n\nLas operaciones basadas en elementos son una característica muy útil en R porque manipulan grupos de valores de forma ordenada. Cuando comience a trabajar con conjuntos de datos, las operaciones por elementos garantizarán que los valores de una observación o caso solo se emparejen con valores de la misma observación o caso. Las operaciones basadas en elementos también facilitan la escritura de sus propios programas y funciones en R.\nPero no creas que R ha renunciado a la multiplicación de matrices tradicional. Solo tienes que pedirlo cuando quieras. Puedes hacer multiplicaciones internas con el operador %*% y multiplicaciones externas con el operador %o%:\ndado %*% dado\n## 91\n\ndado %o% dado\n##      [,1] [,2] [,3] [,4] [,5] [,6]\n## [1,]    1    2    3    4    5    6\n## [2,]    2    4    6    8   10   12\n## [3,]    3    6    9   12   15   18\n## [4,]    4    8   12   16   20   24\n## [5,]    5   10   15   20   25   30\n## [6,]    6   12   18   24   30   36\nTambién puedes hacer cosas como transponer una matriz con t y tomar su determinante con det.\nNo se preocupe si no está familiarizado con estas operaciones. Son fáciles de buscar y no los necesitará para este libro.\nAhora que puede hacer operaciones matemáticas con su objeto dado, veamos cómo podría “tirarlo”. Lanzar el dado requerirá algo más sofisticado que la aritmética básica; deberá seleccionar aleatoriamente uno de los valores del dado. Y para eso, necesitarás una función.",
    "crumbs": [
      "Proyecto 1: Dados Ponderados",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Lo Más Básico</span>"
    ]
  },
  {
    "objectID": "basics.html#funciones",
    "href": "basics.html#funciones",
    "title": "1  Lo Más Básico",
    "section": "\n1.3 Funciones",
    "text": "1.3 Funciones\nR viene con muchas funciones que puede usar para realizar tareas sofisticadas como el muestreo aleatorio. Por ejemplo, puede redondear un número con la función round o calcular su factorial con la función factorial. Usar una función es bastante simple. Simplemente escriba el nombre de la función y luego los datos sobre los que desea que opere la función entre paréntesis::\nround(3.1415)\n## 3\n\nfactorial(3)\n## 6\nLos datos que pasa a la función se denominan argumento de la función. El argumento puede ser datos sin procesar, un objeto R o incluso los resultados de otra función R. En este último caso, R trabajará desde la función más interna hacia la más externa, como en la Figura Figura 1.5.\nmean(1:6)\n## 3.5\n\nmean(dado)\n## 3.5\n\nround(mean(dado))\n## 4\n\n\n\n\n\n\n\nFigura 1.5: Cuando vincula funciones, R las resolverá desde la operación más interna hasta la más externa. Aquí R primero busca el dado, luego calcula la media de uno a seis y luego redondea la media.”}\n\n\n\n\nPor suerte para nosotros, hay una función R que puede ayudar a “tirar” el dado. Puede simular una tirada del dado con la función sample de R. sample toma dos argumentos: un vector llamado x y un número llamado size. sample devolverá elementos de size del vector:\nsample(x = 1:4, size = 2)\n## 3 2\nPara tirar el dado y obtener un número de vuelta, establezca x en dado y muestree un elemento de él. Obtendrá un número nuevo (quizás diferente) cada vez que lo haga rodar:\nsample(x = dado, size = 1)\n## 2\n\nsample(x = dado, size = 1)\n## 1\n\nsample(x = dado, size = 1)\n## 6\nMuchas funciones de R toman múltiples argumentos que las ayudan a hacer su trabajo. Puede dar a una función tantos argumentos como desee siempre que separe cada argumento con una coma.\nEs posible que hayas notado que establecí dado y 1 iguales a los nombres de los argumentos en sample, x y size. Cada argumento en cada función de R tiene un nombre. Puede especificar qué datos deben asignarse a qué argumento estableciendo un nombre igual a data, como en el código anterior. Esto se vuelve importante a medida que comienza a pasar múltiples argumentos a la misma función; los nombres lo ayudan a evitar pasar los datos incorrectos al argumento incorrecto. Sin embargo, el uso de nombres es opcional. Notará que los usuarios de R no suelen usar el nombre del primer argumento en una función. Por lo tanto, es posible que vea el código anterior escrito como:\nsample(dado, size = 1)\n## 2\nA menudo, el nombre del primer argumento no es muy descriptivo y, de todos modos, suele ser obvio a qué se refiere el primer dato.\nPero, ¿cómo saber qué nombres de argumento usar? Si intenta usar un nombre que una función no espera, es probable que obtenga un error:\nround(3.1415, corners = 2)\n## Error in round(3.1415, corners = 2) : unused argument(s) (corners = 2)\nSi no está seguro de qué nombres usar con una función, puede buscar los argumentos de la función con args. Para hacer esto, coloque el nombre de la función entre paréntesis detrás de args. Por ejemplo, puede ver que la función round toma dos argumentos, uno llamado x y otro llamado digits:\nargs(round)\n## function (x, digits = 0) \n## NULL\n¿Notaste que args muestra que el argumento digits de round ya está establecido en 0? Con frecuencia, una función R tomará argumentos opcionales como digits. Estos argumentos se consideran opcionales porque vienen con un valor predeterminado. Puede pasar un nuevo valor a un argumento opcional si así lo desea, y R utilizará el valor predeterminado si no proporciona uno nuevo. Por ejemplo, “round” redondeará su número a 0 dígitos más allá del punto decimal de forma predeterminada. Para anular el valor predeterminado, proporcione su propio valor para digits:\nround(3.1415)\n## 3\n\nround(3.1415, digits = 2)\n## 3.14\nDebe escribir los nombres de cada argumento después del primero o dos cuando llame a una función con múltiples argumentos. ¿Por qué? Primero, esto lo ayudará a usted y a otros a comprender su código. Por lo general, es obvio a qué argumento se refiere su primera entrada (y, a veces, también la segunda entrada). Sin embargo, necesitaría una memoria grande para recordar los argumentos tercero y cuarto de cada función R. En segundo lugar, y más importante, escribir los nombres de los argumentos evita errores.\nSi no escribe los nombres de sus argumentos, R hará coincidir sus valores con los argumentos de su función por orden. Por ejemplo, en el siguiente código, el primer valor, dado, coincidirá con el primer argumento de sample, que se llama x. El siguiente valor, 1, coincidirá con el siguiente argumento, size:\nsample(dado, 1)\n## 2\nA medida que proporciona más argumentos, es más probable que su orden y el orden de R no coincidan. Como resultado, los valores pueden pasarse al argumento incorrecto. Los nombres de los argumentos evitan esto. R siempre hará coincidir un valor con el nombre de su argumento, sin importar dónde aparezca en el orden de los argumentos:\nsample(size = 1, x = dado)\n## 2\n\n1.3.1 Muestra con reemplazo\nSi configura size = 2, puede casi simular un par de dados. Antes de ejecutar ese código, piense por un minuto por qué ese podría ser el caso. sample devolverá dos números, uno para cada dado:\nsample(dado, size = 2)\n## 3 4\nDije que esto “casi” funciona porque este método hace algo divertido. Si lo usa muchas veces, notará que el segundo dado nunca tiene el mismo valor que el primero, lo que significa que nunca obtendrá algo como un par de tres o un par de unos. ¿Qué esta pasando?\nPor defecto, sample construye una muestra sin reemplazo. Para ver lo que esto significa, imagina que sample coloca todos los valores de dado en un frasco o urna. Luego imagine que sample alcanza el frasco y extrae valores uno por uno para construir su muestra. Una vez que se ha extraído un valor del frasco, sample lo deja a un lado. El valor no vuelve al frasco, por lo que no se puede volver a extraer. Entonces, si sample selecciona un seis en su primer sorteo, no podrá seleccionar un seis en el segundo sorteo; seis ya no está en el frasco para ser seleccionado. Aunque sample crea su muestra electrónicamente, sigue este comportamiento aparentemente físico.\nUn efecto secundario de este comportamiento es que cada sorteo depende de los sorteos anteriores. Sin embargo, en el mundo real, cuando lanzas un par de dados, cada dado es independiente del otro. Si el primer dado sale seis, no impide que el segundo dado salga seis. De hecho, no influye en el segundo dado de ninguna manera. Puede recrear este comportamiento en sample agregando el argumento replace = TRUE:\nsample(dado, size = 2, replace = TRUE)\n## 5 5\nEl argumento replace = TRUE hace que sample muestree con reemplazo. Nuestro ejemplo de frasco proporciona una buena manera de comprender la diferencia entre el muestreo con reemplazo y sin reemplazo. Cuando sample usa reemplazo, extrae un valor del frasco y registra el valor. Luego vuelve a poner el valor en el frasco. En otras palabras, sample reemplaza cada valor después de cada sorteo. Como resultado, sample puede seleccionar el mismo valor en el segundo sorteo. Cada valor tiene la posibilidad de ser seleccionado cada vez. Es como si cada sorteo fuera el primer sorteo.\nEl muestreo con reemplazo es una manera fácil de crear muestras aleatorias independientes. Cada valor en su muestra será una muestra de tamaño uno que es independiente de los otros valores. Esta es la forma correcta de simular un par de dados.\nsample(dado, size = 2, replace = TRUE)\n## 2 4\nFelicítate a ti mismo; ¡Acabas de ejecutar tu primera simulación en R! Ahora tiene un método para simular el resultado de lanzar un par de dados. Si desea sumar los dados, puede ingresar su resultado directamente en la función sum:\ndados &lt;- sample(dado, size = 2, replace = TRUE)\ndados\n## 2 4\n\nsum(dados)\n## 6\n¿Qué pasaría si llamas dados varias veces? ¿Generaría R un nuevo par de valores de dados cada vez? Probemos:\ndados\n## 2 4\n\ndados\n## 2 4\n\ndados\n## 2 4\nNo. Cada vez que llame a dados, R le mostrará el resultado de esa vez que llamó a sample y guardó la salida en dados. R no volverá a ejecutar sample(dado, 2, replace = TRUE) para crear una nueva tirada de dados. Esto es un alivio en cierto modo. Una vez que guarda un conjunto de resultados en un objeto de R, esos resultados no cambian. La programación sería bastante difícil si los valores de sus objetos cambiaran cada vez que los llama.\nSin embargo, sería conveniente tener un objeto que pueda volver a tirar los dados cada vez que lo llames. Puede hacer tal objeto escribiendo su propia función de R.",
    "crumbs": [
      "Proyecto 1: Dados Ponderados",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Lo Más Básico</span>"
    ]
  },
  {
    "objectID": "basics.html#Escribir-funciones",
    "href": "basics.html#Escribir-funciones",
    "title": "1  Lo Más Básico",
    "section": "\n1.4 Escribiendo Sus Propias Funciones",
    "text": "1.4 Escribiendo Sus Propias Funciones\nPara recapitular, ya tiene un código de R en funcionamiento que simula lanzar un par de dados:\ndado &lt;- 1:6\ndados &lt;- sample(dado, size = 2, replace = TRUE)\nsum(dados)\nPuede volver a escribir este código en la consola en cualquier momento que desee volver a tirar los dados. Sin embargo, esta es una forma incómoda de trabajar con el código. Sería más fácil usar su código si lo envolviera en su propia función, que es exactamente lo que haremos ahora. Vamos a escribir una función llamada tirar que puedes usar para lanzar tus dados virtuales. Cuando hayas terminado, la función funcionará así: cada vez que llames a tirar(), R devolverá la suma de tirar dos dados:\ntirar()\n## 8 \n\ntirar()\n## 3\n\ntirar()\n## 7\nLas funciones pueden parecer misteriosas o sofisticadas, pero son solo otro tipo de objeto de R. En lugar de contener datos, contienen código. Este código se almacena en un formato especial que facilita su reutilización en situaciones nuevas. Puede escribir sus propias funciones recreando este formato.\n\n1.4.1 El Constructor de Funciones\nCada función en R tiene tres partes básicas: un nombre, un cuerpo de código y un conjunto de argumentos. Para crear su propia función, debe replicar estas partes y almacenarlas en un objeto de R, esto lo puede hacer con la función function. Para hacer esto, llama a function() y sigue con un par de llaves, {}:\nmi_funcion &lt;- function() {}\nfunction construirá una función a partir de cualquier código R que coloque entre las llaves. Por ejemplo, puede convertir su código de dados en una función llamando:\ntirar &lt;- function() {\n  dado &lt;- 1:6\n  dados &lt;- sample(dado, size = 2, replace = TRUE)\n  sum(dados)\n}\n\n\n\n\n\n\nObserve que he aplicado sangría a cada línea de código entre las llaves. Esto hace que el código sea más fácil de leer para usted y para mí, pero no tiene impacto en cómo se ejecuta el código. R ignora los espacios y los saltos de línea y ejecuta una expresión completa a la vez.\n\n\n\nSimplemente presione la tecla Enter entre cada línea después de la primera llave, {. R esperará a que escribas la última llave, }, antes de responder.\nNo olvide guardar la salida de function en un objeto de R. Este objeto se convertirá en su nueva función. Para usarlo, escriba el nombre del objeto seguido de un paréntesis de apertura y cierre:\ntirar()\n## 9\nPuede pensar en los paréntesis como el “disparador” que hace que R ejecute la función. Si escribe el nombre de una función sin los paréntesis, R le mostrará el código que está almacenado dentro de la función. Si escribe el nombre con los paréntesis, R ejecutará ese código:\ntirar\n## function() {\n##   dado &lt;- 1:6\n##   dados &lt;- sample(dado, size = 2, replace = TRUE)\n##   sum(dados)\n## }\n\ntirar()\n## 6\nEl código que coloca dentro de su función se conoce como el cuerpo de la función. Cuando ejecuta una función en R, R ejecutará todo el código en el cuerpo y luego devolverá el resultado de la última línea de código. Si la última línea de código no devuelve un valor, tampoco lo hará su función, por lo que debe asegurarse de que su última línea de código devuelva un valor. Una forma de verificar esto es pensar en lo que sucedería si ejecutara el cuerpo del código línea por línea en la consola. ¿Mostraría R un resultado después de la última línea, o no?\nAquí hay un código que mostraría un resultado:\ndados\n1 + 1\nsqrt(2)\nY aquí hay un código que no:\ndados &lt;- sample(dado, size = 2, replace = TRUE)\ndos &lt;- 1 + 1\na &lt;- sqrt(2)\n¿Notas el patrón? Estas líneas de código no devuelven un valor a la línea de comando; guardan un valor a un objeto.",
    "crumbs": [
      "Proyecto 1: Dados Ponderados",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Lo Más Básico</span>"
    ]
  },
  {
    "objectID": "basics.html#argumentos",
    "href": "basics.html#argumentos",
    "title": "1  Lo Más Básico",
    "section": "\n1.5 Argumentos",
    "text": "1.5 Argumentos\n¿Qué pasa si eliminamos una línea de código de nuestra función y cambiamos el nombre dado a bones, así?\ntirar2 &lt;- function() {\n  dados &lt;- sample(bones, size = 2, replace = TRUE)\n  sum(dados)\n}\nAhora obtendré un error cuando ejecute la función. La función necesita el objeto bones para hacer su trabajo, pero no se puede encontrar ningún objeto llamado bones:\ntirar2()\n## Error in sample(bones, size = 2, replace = TRUE) : \n##   object 'bones' not found\nPuedes proporcionar bones cuando llamas a tirar2 si conviertes a bones en un argumento de la función. Para hacer esto, pon el nombre bones entre los paréntesis que siguen a function cuando definas tirar2:\ntirar2 &lt;- function(bones) {\n  dados &lt;- sample(bones, size = 2, replace = TRUE)\n  sum(dados)\n}\nAhora tirar2 funcionará siempre y cuando proporciones bones cuando llames a la función. Puede aprovechar esto para lanzar diferentes tipos de dados cada vez que llamas tirar2. ¡Calabozos y Dragones, aquí vamos!\nRecuerda, estamos lanzando pares de dados:\ntirar2(bones = 1:4)\n##  3\n\ntirar2(bones = 1:6)\n## 10\n\ntirar2(1:20)\n## 31\nTenga en cuenta que tirar2 seguirá dando un error si no proporciona un valor para el argumento bones cuando llame a tirar2:\ntirar2()\n## Error in sample(bones, size = 2, replace = TRUE) : \n##   argument \"bones\" is missing, with no default\nPuede evitar este error dando al argumento bones un valor predeterminado. Para hacer esto, establece bones igual a un valor cuando definas tirar2:\ntirar2 &lt;- function(bones = 1:6) {\n  dados &lt;- sample(bones, size = 2, replace = TRUE)\n  sum(dados)\n}\nAhora puede proporcionar un nuevo valor para bones si lo desea, y tirar2 usará el valor predeterminado si no lo desea:\ntirar2()\n## 9\nPuede dar a sus funciones tantos argumentos como desee. Simplemente enumere sus nombres, separados por comas, entre los paréntesis que siguen a function.Cuando se ejecuta la función, R reemplazará cada nombre de argumento en el cuerpo de la función con el valor que el usuario proporciona para el argumento. Si el usuario no proporciona un valor, R reemplazará el nombre del argumento con el valor predeterminado del argumento (si definió uno).\nPara resumir, function te ayuda a construir tus propias funciones de R. Usted crea un cuerpo de código para que su función se ejecute escribiendo código entre las llaves que siguen a function. Usted crea argumentos para que su función los use proporcionando sus nombres entre los paréntesis que siguen a function. Finalmente, le da un nombre a su función guardando su salida en un objeto de R, como se muestra en la Figura Figura 1.6.\nUna vez que haya creado su función, R la tratará como cualquier otra función en R. Piense en lo útil que es. ¿Alguna vez ha intentado crear una nueva opción de Excel y agregarla a la barra de menú de Microsoft? ¿O una nueva animación de diapositivas y agregarla a las opciones de Powerpoint? Cuando trabajas con un lenguaje de programación, puedes hacer este tipo de cosas. A medida que aprenda a programar en R, podrá crear herramientas nuevas, personalizadas y reproducibles para usted cuando lo desee. Proyecto 3: Máquina Tragamonedas te enseñará mucho más sobre escribir funciones en R.\n\n\n\n\n\n\n\nFigura 1.6: Cada función en R tiene las mismas partes y puede usar function para crear estas partes. Asigne el resultado a un nombre, para que pueda llamar a la función más tarde.",
    "crumbs": [
      "Proyecto 1: Dados Ponderados",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Lo Más Básico</span>"
    ]
  },
  {
    "objectID": "basics.html#scripts",
    "href": "basics.html#scripts",
    "title": "1  Lo Más Básico",
    "section": "\n1.6 Scripts",
    "text": "1.6 Scripts\n¿Qué pasa si quieres editar tirar2 de nuevo? Podría regresar y volver a escribir cada línea de código en tirar2, pero sería mucho más fácil si tuviera un borrador del código para empezar. Puede crear un borrador de su código a medida que avanza utilizando un script de R. Un script de R es solo un archivo de texto sin formato en el que guarda el código R. Puede abrir un script de R en RStudio yendo a File&gt; New File&gt; R script en la barra de menú. RStudio luego abrirá un script nuevo sobre el panel de su consola, como se muestra en la Figura Figura 1.7.\nLe recomiendo encarecidamente que escriba y edite todo su código de R en un script antes de ejecutarlo en la consola. ¿Por qué? Este hábito crea un registro reproducible de su trabajo. Cuando termine el día, puede guardar su secuencia de comandos y luego usarla para volver a ejecutar todo el análisis al día siguiente. Los scripts también son muy útiles para editar y corregir su código, y hacen una buena copia de su trabajo para compartir con otros. Para guardar un script, haga clic en el panel de scripts y luego vaya a File &gt; Save as en la barra de menú.\n\n\n\n\n\n\n\nFigura 1.7: Cuando abre un R Script (File &gt; New File &gt; R Script in the menu bar), RStudio crea un cuarto panel encima de la consola donde puede escribir y editar su código\n\n\n\n\nRStudio viene con muchas funciones integradas que facilitan el trabajo con scripts. Primero, puede ejecutar automáticamente una línea de código en un script haciendo clic en el botón Run, como se muestra en la Figura Figura 1.8.\nR ejecutará cualquier línea de código en la que esté el cursor. Si tiene una sección completa resaltada, R ejecutará el código resaltado. Como alternativa, puede ejecutar todo el script haciendo clic en el botón Source. ¿No te gusta hacer clic en los botones? Puede usar Control + Enter como acceso directo para el botón Ejecutar. En Mac, eso sería Comando + Enter.\n\n\n\n\n\n\n\nFigura 1.8: Puede ejecutar una parte resaltada del código en su secuencia de comandos si hace clic en el botón Run en la parte superior del panel de Scripts. Puede ejecutar todo el script haciendo clic en el botón Source.\n\n\n\n\nSi no está convencido acerca de los scripts, pronto lo estará. Se convierte en una molestia escribir código de varias líneas en la línea de comando de una sola línea de la consola. Evitemos ese dolor de cabeza y abramos su primer script ahora antes de pasar al siguiente capítulo.\n\n\n\n\n\n\nExtraer función\nRStudio viene con una herramienta que puede ayudarlo a crear funciones. Para usarlo, resalte las líneas de código en su secuencia de comandos R que desea convertir en una función. Luego haga clic en Code &gt; Extract Function en la barra de menú. RStudio le pedirá un nombre de función para usar y luego envolverá su código en una llamada de function. Escaneará el código en busca de variables indefinidas y las usará como argumentos.\nEs posible que desee volver a comprobar el trabajo de RStudio. Asume que su código es correcto, por lo que si hace algo sorprendente, es posible que tenga un problema en su código.",
    "crumbs": [
      "Proyecto 1: Dados Ponderados",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Lo Más Básico</span>"
    ]
  },
  {
    "objectID": "basics.html#resumen",
    "href": "basics.html#resumen",
    "title": "1  Lo Más Básico",
    "section": "\n1.7 Resumen",
    "text": "1.7 Resumen\nYa has cubierto mucho terreno. Ahora tiene un dado virtual almacenado en la memoria de su computadora, así como su propia función de R que lanza un par de dados. También ha comenzado a hablar el lenguaje R.\nComo has visto, R es un lenguaje que puedes usar para hablar con tu computadora. Escribes comandos en R y los ejecutas en la línea de comandos para que tu computadora los lea. Su computadora a veces responderá–por ejemplo, cuando cometa un error–pero generalmente solo hace lo que le pide y luego muestra el resultado.\nLos dos componentes más importantes del lenguaje R son los objetos, que almacenan datos, y las funciones, que manipulan datos. R también usa una gran cantidad de operadores como +, -, *, / y &lt;- para realizar tareas básicas. Como científico de datos, usará objetos de R para almacenar datos en la memoria de su computadora y usará funciones para automatizar tareas y realizar cálculos complicados. Examinaremos los objetos con más profundidad más adelante en Proyecto 2: Baraja de Cartas y profundizaremos en las funciones en Proyecto 3: Máquina Tragamonedas. El vocabulario que ha desarrollado aquí hará que cada uno de esos proyectos sea más fácil de entender. Sin embargo, aún no hemos terminado con tus dados.\nEn Paquetes y páginas de ayuda, , ejecutará algunas simulaciones con sus dados y construirá sus primeros gráficos en R. También verá dos de los componentes más útiles del lenguaje R: Paquetes de R, que son colecciones de funciones escritas por la talentosa comunidad de desarrolladores de R, y documentación de R, que es una colección de páginas de ayuda integradas en R que explica cada función y conjunto de datos en el lenguaje.",
    "crumbs": [
      "Proyecto 1: Dados Ponderados",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Lo Más Básico</span>"
    ]
  },
  {
    "objectID": "packages.html",
    "href": "packages.html",
    "title": "2  Paquetes y páginas de ayuda",
    "section": "",
    "text": "2.1 Paquetes\nAhora tiene una función que simula lanzar un par de dados. Hagamos las cosas un poco más interesantes ponderando los dados a tu favor. La casa siempre gana, ¿verdad? Hagamos que los dados arrojen números altos un poco más a menudo que los números bajos.\nAntes de ponderar los dados, debemos asegurarnos de que sean justos para empezar. Dos herramientas te ayudarán a hacer esto: repetición y visualización. Por coincidencia, estas herramientas también son dos de los superpoderes más útiles en el mundo de la ciencia de datos.\nRepetiremos nuestras tiradas de dados con una función llamada replicate y visualizaremos nuestras tiradas con una función llamada qplot. qplot no viene con R cuando lo descargas; qplot viene en un paquete de R independiente. Muchas de las herramientas de R más útiles vienen en paquetes de R, así que tomemos un momento para ver qué son los paquetes de R y cómo puede usarlos.\nNo es la única persona que escribe sus propias funciones con R. Muchos profesores, programadores y estadísticos usan R para diseñar herramientas que pueden ayudar a las personas a analizar datos. Luego hacen que estas herramientas sean gratuitas para que cualquiera las use. Para usar estas herramientas, solo tienes que descargarlas. Vienen como colecciones preensambladas de funciones y objetos llamados paquetes. Apéndice 2: Paquetes de R contiene instrucciones detalladas para descargar y actualizar paquetes R, pero aquí veremos los conceptos básicos.\nVamos a usar la función qplot para hacer algunos gráficos rápidos. qplot viene en el paquete ggplot2, un paquete popular para hacer gráficos. Antes de que pueda usar qplot, o cualquier otra cosa en el paquete ggplot2, debe descargarlo e instalarlo.",
    "crumbs": [
      "Proyecto 1: Dados Ponderados",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Paquetes y páginas de ayuda</span>"
    ]
  },
  {
    "objectID": "packages.html#paquetes",
    "href": "packages.html#paquetes",
    "title": "2  Paquetes y páginas de ayuda",
    "section": "",
    "text": "2.1.1 install.packages\nCada paquete R está alojado en http://cran.r-project.org, el mismo sitio web que aloja R. Sin embargo, no necesita visitar el sitio web para descargar un paquete R; puede descargar paquetes directamente desde la línea de comandos de R. Así es cómo:\n\nAbre RStudio.\nAsegúrate de estar conectado a Internet.\nEjecute install.packages(\"ggplot2\") en la línea de comando.\n\nEso es. R hará que su computadora visite el sitio web, descargue ggplot2 e instale el paquete en su disco duro justo donde R quiere encontrarlo. Ahora tiene el paquete ggplot2. Si desea instalar otro paquete, reemplace ggplot2 con el nombre de su paquete en el código.\n\n2.1.2 library\nLa instalación de un paquete no pone sus funciones al alcance de su mano todavía: simplemente las coloca en su disco duro. Para usar un paquete de R, luego debe cargarlo en su sesión de R con el comando library(\"ggplot2\"). Si desea cargar un paquete diferente, reemplace ggplot2 con el nombre de su paquete en el código.\nPara ver lo que esto hace, intente un experimento. Primero, pide a R que te muestre la función qplot. R no podrá encontrar qplot porque qplot vive en el paquete ggplot2, que no ha cargado:\nqplot\n## Error: object 'qplot' not found\nAhora cargue el paquete ggplot2:\nlibrary(\"ggplot2\")\nSi instaló el paquete con install.packages según las instrucciones, todo debería ir bien. No se preocupe si no ve ningún resultado o mensaje. No tener noticias es una buena noticia a la hora de cargar un paquete. No se preocupe si ve un mensaje tampoco; ggplot2 a veces muestra mensajes de inicio útiles. Mientras no vea nada que diga “Error”, lo está haciendo bien.\nAhora, si pide ver qplot, R le mostrará bastante código (qplot es una función larga):\nqplot\n## (quite a bit of code)\nApéndice 2: Paquetes de R contiene muchos más detalles sobre la adquisición y el uso de paquetes. Le recomiendo que lo lea si no está familiarizado con el sistema de paquetes de R. Lo más importante que debe recordar es que solo necesita instalar un paquete una vez, pero debe cargarlo con library cada vez que desee usarlo en una nueva sesión de R. R descargará todos sus paquetes cada vez que cierre RStudio.\nAhora que ha cargado qplot, vamos a probarlo. qplot hace “gráficos rápidos”. Si le das a qplot dos vectores de igual longitud, qplot dibujará un diagrama de dispersión por ti. qplot usará el primer vector como un conjunto de valores x y el segundo vector como un conjunto de valores y. Busque el gráfico que aparecerá en la pestaña Gráficos del panel inferior derecho de la ventana de RStudio.\nEl siguiente código creará el gráfico que aparece en la Figura Figura 2.1. Hasta ahora, hemos estado creando secuencias de números con el operador :; pero también puedes crear vectores de números con la función c. Proporcione a c todos los números que desea que aparezcan en el vector, separados por una coma. c significa concatenar, pero puedes pensar en ello como “recolectar” o “combinar”:\nx &lt;- c(-1, -0.8, -0.6, -0.4, -0.2, 0, 0.2, 0.4, 0.6, 0.8, 1)\nx\n## -1.0 -0.8 -0.6 -0.4 -0.2  0.0  0.2  0.4  0.6  0.8  1.0\n\ny &lt;- x^3\ny\n## -1.000 -0.512 -0.216 -0.064 -0.008  0.000  0.008\n##  0.064  0.216  0.512  1.000\n\nqplot(x, y)\n\n\n\n\n\n\n\nFigura 2.1: qplot hace un diagrama de dispersión cuando le das dos vectores.\n\n\n\n\nNo necesitas nombrar tus vectores x e y. Solo hice eso para aclarar el ejemplo. Como puede ver en la figura Figura 2.1, un diagrama de dispersión es un conjunto de puntos, cada uno representado de acuerdo con sus valores x e y. Juntos, los vectores x e y describen un conjunto de 10 puntos. ¿Cómo hizo coincidir R los valores en x e y para hacer estos puntos? Con ejecución por elementos, como vimos en la Figura Figura 1.3.\nLos diagramas de dispersión son útiles para visualizar la relación entre dos variables. Sin embargo, vamos a utilizar un tipo diferente de gráfico, un histograma. Un histograma visualiza la distribución de una sola variable; muestra cuántos puntos de datos aparecen en cada valor de x.\nEchemos un vistazo a un histograma para ver si esto tiene sentido. qplot hará un histograma cada vez que le des solo un vector para graficar. El siguiente código crea el gráfico de la izquierda en la Figura Figura 2.2 (nos preocuparemos del gráfico de la derecha en un segundo). Para asegurarse de que nuestros gráficos tengan el mismo aspecto, utilice el argumento extra binwidth = 1:\nx &lt;- c(1, 2, 2, 2, 3, 3)\nqplot(x, binwidth = 1)\n\n\n\n\n\n\n\nFigura 2.2: qplot hace un histograma cuando le das un solo vector.\n\n\n\n\nEste gráfico muestra que nuestro vector contiene un valor en el intervalo [1, 2) colocando una barra de altura 1 sobre ese intervalo. De manera similar, la gráfica muestra que el vector contiene tres valores en el intervalo [2, 3) colocando una barra de altura 3 en ese intervalo. Muestra que el vector contiene dos valores en el intervalo [3, 4) colocando una barra de altura 2 en ese intervalo. En estos intervalos, el corchete, [, significa que el primer número está incluido en el intervalo. El paréntesis, ), significa que el último número no está incluido.\nProbemos con otro histograma. Este código crea el gráfico de la derecha en la Figura Figura 2.2. Observe que hay cinco puntos con un valor de 1 en x2. El histograma muestra esto trazando una barra de altura 5 sobre el intervalo x2 = [1, 2):\nx2 &lt;- c(1, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 4)\nqplot(x2, binwidth = 1)\nEjercicio 3.1 (Visualizar un Histograma) Sea x3 el siguiente vector:\nx3 &lt;- c(0, 1, 1, 2, 2, 2, 3, 3, 4)\nImagina cómo se vería un histograma de x3. Suponga que el histograma tiene un ancho de intervalo de 1. ¿Cuántas barras tendrá el histograma? ¿Dónde aparecerán? ¿Qué altura tendrá cada uno?\nCuando haya terminado, trace un histograma de x3 con binwidth = 1, y vea si tiene razón.\nSolución. Puedes hacer un histograma de x3 con qplot(x3, binwidth = 1). El histograma se verá como una pirámide simétrica. La barra del medio tendrá una altura de 3 y aparecerá encima de [2, 3), pero asegúrese de probarlo y verlo por sí mismo.\nPuede usar un histograma para mostrar visualmente qué tan comunes son los diferentes valores de x. Los números cubiertos por una barra alta son más comunes que los números cubiertos por una barra corta.\n¿Cómo puedes usar un histograma para verificar la precisión de tus dados?\nBueno, si tiras los dados muchas veces y haces un seguimiento de los resultados, esperarás que algunos números ocurran más que otros. Esto se debe a que hay más formas de obtener algunos números sumando dos dados que de obtener otros números, como se muestra en la Figura Figura 2.3.\nSi tira los dados muchas veces y grafica los resultados con qplot, el histograma le mostrará con qué frecuencia apareció cada suma. Las sumas que ocurrieron con mayor frecuencia tendrán las barras más altas. El histograma debería parecerse al patrón de la Figura Figura 2.3 si los dados tienen un peso justo.\nAquí es donde entra replicate. replicate proporciona una manera fácil de repetir un comando de R muchas veces. Para usarlo, primero dale a replicate el número de veces que deseas repetir un comando de R, y luego dale el comando que deseas repetir. replicate ejecutará el comando varias veces y almacenará los resultados como un vector:\nreplicate(3, 1 + 1)\n## 2 2 2\n\nreplicate(10, tirar())\n## 3  7  5  3  6  2  3  8 11  7\n\n\n\n\n\n\n\nFigura 2.3: Cada combinación individual de dados debe ocurrir con la misma frecuencia. Como resultado, algunas sumas ocurrirán con más frecuencia que otras. Con dados justos, cada suma debe aparecer en proporción al número de combinaciones que la forman.\n\n\n\n\nUn histograma de sus las primeras 10 tiradas de los dados probablemente no se verá como el patrón que se muestra en la Figura Figura 2.3. ¿Por qué no? Hay demasiada aleatoriedad involucrada. Recuerda que usamos dados en la vida real porque son generadores efectivos de números aleatorios. Los patrones de frecuencias de largo plazo solo aparecerán en el largo plazo. Así que simulemos 10.000 lanzamientos de dados y representemos los resultados. No te preocupes; qplot y replicate pueden manejarlo. Los resultados aparecen en la Figura Figura 2.4:\nlanzamientos &lt;- replicate(10000, tirar())\nqplot(lanzamientos, binwidth = 1)\nLos resultados sugieren que los dados son justos. A la larga, cada número aparece en proporción al número de combinaciones que lo generan.\nAhora, ¿cómo puedes sesgar estos resultados? El patrón anterior ocurre porque cada combinación subyacente de dados (por ejemplo, (3,4)) ocurre con la misma frecuencia. Si pudieras aumentar la probabilidad de que salga un 6 en cualquiera de los dados, entonces cualquier combinación con un seis ocurrirá con más frecuencia que cualquier combinación sin un seis. La combinación (6, 6) ocurriría más frecuente que todas las demás. Esto no hará que los dados sumen 12 con más frecuencia que siete, pero sesgará los resultados hacia los números más altos\n\n\n\n\n\n\n\nFigura 2.4: El comportamiento de nuestros dados sugiere que son justos. Siete ocurre con más frecuencia que cualquier otro número, y las frecuencias disminuyen en proporción al número de combinaciones de dados que crean cada número.\n\n\n\n\nPara decirlo de otra manera, la probabilidad de sacar cualquier número en un dado justo es 1/6. Me gustaría que cambiara la probabilidad a 1/8 para cada número por debajo de seis y luego aumentara la probabilidad de sacar un seis a 3/8:\n\n\nNúmero\nProbabilidad justa\nProbabilidad sesgada\n\n\n\n1\n1/6\n1/8\n\n\n2\n1/6\n1/8\n\n\n3\n1/6\n1/8\n\n\n4\n1/6\n1/8\n\n\n5\n1/6\n1/8\n\n\n6\n1/6\n3/8\n\n\n\nPuede cambiar las probabilidades agregando un nuevo argumento a la función sample. No te voy a decir cuál es el argumento; en su lugar, le indicaré la página de ayuda para la función sample. ¿Que es eso? ¿Las funciones de R vienen con páginas de ayuda? Sí, así que aprendamos a leer una.",
    "crumbs": [
      "Proyecto 1: Dados Ponderados",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Paquetes y páginas de ayuda</span>"
    ]
  },
  {
    "objectID": "packages.html#obteniendo-ayuda-con-las-páginas-de-ayuda",
    "href": "packages.html#obteniendo-ayuda-con-las-páginas-de-ayuda",
    "title": "2  Paquetes y páginas de ayuda",
    "section": "\n2.2 Obteniendo Ayuda con las Páginas de Ayuda",
    "text": "2.2 Obteniendo Ayuda con las Páginas de Ayuda\nHay más de 1000 funciones en el núcleo de R, y se crean nuevas funciones todo el tiempo. ¡Esto puede ser mucho material para memorizar y aprender! Afortunadamente, cada función de R viene con su propia página de ayuda, a la que puede acceder escribiendo el nombre de la función después de un signo de interrogación. Por ejemplo, cada uno de estos comandos abrirá una página de ayuda. Busque las páginas que aparecerán en la pestaña Ayuda del panel inferior derecho de RStudio:\n?sqrt\n?log10\n?sample\nLas páginas de ayuda contienen información útil sobre lo que hace cada función. Estas páginas de ayuda también sirven como documentación del código, por lo que leerlas puede resultar agridulce. A menudo parecen estar escritas para personas que ya entienden la función y no necesitan ayuda.\nNo deje que esto le moleste: puede obtener mucho de una página de ayuda si la escanea buscando información que tenga sentido y pasa por alto el resto. Esta técnica inevitablemente lo llevará a la parte más útil de cada página de ayuda: la parte inferior. Aquí, casi todas las páginas de ayuda incluyen algún código de ejemplo que pone la función en acción. Ejecutar este código es una excelente manera de aprender con el ejemplo.\n\n\n\n\n\n\nSi una función viene en un paquete R, R no podrá encontrar su página de ayuda a menos que se cargue el paquete.\n\n\n\n\n2.2.1 Partes de una Página de Ayuda\nCada página de ayuda está dividida en secciones. Las secciones que aparecen pueden variar de una página de ayuda a otra, pero normalmente puede esperar encontrar estos temas útiles\nDescripción - Un breve resumen de lo que hace la función.\nUso - Un ejemplo de cómo escribiría la función. Cada argumento de la función aparecerá en el orden en que R espera que lo proporciones (si no usas nombres de argumentos).\nArgumentos - Una lista de cada argumento que toma la función, qué tipo de información R espera que proporcione para el argumento y qué hará la función con la información.\nDetalles - Una descripción más detallada de la función y cómo opera. La sección de detalles también le da al autor de la función la oportunidad de alertarlo sobre cualquier cosa que desee saber al usar la función.\nValor - Una descripción de lo que devuelve la función cuando la ejecuta.\nVea También - Una breve lista de funciones de R relacionadas.\nEjemplos - Código de ejemplo que usa la función y se garantiza que funcionará. La sección de ejemplos de una página de ayuda generalmente demuestra un par de formas diferentes de usar una función. Esto ayuda a darle una idea de lo que la función es capaz de hacer.\nSi desea buscar una función en la página de ayuda pero ha olvidado el nombre de la función, puede buscar por palabra clave. Para ello, escriba dos signos de interrogación seguidos de una palabra clave en la línea de comandos de R. R mostrará una lista de enlaces a páginas de ayuda relacionadas con la palabra clave. Puede pensar en esto como la página de ayuda para la página de ayuda:\n??log\nDemos un paseo por la página de ayuda de sample. Recuerde: estamos buscando cualquier cosa que pueda ayudarlo a cambiar las probabilidades involucradas en el proceso de muestreo. No voy a reproducir toda la página de ayuda aquí (solo las partes más jugosas), por lo que debe seguirla en su computadora.\nPrimero, abra la página de ayuda. Aparecerá en el mismo panel en RStudio que sus gráficos (pero en la pestaña Help, no en la pestaña Plots):\n?sample\n\n\n\n\n\n\nComo verá a continuación y en su panel Help de la ventana inferior derecha de RStudio las páginas de ayuda de R solo se encuentran en idioma inglés. Por lo que las secciones, de la página de ayuda de la función sample, que se exponen a continuación se mostrarán en inglés. Si no posee un nivel de inglés que le permita leer y entender las páginas de ayuda de R, el traductor le recomienda traducir las mismas usando algún traductor de documentos online, aunque estos pueden ser muy textuales en ocasiones.\n\n\n\n¿Que ves? Comenzando desde arriba:\n\nRandom Samples and Permutations\n\nDescription\n    sample takes a sample of the specified size from the elements of x using \neither with or without replacement.\nHasta ahora todo bien. Ya sabías todo eso. La siguiente sección, Uso, tiene una posible pista. Menciona un argumento llamado prob:\nUsage\n    sample(x, size, replace = FALSE, prob = NULL)\nSi se desplaza hacia abajo hasta la sección de argumentos, la descripción de +prob+ suena muy prometedora:\nA vector of probability weights for obtaining the elements of the vector being \nsampled.\nLa sección Detalles confirma nuestras sospechas. En este caso, también te indica cómo proceder:\nThe optional prob argument can be used to give a vector of weights for obtaining \nthe elements of the vector being sampled. They need not sum to one, but they \nshould be nonnegative and not all zero.\nAunque la página de ayuda no lo dice aquí, estos pesos se emparejarán de manera individual con los elementos que se muestrean.El primer peso describirá el primer elemento, el segundo peso el segundo elemento, y así sucesivamente. Esta es una práctica común en R.\nLeer:\nIf replace is true, Walker's alias method (Ripley, 1987) is used...\nVale, parece que es hora de empezar a hojear. Deberíamos tener suficiente información ahora para descubrir cómo manipular nuestros dados.\nEjercicio 3.2 (Lanzar un par de Dados) Vuelva a escribir la función tirar a continuación para lanzar un par de dados ponderados:\ntirar &lt;- function() {\n  dado &lt;- 1:6\n  dados &lt;- sample(dado, size = 2, replace = TRUE)\n  sum(dados)\n}\nDeberá agregar un argumento prob a la función sample dentro de tirar. Este argumento debería decirle a sample que muestree los números del uno al cinco con una probabilidad de 1/8 y el número 6 con una probabilidad de 3/8.\nCuando haya terminado, siga leyendo para ver un ejemplo de respuesta.\nSolución. Para ponderar sus dados, debe agregar un argumento prob con un vector de pesos a sample, como este:\ntirar &lt;- function() {\n  dado &lt;- 1:6\n  dados &lt;- sample(dado, size = 2, replace = TRUE, \n    prob = c(1/8, 1/8, 1/8, 1/8, 1/8, 3/8))\n  sum(dados)\n}\nEsto hará que tirar elija del 1 al 5 con una probabilidad de 1/8 y 6 con una probabilidad de 3/8.\nSobrescriba su versión anterior de tirar con la nueva función (ejecutando el fragmento de código anterior en su línea de comando). Luego visualiza el nuevo comportamiento a largo plazo de tus dados. He puesto los resultados en la Figura Figura 2.5 junto a nuestros resultados originales:\nlanzamientos &lt;- replicate(10000, tirar())\nqplot(lanzamientos, binwidth = 1)\nEsto confirma que efectivamente hemos ponderado los dados. Los números altos ocurren con mucha más frecuencia que los números bajos. Lo notable es que este comportamiento solo será evidente cuando examine las frecuencias a largo plazo. En cualquier tirada individual, los dados parecerán comportarse aleatoriamente. Esta es una gran noticia si juegas a Settlers of Catan (solo dile a tus amigos que perdiste los dados), pero debería ser perturbador si analizas los datos, porque significa que el sesgo puede ocurrir fácilmente sin que nadie lo note a corto plazo.\n\n\n\n\n\n\n\nFigura 2.5: Los dados ahora están claramente sesgados hacia números altos, ya que las sumas altas ocurren con mucha más frecuencia que las sumas bajas.\n\n\n\n\n\n2.2.2 Obteniendo Más Ayuda\nR también viene con una comunidad súper activa de usuarios a la que puede acudir para obtener ayuda en la lista de correo de R-help. Puede enviar un correo electrónico a la lista con preguntas, pero existe una gran posibilidad de que su pregunta ya haya sido respondida. Descúbrelo buscando en los archivos.\nIncluso mejor que la lista R-help es Stack Overflow, un sitio web que permite a los programadores responder preguntas y a los usuarios clasificar las respuestas según su utilidad. Personalmente, creo que el formato Stack Overflow es más fácil de usar que la lista de correo electrónico R-help (y los encuestados son más amigables con los humanos). Puede enviar su propia pregunta o buscar a través de las preguntas respondidas anteriormente de Stack Overflow relacionadas con R. Hay más de 30,000.\nLo mejor de todo es Posit Community, un lugar amigable e inclusivo para compartir preguntas relacionadas con R. Posit Community es un foro muy activo centrado en R. No se sorprenda si hace una pregunta sobre un paquete de R y el autor del paquete aparece para dar respuesta.\nPara toda la lista de ayuda de R, Stack Overflow y Posit Community, es más probable que obtenga una respuesta útil si proporciona un ejemplo reproducible con su pregunta. Esto significa pegar un pequeño fragmento de código que los usuarios pueden ejecutar para llegar al error o pregunta que tiene en mente.",
    "crumbs": [
      "Proyecto 1: Dados Ponderados",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Paquetes y páginas de ayuda</span>"
    ]
  },
  {
    "objectID": "packages.html#resumen",
    "href": "packages.html#resumen",
    "title": "2  Paquetes y páginas de ayuda",
    "section": "\n2.3 Resumen",
    "text": "2.3 Resumen\nLos paquetes y las páginas de ayuda de R pueden convertirlo en un programador más productivo. Viste en Lo Más Básico que R te da el poder de escribir tus propias funciones que hacen cosas específicas, pero a menudo la función que deseas escribir ya existirá en un paquete de R. Profesores, programadores y científicos han desarrollado más de 13.000 paquetes para su uso, lo que puede ahorrarle un valioso tiempo de programación. Para usar un paquete, debe instalarlo en su computadora una vez con install.packages y luego cargarlo en cada nueva sesión de R con library.\nLas páginas de ayuda de R lo ayudarán a dominar las funciones que aparecen en R y sus paquetes. Cada función y conjunto de datos en R tiene su propia página de ayuda. Aunque las páginas de ayuda a menudo contienen contenido avanzado, también contienen pistas y ejemplos valiosos que pueden ayudarlo a aprender a usar una función.\nYa ha visto suficiente de R para aprender haciendo, que es la mejor manera de aprender R. Puede crear sus propios comandos de R, ejecutarlos y obtener ayuda cuando necesite comprender algo que no he explicado. Lo animo a que experimente con sus propias ideas en R mientras lee los próximos dos proyectos.",
    "crumbs": [
      "Proyecto 1: Dados Ponderados",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Paquetes y páginas de ayuda</span>"
    ]
  },
  {
    "objectID": "packages.html#resumen-del-proyecto-1",
    "href": "packages.html#resumen-del-proyecto-1",
    "title": "2  Paquetes y páginas de ayuda",
    "section": "\n2.4 Resumen del Proyecto 1",
    "text": "2.4 Resumen del Proyecto 1\nHas hecho más en este proyecto que permitir el fraude y las apuestas; también aprendió a hablarle a su computadora en el idioma de R. R es un idioma como inglés, español o alemán, excepto que R lo ayuda a hablar con computadoras, no con humanos.\nHas conocido los sustantivos del lenguaje R, objetos. Y espero que hayas adivinado que las funciones son los verbos (supongo que los argumentos de función serían los adverbios). Cuando combinas funciones y objetos, expresas un pensamiento completo. Al unir pensamientos en una secuencia lógica, puede construir declaraciones elocuentes e incluso artísticas. En ese sentido, R no es tan diferente de cualquier otro idioma.\nR comparte otra característica de los lenguajes humanos: no te sentirás muy cómodo hablando R hasta que construyas un vocabulario de comandos de R para usar. Afortunadamente, no tienes que ser tímido. Tu computadora será la única que “escuchará” “hablando” R. Tu computadora no es muy indulgente, pero tampoco juzga. No es que tengas que preocuparte; ampliará enormemente su vocabulario de R entre aquí y el final del libro.\nAhora que puede usar R, es hora de convertirse en un experto en el uso de R para hacer ciencia de datos. La base de la ciencia de datos es la capacidad de almacenar grandes cantidades de datos y recuperar valores a pedido. A partir de esto, sigue todo lo demás: manipulación de datos, visualización de datos, modelado de datos y más. Sin embargo, no puede almacenar fácilmente un conjunto de datos en su mente al memorizarlo. Tampoco puede almacenar fácilmente un conjunto de datos en papel escribiéndolo. La única forma eficiente de almacenar grandes cantidades de datos es con una computadora. De hecho, las computadoras son tan eficientes que su desarrollo en las últimas tres décadas ha cambiado por completo el tipo de datos que podemos acumular y los métodos que podemos usar para analizarlos. En resumen, el almacenamiento de datos informáticos ha impulsado la revolución en la ciencia que llamamos ciencia de datos.\nProyecto 2: Baraja de Cartas lo hará parte de esta revolución enseñándole cómo usar R para almacenar conjuntos de datos en la memoria de su computadora y cómo recuperar y manipular datos una vez que están allí.",
    "crumbs": [
      "Proyecto 1: Dados Ponderados",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Paquetes y páginas de ayuda</span>"
    ]
  },
  {
    "objectID": "cards.html",
    "href": "cards.html",
    "title": "Proyecto 2: Baraja de Cartas",
    "section": "",
    "text": "Este proyecto, que abarca los siguientes cuatro capítulos, le enseñará cómo almacenar, recuperar y cambiar valores de datos en la memoria de su computadora. Estas habilidades lo ayudarán a guardar y administrar datos sin acumular errores. En el proyecto, diseñará una baraja de cartas que pueda barajar y repartir. Lo mejor de todo es que la baraja recordará qué cartas se han repartido, como una baraja real. Puede usar el mazo para jugar juegos de cartas, adivinar fortunas y probar estrategias de conteo de cartas.\nEn el camino, aprenderá cómo:\n\nGuardar nuevos tipos de datos, como cadenas de caracteres y valores lógicos\nGuardar un conjunto de datos como vector, matriz, arreglo, lista o data frame\nCargar y guardar sus propios conjuntos de datos con R\nExtraer valores individuales de un conjunto de datos\nCambiar valores individuales dentro de un conjunto de datos\nEscribir pruebas lógicas\nUsar el símbolo de valor faltante de R, NA\n\nPara simplificar el proyecto, lo he dividido en cuatro tareas. Cada tarea le enseñará una nueva habilidad para administrar datos con R:\nTask 1: Construir la baraja\nEn Objetos de R, diseñarás y construirás una baraja virtual de naipes. Este será un conjunto de datos completo, como los que usará como científico de datos. Necesitará saber cómo usar los tipos de datos y las estructuras de datos de R para que esto funcione.\nTask 2: Construir funciones para repartir y barajar A continuación, en Notación de R, escribirá dos funciones para usar con la baraja. Una función repartirá cartas de la baraja y la otra volverá a barajar la baraja. Para escribir estas funciones, necesitará saber cómo extraer valores de un conjunto de datos con R.\nTarea 3: Cambiar el sistema de puntos para adaptarlo a tu juego\nEn Modificación de valores, utilizará el sistema de notación de R para cambiar los valores de puntos de sus cartas para que coincidan con los juegos de cartas que desee jugar, como guerra, corazones o blackjack. Esto le ayudará a cambiar los valores existentes en los conjuntos de datos existentes.\nTarea 4: Gestionar el estado de la baraja Finalmente, en Entornos, te asegurarás de que tu mazo recuerde qué cartas ha repartido. Esta es una tarea avanzada y presentará el sistema de entorno de R y las reglas de alcance. Para hacerlo con éxito, deberá aprender los detalles minuciosos de cómo R busca y usa los datos que ha almacenado en su computadora.",
    "crumbs": [
      "Proyecto 2: Baraja de Cartas"
    ]
  },
  {
    "objectID": "objects.html",
    "href": "objects.html",
    "title": "3  Objectos de R",
    "section": "",
    "text": "3.1 Vectores Atómicos\nEn este capítulo, usará R para armar una baraja de 52 cartas.\nComenzará construyendo objetos R simples que representan naipes y luego avanzará hasta una tabla de datos completa. En resumen, creará el equivalente a una hoja de cálculo de Excel desde cero. Cuando hayas terminado, tu mazo de cartas se verá así:\n¿Necesita crear un conjunto de datos desde cero para usarlo en R? Para nada. Puede cargar la mayoría de los conjuntos de datos en R con un simple paso, consulte Cargar datos. Pero este ejercicio le enseñará cómo R almacena datos y cómo puede ensamblar, o desensamblar, sus propios conjuntos de datos. También aprenderá sobre los diversos tipos de objetos disponibles para usar en R (¡no todos los objetos de R son iguales!). Considere este ejercicio como un rito de iniciación; al hacerlo, se convertirá en un experto en el almacenamiento de datos en R.\nComenzaremos con lo más básico. El tipo de objeto más simple en R es un vector atómico. Los vectores atómicos no tienen energía nuclear, pero son muy simples y aparecen en todas partes. Si observa lo suficientemente de cerca, verá que la mayoría de las estructuras en R se construyen a partir de vectores atómicos.\nUn vector atómico es solo un simple vector de datos. De hecho, ya ha creado un vector atómico, su objeto dado del Proyecto 1: Dados Ponderados. Puede hacer un vector atómico agrupando algunos valores de datos con c:\nTambién puedes hacer un vector atómico con un solo valor. R guarda valores individuales como un vector atómico de longitud 1:\nCada vector atómico almacena sus valores como un vector unidimensional y cada vector atómico solo puede almacenar un tipo de datos. Puede guardar diferentes tipos de datos en R utilizando diferentes tipos de vectores atómicos. En total, R reconoce seis tipos básicos de vectores atómicos: dobles, enteros, caracteres, lógicos, complejos y sin procesar.\nPara crear su mazo de cartas, necesitará usar diferentes tipos de vectores atómicos para guardar diferentes tipos de información (texto y números). Puede hacer esto usando algunas convenciones simples cuando ingresa sus datos. Por ejemplo, puede crear un vector de números enteros al incluir una L mayúscula con su entrada. Puede crear un vector de caracteres encerrando su entrada entre comillas:\nCada tipo de vector atómico tiene su propia convención (descrita a continuación). R reconocerá la convención y la usará para crear un vector atómico del tipo apropiado. Si desea crear vectores atómicos que tengan más de un elemento, puede combinar un elemento con la función c de Paquetes y Páginas de ayuda. Use la misma convención con cada elemento:\nQuizás se pregunte por qué R usa múltiples tipos de vectores. Los tipos de vectores ayudan a que R se comporte como cabría esperar. Por ejemplo, R hará operaciones matemáticas con vectores atómicos que contienen números, pero no con vectores atómicos que contienen cadenas de caracteres:\n¡Pero nos estamos adelantando! Prepárese para saludar a los seis tipos de vectores atómicos en R.",
    "crumbs": [
      "Proyecto 2: Baraja de Cartas",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Objectos de R</span>"
    ]
  },
  {
    "objectID": "objects.html#vectores-atómicos",
    "href": "objects.html#vectores-atómicos",
    "title": "3  Objectos de R",
    "section": "",
    "text": "dado &lt;- c(1, 2, 3, 4, 5, 6)\ndado\n## 1 2 3 4 5 6\n\nis.vector(dado)\n##  TRUE\n\n\n\n\n\n\nis.vector\nis.vector comprueba si un objeto es un vector atómico. Devuelve TRUE si el objeto es un vector atómico y FALSE en caso contrario.\n\n\n\n\ncinco &lt;- 5\ncinco\n## 5\n\nis.vector(cinco)\n##  TRUE\n\nlength(cinco)\n## 1\nlength(dado)\n## 6\n\n\n\n\n\n\nlength\nlength devuelve la longitud de un vector atómico.\n\n\n\n\n\nent &lt;- 1L\ntext &lt;- \"as\"\n\nent &lt;- c(1L, 5L)\ntext &lt;- c(\"as\", \"corazon\")\n\nsum(ent)\n## 6\n\nsum(text)\n## Error in sum(text) : invalid 'type' (character) of argument\n\n\n3.1.1 Dobles\nUn vector doble almacena números regulares. Los números pueden ser positivos o negativos, grandes o pequeños, y tener dígitos a la derecha del lugar decimal o no. En general, R guardará cualquier número que escriba en R como un doble. Entonces, por ejemplo, el dado que hiciste en Proyecto 1: Dados Ponderados era un objeto doble:\ndado &lt;- c(1, 2, 3, 4, 5, 6)\ndado\n## 1 2 3 4 5 6\nPor lo general, sabrá con qué tipo de objeto está trabajando en R (será obvio), pero también puede preguntarle a R qué tipo de objeto es un objeto con typeof. Por ejemplo:\ntypeof(dado)\n##  \"double\"\nAlgunas funciones de R se refieren a los dobles como “numéricos”, y yo haré lo mismo con frecuencia. Doble es un término informático. Se refiere a la cantidad específica de bytes que usa su computadora para almacenar un número, pero encuentro que “numérico” es mucho más intuitivo cuando se hace ciencia de datos.\n\n3.1.2 Enteros\nLos vectores enteros almacenan números enteros, números que se pueden escribir sin un componente decimal. Como científico de datos, no usará el tipo de número entero con mucha frecuencia porque puede guardar los números enteros como un objeto doble.\nPuede crear específicamente un número entero en R escribiendo un número seguido de una L mayúscula. Por ejemplo:\nent &lt;- c(-1L, 2L, 4L)\nent\n## -1  2  4\n\ntypeof(ent)\n## \"integer\"\nTenga en cuenta que R no guardará un número como un entero a menos que incluya L. Los números enteros sin la L se guardarán como dobles. La única diferencia entre 4 y 4L es cómo R guarda el número en la memoria de tu computadora. Los números enteros se definen con mayor precisión en la memoria de su computadora que los dobles (a menos que el número entero sea muy grande o pequeño).\n¿Por qué guardaría sus datos como un número entero en lugar de un doble? A veces, una diferencia en la precisión puede tener efectos sorprendentes. Su computadora asigna 64 bits de memoria para almacenar cada doble en un programa de R. Esto permite mucha precisión, pero algunos números no se pueden expresar exactamente en 64 bits, el equivalente a una secuencia de 64 unos y ceros. Por ejemplo, el número \\(\\pi\\) contiene una secuencia interminable de dígitos a la derecha del lugar decimal. Su computadora debe redondear \\(\\pi\\) a algo cercano, pero no exactamente igual a \\(\\pi\\) para almacenar \\(\\pi\\) en su memoria. Muchos números decimales comparten esta característica.\nComo resultado, cada doble tiene una precisión de unos 16 dígitos significativos. Esto introduce un pequeño error. En la mayoría de los casos, este error de redondeo pasará desapercibido. Sin embargo, en algunas situaciones, el error de redondeo puede causar resultados sorprendentes. Por ejemplo, puede esperar que el resultado de la siguiente expresión sea cero, pero no lo es:\nsqrt(2)^2 - 2\n## 4.440892e-16\nLa raíz cuadrada de dos no se puede expresar exactamente en 16 dígitos significativos. Como resultado, R tiene que redondear la cantidad y la expresión se resuelve en algo muy cercano a cero, pero no del todo.\nEstos errores se conocen como errores de punto flotante, y hacer aritmética en estas condiciones se conoce como aritmética de punto flotante. La aritmética de punto flotante no es una característica de R; es una característica de la programación de computadoras. Por lo general, los errores de punto flotante no serán suficientes para arruinar su día. Solo tenga en cuenta que pueden ser la causa de resultados sorprendentes.\nPuede evitar errores de punto flotante si evita los decimales y solo usa números enteros. Sin embargo, esta no es una opción en la mayoría de las situaciones de ciencia de datos. No puedes hacer muchas matemáticas con números enteros antes de que necesites un número no entero para expresar el resultado. Afortunadamente, los errores causados por la aritmética de punto flotante suelen ser insignificantes (y cuando no lo son, son fáciles de detectar). Como resultado, generalmente usará dobles en lugar de números enteros como científico de datos.\n\n3.1.3 Caracteres\nUn vector de caracteres almacena pequeños fragmentos de texto. Puede crear un vector de caracteres en R escribiendo un carácter o una cadena de caracteres entre comillas:\ntext &lt;- c(\"Hola\",  \"Mundo\")\ntext\n##  \"Hola\"  \"Mundo\"\n\ntypeof(text)\n## \"character\"\n\ntypeof(\"Hola\")\n## \"character\"\nLos elementos individuales de un vector de caracteres se conocen como cadenas. Tenga en cuenta que una cadena puede contener más que solo letras. También puede ensamblar una cadena de caracteres a partir de números o símbolos.\nEjercicio 5.1 (Carácter or Número) ¿Puedes encontrar la diferencia entre una cadena de caracteres y un número? Aquí hay una prueba: ¿Cuáles de estos son cadenas de caracteres y cuáles son números? 1, \"1\", \"uno\".\nSolución. \"1\" y \"uno\" son ambos cadenas de caracteres.\nLas cadenas de caracteres pueden contener caracteres numéricos, pero eso no los convierte en numéricos. Son solo cadenas que tienen números en ellas. Puede distinguir cadenas de números reales porque las cadenas vienen entre comillas. De hecho, todo lo que esté entre comillas en R se tratará como una cadena de caracteres, independientemente de lo que aparezca entre las comillas.\nEs fácil confundir objetos de R con cadenas de caracteres. ¿Por qué? Porque ambos aparecen como fragmentos de texto en código de R. Por ejemplo, x es el nombre de un objeto R llamado “x”, \"x\" es una cadena de caracteres que contiene el carácter “x”. Uno es un objeto que contiene datos sin procesar, el otro es un fragmento de datos sin procesar en sí mismo.\nEspere un error cada vez que olvide sus comillas; R comenzará a buscar un objeto que probablemente no exista.\n\n3.1.4 Lógicos\nLos vectores lógicos almacenan TRUE y FALSE, la forma de R de datos booleanos. Los lógicos son muy útiles para hacer cosas como comparaciones:\n3 &gt; 4\n## FALSE\nCada vez que escriba TRUE o FALSE en letras mayúsculas (sin comillas), R tratará su entrada como datos lógicos. R también asume que T y F son abreviaturas de TRUE y FALSE, a menos que se definan en otra parte (por ejemplo, ‘T &lt;- 500’). Dado que el significado de T y F puede cambiar, es mejor quedarse con TRUE y FALSE:\nlogico &lt;- c(TRUE, FALSE, TRUE)\nlogico\n##   TRUE FALSE  TRUE\n\ntypeof(logico)\n## \"logical\"\n\ntypeof(F)\n## \"logical\"\n\n3.1.5 Complejo y Sin Procesar\nDobles, enteros, caracteres y lógicos son los tipos más comunes de vectores atómicos en R, pero R también reconoce dos tipos más: complejos y sin procesar. Es dudoso que alguna vez los use para analizar datos, pero aquí están por el bien de la minuciosidad.\nLos vectores complejos almacenan números complejos. Para crear un vector complejo, agregue un término imaginario a un número con i:\ncomp &lt;- c(1 + 1i, 1 + 2i, 1 + 3i)\ncomp\n## 1+1i 1+2i 1+3i\n\ntypeof(comp)\n## \"complex\"\nLos vectores sin procesar almacenan bytes de datos sin procesar. Hacer vectores sin procesar se vuelve complicado, pero puedes hacer un vector sin procesar vacío de longitud n con raw(n). Consulte la página de ayuda de raw para obtener más opciones al trabajar con este tipo de datos:\nraw(3)\n## 00 00 00\n\ntypeof(raw(3))\n## \"raw\"\nEjercicio 5.2 (Vector de Cartas) Cree un vector atómico que almacene solo los nombres de las caras de las cartas en una escalera real, por ejemplo, el as de picas, el rey de picas, la reina de picas, la jota de picas y el diez de picas. El nombre de la cara del as de picas sería “as” y “picas” es el palo.\n¿Qué tipo de vector usarás para guardar los nombres?\nSolución. Un vector de caracteres es el tipo de vector atómico más apropiado para guardar los nombres de las cartas. Puedes crear uno con la función c si pones cada nombre entre comillas:\nmano &lt;- c(\"as\", \"rey\", \"reina\", \"jota\", \"diez\")\nmano\n## \"as\"   \"rey\"  \"reina\" \"jota\"  \"diez\"  \n\ntypeof(mano)\n## \"character\"\nEsto crea un grupo unidimensional de nombres de cartas. ¡Excelente trabajo! Ahora hagamos una estructura de datos más sofisticada, una tabla bidimensional de nombres de cartas y palos. Puede construir un objeto más sofisticado a partir de un vector atómico dándole algunos atributos y asignándole una clase.",
    "crumbs": [
      "Proyecto 2: Baraja de Cartas",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Objectos de R</span>"
    ]
  },
  {
    "objectID": "objects.html#attributes",
    "href": "objects.html#attributes",
    "title": "3  Objectos de R",
    "section": "\n3.2 Atributos",
    "text": "3.2 Atributos\nUn atributo es una pieza de información que puede adjuntar a un vector atómico (o cualquier objeto de R). El atributo no afectará ninguno de los valores del objeto y no aparecerá cuando muestre su objeto. Puede pensar en un atributo como “metadatos”; es solo un lugar conveniente para colocar información asociada con un objeto. R normalmente ignorará estos metadatos, pero algunas funciones de R verificarán atributos específicos. Estas funciones pueden usar los atributos para hacer cosas especiales con los datos.\nPuedes ver qué atributos tiene un objeto con attributes. attributes devolverá NULL si un objeto no tiene atributos. Un vector atómico, como dado, no tendrá ningún atributo a menos que le des alguno:\nattributes(dado)\n## NULL\n\n\n\n\n\n\nNULL\nR usa NULL para representar el conjunto nulo, un objeto vacío. NULL a menudo es devuelto por funciones cuyos valores no están definidos. Puede crear un objeto NULL escribiendo NULL en letras mayúsculas.\n\n\n\n\n3.2.1 Nombres\nLos atributos más comunes para dar un vector atómico son nombres, dimensiones (dim) y clases. Cada uno de estos atributos tiene su propia función auxiliar que puede usar para otorgar atributos a un objeto. También puede usar las funciones auxiliares para buscar el valor de estos atributos para los objetos que ya los tienen. Por ejemplo, puedes buscar el valor del atributo de nombres de dado con names:\nnames(dado)\n## NULL\nNULL significa que dado no tiene un atributo de nombres. Puedes darle uno a dado asignando un vector de caracteres a la salida de names. El vector debe incluir un nombre para cada elemento en dado:\nnames(dado) &lt;- c(\"uno\", \"dos\", \"tres\", \"cuatro\", \"cinco\", \"seis\")\nAhora dado tiene el atributo nombres:\nnames(dado)\n## \"uno\"   \"dos\"   \"tres\" \"cuatro\"  \"cinco\"  \"seis\" \n\nattributes(dado)\n## $names\n## [1] \"uno\"   \"dos\"   \"tres\" \"cuatro\"  \"cinco\"  \"seis\"\nR mostrará los nombres sobre los elementos de dado cada vez que mires el vector:\ndado\n##  uno   dos  tres  cuatro  cinco   seis \n##    1     2     3       4      5      6  \nSin embargo, los nombres no afectarán los valores reales del vector, ni los nombres se verán afectados cuando manipule los valores del vector:\ndado + 1\n##  uno   dos  tres  cuatro  cinco   seis \n##    2     3     4       5      6      7\nTambién puede usar names para cambiar el atributo de nombres o eliminarlo todo junto. Para cambiar los nombres, asigna un nuevo conjunto de etiquetas a names:\nnames(dado) &lt;- c(\"one\", \"two\", \"three\", \"four\", \"five\", \"six\")\ndado\n##   one    two   three four  five   six \n##     1      2       3    4     5     6 \nPara eliminar el atributo de nombres, configúrelo en NULL:\nnames(dado) &lt;- NULL\ndado\n##  1 2 3 4 5 6\n\n3.2.2 Dimensiones\nPuede transformar un vector atómico en una matriz n-dimensional dándole un atributo de dimensiones con dim. Para hacer esto, establezca el atributo dim en un vector numérico de longitud n. R reorganizará los elementos del vector en n dimensiones. Cada dimensión tendrá tantas filas (o columnas, etc.) como el valor n del vector dim. Por ejemplo, puede reorganizar dado en una matriz de 2 × 3 (que tiene 2 filas y 3 columnas):\ndim(dado) &lt;- c(2, 3)\ndado\n##      [,1] [,2] [,3]\n## [1,]    1    3    5\n## [2,]    2    4    6\no en una mariz de 3 × 2 (que tiene 3 filas y 2 columnas):\ndim(dado) &lt;- c(3, 2)\ndado\n##      [,1] [,2]\n## [1,]    1    4\n## [2,]    2    5\n## [3,]    3    6\no en hipercubo de 1 × 2 × 3 (que tiene 1 fila, 2 columnas, y 3 “rebanadas”). Esta es una estructura tridimensional, pero R necesitará mostrarla rebanada por rebanada en la pantalla bidimensional de su computadora:\ndim(dado) &lt;- c(1, 2, 3)\ndado\n## , , 1\n## \n##      [,1] [,2]\n## [1,]    1    2\n## \n## , , 2\n## \n##      [,1] [,2]\n## [1,]    3    4\n## \n## , , 3\n## \n##      [,1] [,2]\n## [1,]    5    6\nR siempre usará el primer valor en dim para el número de filas y el segundo valor para el número de columnas. En general, las filas siempre van primero en las operaciones de R que se ocupan tanto de filas como de columnas.\nPuede notar que no tiene mucho control sobre cómo R reorganiza los valores en filas y columnas. Por ejemplo, R siempre llena cada matriz por columnas, en lugar de por filas. Si desea tener más control sobre este proceso, puede usar una de las funciones auxiliares de R, matrix o array. Hacen lo mismo que cambiar el atributo dim, pero proporcionan argumentos adicionales para personalizar el proceso.",
    "crumbs": [
      "Proyecto 2: Baraja de Cartas",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Objectos de R</span>"
    ]
  },
  {
    "objectID": "objects.html#matrices",
    "href": "objects.html#matrices",
    "title": "3  Objectos de R",
    "section": "\n3.3 Matrices",
    "text": "3.3 Matrices\nLas matrices almacenan valores en una matriz bidimensional, como una matriz de álgebra lineal. Para crear uno, primero dale a matrix un vector atómico para reorganizar en una matriz. Luego, defina cuántas filas debe haber en la matriz configurando el argumento nrow en un número. matrix organizará su vector de valores en una matriz con el número especificado de filas. Alternativamente, puede establecer el argumento ncol, que le dice a R cuántas columnas incluir en la matriz:\nm &lt;- matrix(dado, nrow = 2)\nm\n##      [,1] [,2] [,3]\n## [1,]    1    3    5\n## [2,]    2    4    6\nmatrix llenará la matriz columna por columna por defecto, pero puedes llenar la matriz fila por fila si incluyes el argumento byrow = TRUE:\nm &lt;- matrix(dado, nrow = 2, byrow = TRUE)\nm\n##      [,1] [,2] [,3]\n## [1,]    1    2    3\n## [2,]    4    5    6\nmatrix también tiene otros argumentos predeterminados que puede usar para personalizar su matriz. Puede leer sobre ellos en la página de ayuda de matrix (accesible por ?matrix).",
    "crumbs": [
      "Proyecto 2: Baraja de Cartas",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Objectos de R</span>"
    ]
  },
  {
    "objectID": "objects.html#arreglos",
    "href": "objects.html#arreglos",
    "title": "3  Objectos de R",
    "section": "\n3.4 Arreglos",
    "text": "3.4 Arreglos\nLa función array crea una matriz de n dimensiones. Por ejemplo, podría usar array para clasificar los valores en un cubo de tres dimensiones o un hipercubo en 4, 5 o n dimensiones. array no es tan personalizable como matrix y básicamente hace lo mismo que configurar el atributo dim. Para usar array, proporcione un vector atómico como primer argumento y un vector de dimensiones como segundo argumento, ahora llamado dim:\nar &lt;- array(c(11:14, 21:24, 31:34), dim = c(2, 2, 3))\nar\n## , , 1\n## \n##      [,1] [,2]\n## [1,]   11   13\n## [2,]   12   14\n## \n## , , 2\n## \n##      [,1] [,2]\n## [1,]   21   23\n## [2,]   22   24\n## \n## , , 3\n## \n##      [,1] [,2]\n## [1,]   31   33\n## [2,]   32   34\nEjercicio 5.3 (Hacer una Matriz) Cree la siguiente matriz, que almacena el nombre y el palo de cada carta en una escalera real.\n##      [,1]       [,2]    \n## [1,] \"as\"      \"picas\"\n## [2,] \"rey\"     \"picas\"\n## [3,] \"reina\"   \"picas\"\n## [4,] \"jota\"    \"picas\"\n## [5,] \"diez\"    \"picas\"\nSolución. Hay más de una forma de construir esta matriz, pero en todos los casos, deberá comenzar creando un vector de caracteres con 10 valores. Si comienza con el siguiente vector de caracteres, puede convertirlo en una matriz con cualquiera de los siguientes tres comandos:\nmano1 &lt;- c(\"as\", \"rey\", \"reina\", \"jota\", \"diez\", \"picas\", \"picas\",\n  \"picas\", \"picas\", \"picas\")\n\nmatrix(mano1, nrow = 5)\nmatrix(mano1, ncol = 2)\ndim(mano1) &lt;- c(5, 2)\nTambién puede comenzar con un vector de caracteres que enumere las cartas en un orden ligeramente diferente. En este caso, deberá pedirle a R que llene la matriz fila por fila en lugar de columna por columna:\nmano2 &lt;- c(\"as\", \"picas\", \"rey\", \"picas\", \"reina\", \"picas\", \"jota\", \n  \"picas\", \"diez\", \"picas\")\n\nmatrix(mano2, nrow = 5, byrow = TRUE)\nmatrix(mano2, ncol = 2, byrow = TRUE)",
    "crumbs": [
      "Proyecto 2: Baraja de Cartas",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Objectos de R</span>"
    ]
  },
  {
    "objectID": "objects.html#clases",
    "href": "objects.html#clases",
    "title": "3  Objectos de R",
    "section": "\n3.5 Clases",
    "text": "3.5 Clases\nTenga en cuenta que cambiar las dimensiones de su objeto no cambiará el tipo del objeto, pero cambiará el atributo clase del objeto:\ndim(dado) &lt;- c(2, 3)\ntypeof(dado)\n##  \"double\"\n \nclass(dado)\n##  \"matrix\"\nUna matriz es un caso especial de un vector atómico. Por ejemplo, la matriz dado es un caso especial de vector doble. Cada elemento de la matriz sigue siendo un doble, pero los elementos se han organizado en una nueva estructura. R agregó un atributo de clase a dado cuando cambiaste sus dimensiones. Esta clase describe el nuevo formato de dado. Muchas funciones de R buscarán específicamente el atributo clase de un objeto y luego manejarán el objeto de una manera predeterminada en función del atributo.\nTenga en cuenta que el atributo clase de un objeto no siempre aparecerá cuando ejecute attributes; es posible que deba buscarlo específicamente con class:\nattributes(dado)\n## $dim\n## [1] 2 3\nPuede aplicar class a objetos que no tienen un atributo de clase. class devolverá un valor basado en el tipo atómico del objeto. Tenga en cuenta que la “clase” de un doble es “numérica”, una desviación extraña, pero por la que estoy agradecido. Creo que la propiedad más importante de un vector doble es que contiene números, una propiedad que “numeric” hace evidente:\nclass(\"Hola\")\n##  \"character\"\n\nclass(5)\n##  \"numeric\"\nTambién puede usar class para establecer el atributo clase de un objeto, pero esto suele ser una mala idea. R esperará que los objetos de una clase compartan ciertas características, como atributos, que su objeto puede no poseer. Aprenderá a crear y utilizar sus propias clases en Proyecto 3: Máquina Tragamonedas.\n\n3.5.1 Fechas y Horarios\nEl sistema de atributos permite que R represente más tipos de datos que solo dobles, enteros, caracteres, lógicos, complejos y sin procesar. La hora parece una cadena de caracteres cuando la visualizas, pero su tipo de datos es en realidad \"doble\", y su clase es \"POSIXct\" \"POSIXt\" (tiene dos clases):\nahora &lt;- Sys.time()\nahora\n## \"2014-03-17 12:00:00 UTC\"\n\ntypeof(ahora)\n##  \"double\"\n\nclass(ahora)\n## \"POSIXct\" \"POSIXt\" \nPOSIXct es un marco ampliamente utilizado para representar fechas y horas. En el marco de POSIXct, cada hora se representa por la cantidad de segundos que han pasado entre la hora y las 12:00 a. m. del 1 de enero de 1970 (en la zona Universal Time Coordinated (UTC)). Por ejemplo, el tiempo anterior ocurre 1 395 057 600 segundos después. Entonces, en el sistema POSIXct, el tiempo se guardaría como 1395057600.\nR crea el objeto de tiempo construyendo un vector doble con un elemento, 1395057600. Puede ver este vector eliminando el atributo clase de ahora, o usando la función unclass, que hace lo mismo:\nunclass(ahora)\n## 1395057600\nR luego le da al vector doble un atributo clase que contiene dos clases, \"POSIXct\" y \"POSIXt\". Este atributo alerta a las funciones de R de que están tratando con un tiempo POSIXct, para que puedan tratarlo de una manera especial. Por ejemplo, las funciones R usarán el estándar POSIXct para convertir la hora en una cadena de caracteres fácil de usar antes de mostrarla.\nPuede aprovechar este sistema dando la clase POSIXct a objetos R aleatorios. Por ejemplo, ¿alguna vez se ha preguntado qué día era un millón de segundos después de las 12:00 a. m. del 1 de enero de 1970?\nmillon &lt;- 1000000\nmillon\n## 1e+06\n \nclass(millon) &lt;- c(\"POSIXct\", \"POSIXt\")\nmillon\n## \"1970-01-12 13:46:40 UTC\"\n12 de enero de 1970. Vaya. Un millón de segundos pasan más rápido de lo que piensas. Esta conversión funcionó bien porque la clase POSIXct no depende de ningún atributo adicional, pero en general, forzar la clase de un objeto es una mala idea.\nHay muchas clases diferentes de datos en R y sus paquetes, y cada día se inventan nuevas clases. Sería difícil aprender sobre cada clase, pero no es necesario. La mayoría de las clases solo son útiles en situaciones específicas. Dado que cada clase viene con su propia página de ayuda, puede esperar para aprender sobre una clase hasta que la encuentre. Sin embargo, hay una clase de datos que es tan omnipresente en R que debería conocerla junto con los tipos de datos atómicos. Esa clase es factores.\n\n3.5.2 Factores\nLos factores son la forma en que R almacena información categórica, como el origen étnico o el color de ojos. Piense en un factor como algo así como un género; solo puede tener ciertos valores (masculino o femenino), y estos valores pueden tener su propio orden idiosincrático (damas primero). Este arreglo hace que los factores sean muy útiles para registrar los niveles de tratamiento de un estudio y otras variables categóricas.\nPara hacer un factor, pase un vector atómico a la función factor. R recodificará los datos en el vector como enteros y almacenará los resultados en un vector entero. R también agregará un atributo niveles (levels en inglés) al entero, que contiene un conjunto de etiquetas para mostrar los valores de los factores, y un atributo class, que contiene la clase factor:\ngenero &lt;- factor(c(\"masculino\", \"femenino\", \"femenino\", \"masculino\"))\n\ntypeof(genero)\n## \"integer\"\n\nattributes(genero)\n## $levels\n## [1] \"femenino\" \"masculino\"  \n## \n## $class\n## [1] \"factor\"\nPuedes ver exactamente cómo R almacena tu factor con unclass:\nunclass(genero)\n## [1] 2 1 1 2\n## attr(,\"levels\")\n## [1] \"femenino\" \"masculino\"  \nR usa el atributo de niveles cuando muestra el factor, como verá. R mostrará cada 1 como femenino, la primera etiqueta en el vector de niveles, y cada 2 como masculino, la segunda etiqueta. Si el factor incluyera 3, se mostrarían como la tercera etiqueta, y así sucesivamente:\ngenero\n## masculino   femenino femenino masculino  \n## Levels: femenino masculino\nLos factores facilitan la colocación de variables categóricas en un modelo estadístico porque las variables ya están codificadas como números. Sin embargo, los factores pueden resultar confusos, ya que parecen cadenas de caracteres pero se comportan como números enteros.\nR a menudo intentará convertir cadenas de caracteres en factores cuando cargue y cree datos. En general, tendrá una experiencia más fluida si no permite que R haga factores hasta que los solicite. Te mostraré cómo hacer esto cuando comencemos a leer datos.\nPuede convertir un factor en una cadena de caracteres con la función as.character. R conservará la versión de visualización del factor, no los números enteros almacenados en la memoria:\nas.character(genero)\n## \"masculino\"   \"femenino\" \"femenino\" \"masculino\" \nAhora que comprende las posibilidades que brindan los vectores atómicos de R, hagamos un tipo de naipe más complicado.\nEjercicio 5.4 (Escriba una Carta) Muchos juegos de cartas asignan un valor numérico a cada carta. Por ejemplo, en el blackjack, cada carta con figuras vale 10 puntos, cada carta con números vale entre 2 y 10 puntos, y cada as vale 1 u 11 puntos, dependiendo de la puntuación final.\nHaz un naipe virtual combinando “as”, “corazón” y 1 en un vector. ¿Qué tipo de vector atómico resultará? Comprueba si tienes razón.\nSolución. Es posible que hayas adivinado que este ejercicio no saldría bien. Cada vector atómico solo puede almacenar un tipo de datos. Como resultado, R convierte todos sus valores en cadenas de caracteres:\ncarta &lt;- c(\"as\", \"corazones\", 1)\ncarta\n## \"as\"    \"corazones\" \"1\" \nEsto causará problemas si desea hacer operaciones matemáticas con ese valor en puntos, por ejemplo, para ver quién ganó su juego de blackjack.\n\n\n\n\n\n\nTipos de datos en vectores\nSi intenta poner varios tipos de datos en un vector, R convertirá los elementos en un solo tipo de datos.\n\n\n\nDado que las matrices y los arreglos son casos especiales de vectores atómicos, sufren el mismo comportamiento. Cada uno solo puede almacenar un tipo de datos.\nEsto crea un par de problemas. Primero, muchos conjuntos de datos contienen múltiples tipos de datos. Los programas simples como Excel y Numbers pueden guardar múltiples tipos de datos en el mismo conjunto de datos, y debería esperar que R también pueda hacerlo. No te preocupes, puede.\nEn segundo lugar, la coerción es un comportamiento común en R, por lo que querrá saber cómo funciona.",
    "crumbs": [
      "Proyecto 2: Baraja de Cartas",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Objectos de R</span>"
    ]
  },
  {
    "objectID": "objects.html#coerción",
    "href": "objects.html#coerción",
    "title": "3  Objectos de R",
    "section": "\n3.6 Coerción",
    "text": "3.6 Coerción\nEl comportamiento de coerción de R puede parecer inconveniente, pero no es arbitrario. R siempre sigue las mismas reglas cuando obliga a los tipos de datos. Una vez que esté familiarizado con estas reglas, puede usar el comportamiento de coerción de R para hacer cosas sorprendentemente útiles.\nEntonces, ¿cómo coacciona R los tipos de datos? Si una cadena de caracteres está presente en un vector atómico, R convertirá todo lo demás en el vector en cadenas de caracteres. Si un vector solo contiene lógicos y números, R convertirá los lógicos en números; cada TRUE se convierte en 1, y cada FALSE se convierte en 0, como se muestra en la Figura Figura 3.1.\n\n\n\n\n\n\n\nFigura 3.1: R siempre usa las mismas reglas para obligar a los datos a un solo tipo. Si hay cadenas de caracteres presentes, todo se convertirá en una cadena de caracteres. De lo contrario, los lógicos se convierten en numéricos.\n\n\n\n\nEste arreglo preserva la información. Es fácil mirar una cadena de caracteres y decir qué información solía contener. Por ejemplo, puede detectar fácilmente los orígenes de \"TRUE\" y \"5\". También puede volver a transformar fácilmente un vector de 1 y 0 en TRUE y FALSE.\nR usa las mismas reglas de coerción cuando intenta hacer operaciones matemáticas con valores lógicos. Entonces el siguiente código:\nsum(c(TRUE, TRUE, FALSE, FALSE))\nse convertirá:\nsum(c(1, 1, 0, 0))\n## 2\nEsto significa que sum contará el número de TRUE en un vector lógico (y mean calculará la proporción de TRUE). Listo, ¿eh?\nPuede pedirle explícitamente a R que convierta datos de un tipo a otro con las funciones as. R convertirá los datos siempre que haya una forma sensata de hacerlo:\nas.character(1)\n## \"1\"\n\nas.logical(1)\n## TRUE\n\nas.numeric(FALSE)\n## 0\nAhora sabe cómo R coacciona los tipos de datos, pero esto no lo ayudará a salvar una carta. Para hacer eso, deberá evitar la coerción por completo. Puedes hacer esto usando un nuevo tipo de objeto, una lista.\nAntes de ver las listas, abordemos una pregunta que podría tener en mente.\nMuchos conjuntos de datos contienen múltiples tipos de información. La incapacidad de vectores, matrices y arreglos para almacenar múltiples tipos de datos parece ser una limitación importante. Entonces, ¿por qué molestarse con ellos?\nEn algunos casos, usar un solo tipo de datos es una gran ventaja. Los vectores, las matrices y los arreglos hacen que sea muy fácil hacer operaciones matemáticas con grandes conjuntos de números porque R sabe que puede manipular cada valor de la misma manera. Las operaciones con vectores, matrices y arreglos también tienden a ser rápidas porque los objetos son muy fáciles de almacenar en la memoria.\nEn otros casos, permitir un solo tipo de datos no es una desventaja. Los vectores son la estructura de datos más común en R porque almacenan muy bien las variables. Cada valor de una variable mide la misma propiedad, por lo que no es necesario utilizar diferentes tipos de datos.",
    "crumbs": [
      "Proyecto 2: Baraja de Cartas",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Objectos de R</span>"
    ]
  },
  {
    "objectID": "objects.html#listas",
    "href": "objects.html#listas",
    "title": "3  Objectos de R",
    "section": "\n3.7 Listas",
    "text": "3.7 Listas\nLas listas son como vectores atómicos porque agrupan datos en un conjunto unidimensional. Sin embargo, las listas no agrupan valores individuales; las listas agrupan objetos de R, como vectores atómicos y otras listas. Por ejemplo, puede crear una lista que contenga un vector numérico de longitud 31 en su primer elemento, un vector de caracteres de longitud 1 en su segundo elemento y una nueva lista de longitud 2 en su tercer elemento. Para hacer esto, use la función list.\nlist crea una lista de la misma manera que c crea un vector. Separe cada elemento de la lista con una coma:\nlista1 &lt;- list(100:130, \"R\", list(TRUE, FALSE))\nlista1\n## [[1]]\n## [1] 100 101 102 103 104 105 106 107 108 109 110 111 112\n## [14] 113 114 115 116 117 118 119 120 121 122 123 124 125\n## [27] 126 127 128 129 130\n## \n## [[2]]\n## [1] \"R\"\n##\n## [[3]]\n## [[3]][[1]]\n## [1] TRUE\n##\n## [[3]][[2]]\n## [1] FALSE\nDejé la notación [1] en la salida para que puedas ver cómo cambia para las listas. Los índices entre corchetes le indican qué elemento de la lista se está mostrando. Los índices de un solo paréntesis le indican qué subelemento de un elemento se muestra. Por ejemplo, 100 es el primer subelemento del primer elemento de la lista. \"R\" es el primer subelemento del segundo elemento. Esta notación de dos sistemas surge porque cada elemento de una lista puede ser cualquier objeto R, incluido un nuevo vector (o lista) con sus propios índices.\nLas listas son un tipo básico de objeto en R, a la par de los vectores atómicos. Al igual que los vectores atómicos, se utilizan como bloques de construcción para crear muchos tipos más sofisticados de objetos de R.\nComo puede imaginar, la estructura de las listas puede volverse bastante complicada, pero esta flexibilidad hace que las listas sean una herramienta de almacenamiento útil para todo uso en R: puede agrupar cualquier cosa con una lista.\nSin embargo, no todas las listas tienen que ser complicadas. Puede almacenar una carta de juego en una lista muy simple.\nEjercicio 5.5 (Usar una Lista para Crear una Carta) Use una lista para almacenar una sola carta, como el as de corazones, que tiene un valor de punto de uno. La lista debe guardar la cara de la carta, el palo y el valor del punto en elementos separados.\nSolución. Puedes crear tu carta así. En el siguiente ejemplo, el primer elemento de la lista es un vector de caracteres (de longitud 1). El segundo elemento también es un vector de caracteres y el tercer elemento es un vector numérico:\ncarta &lt;- list(\"as\", \"corazones\", 1)\ncarta\n## [[1]]\n## [1] \"as\"\n##\n## [[2]]\n## [1] \"corazones\"\n##\n## [[3]]\n## [1] 1\nTambién puede usar una lista para almacenar una baraja completa de cartas. Dado que puede guardar una sola carta de juego como una lista, puede guardar una baraja de cartas de juego como una lista de 52 sublistas (una para cada carta). Pero no nos molestemos, hay una forma mucho más limpia de hacer lo mismo. Puede usar una clase especial de lista, conocida como data frames.",
    "crumbs": [
      "Proyecto 2: Baraja de Cartas",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Objectos de R</span>"
    ]
  },
  {
    "objectID": "objects.html#data-frames",
    "href": "objects.html#data-frames",
    "title": "3  Objectos de R",
    "section": "\n3.8 Data Frames",
    "text": "3.8 Data Frames\nData frames son la versión bidimensional de una lista. Son, por mucho, la estructura de almacenamiento más útil para el análisis de datos y proporcionan una forma ideal de almacenar una baraja completa de cartas. Puede pensar en un data frame como el equivalente de R a la hoja de cálculo de Excel porque almacena datos en un formato similar.\nData frames agrupan vectores en una tabla bidimensional. Cada vector se convierte en una columna en la tabla. Como resultado, cada columna de un data frame puede contener un tipo diferente de datos; pero dentro de una columna, cada celda debe tener el mismo tipo de datos, como en la Figura Figura 3.2.\n\n\n\n\n\n\n\nFigura 3.2: Data frames almacenan datos como una secuencia de columnas. Cada columna puede ser un tipo de datos diferente. Cada columna en un data frame debe tener la misma longitud.\n\n\n\n\nCrear un data frame a mano requiere escribir mucho, pero puede hacerlo (si lo desea) con la función data.frame. Proporcione a data.frame cualquier número de vectores, cada uno separado por una coma. Cada vector debe establecerse igual a un nombre que describa el vector. data.frame convertirá cada vector en una columna del nuevo data frame:\ndf &lt;- data.frame(cara = c(\"as\", \"dos\", \"seis\"),  \n  palo = c(\"treboles\", \"treboles\", \"treboles\"), valor = c(1, 2, 3))\ndf\n## cara      palo valor\n##  as   treboles     1\n##  dos  treboles     2\n##  seis treboles     3\nDeberá asegurarse de que cada vector tenga la misma longitud (o se puede hacer así con las reglas de reciclaje de R; consulte la figura Figura 1.4, ya que los data frames no pueden combinar columnas de diferentes longitudes.\nEn el código anterior, nombré los argumentos en data.frame cara, palo y valor, pero puedes nombrar los argumentos como quieras. data.frame utilizará los nombres de sus argumentos para etiquetar las columnas del data frame.\n\n\n\n\n\n\nNombres\nTambién puede dar nombres a una lista o vector cuando crea uno de estos objetos. Use la misma sintaxis que con data.frame:\nlist(cara = \"as\", palo = \"corazones\", value = 1)c(cara = \"as\", palo = \"corazones\", value = \"one\")\nLos nombres se almacenarán en el atributo names del objeto.\n\n\n\nSi observa el tipo de data frame, verá que es una lista. De hecho, cada data frame es una lista con la clase data.frame. Puede ver qué tipos de objetos se agrupan en una lista (o data frame) con la función str:\ntypeof(df)\n## \"list\"\n\nclass(df)\n## \"data.frame\"\n\nstr(df)\n## 'data.frame':    3 obs. of  3 variables:\n##  $ cara : Factor w/ 3 levels \"as\",\"seis\",\"dos\": 1 3 2\n##  $ palo : Factor w/ 1 level \"treboles\": 1 1 1\n##  $ valor: num  1 2 3\nObserve que R guardó sus cadenas de caracteres como factores. ¡Te dije que a R le gustan los factores! No es un gran problema aquí, pero puede evitar este comportamiento agregando el argumento stringsAsFactors = FALSE a data.frame:\ndf &lt;- data.frame(cara = c(\"as\", \"dos\", \"seis\"),  \n  palo = c(\"treboles\", \"treboles\", \"treboles\"), value = c(1, 2, 3),\n  stringsAsFactors = FALSE)\nUn data frame es una excelente manera de construir una baraja completa de cartas. Puede convertir cada fila del data frame en una carta de juego y cada columna en un tipo de valor, cada uno con su propio tipo de datos apropiado. El data frame se vería así:\n##   cara      palo valor\n##    rey     picas    13\n##  reina     picas    12\n##   jota     picas    11\n##   diez     picas    10\n##  nueve     picas     9\n##   ocho     picas     8\n##  siete     picas     7\n##   seis     picas     6\n##  cinco     picas     5\n## cuatro     picas     4\n##   tres     picas     3\n##    dos     picas     2\n##     as     picas     1\n##    rey  treboles    13\n##  reina  treboles    12\n##   jota  treboles    11\n##   diez  treboles    10\n##   ... y así sucesivamente.\nPodría crear este data frame con data.frame, ¡pero mire la escritura involucrada! Necesitas escribir tres vectores, cada uno con 52 elementos:\nbaraja &lt;- data.frame(\n  cara = c(\"rey\", \"reina\", \"jota\", \"diez\", \"nueve\", \"ocho\", \"siete\", \"seis\",\n    \"cinco\", \"cuatro\", \"tres\", \"dos\", \"as\", \"rey\", \"reina\", \"jota\", \"diez\", \n    \"nueve\", \"ocho\", \"siete\", \"seis\", \"cinco\", \"cuatro\", \"tres\", \"dos\", \"as\", \n    \"rey\", \"reina\", \"jota\", \"diez\", \"nueve\", \"ocho\", \"siete\", \"seis\", \"cinco\", \n    \"cuatro\", \"tres\", \"dos\", \"as\", \"rey\", \"reina\", \"jota\", \"diez\", \"nueve\", \n    \"ocho\", \"siete\", \"seis\", \"cinco\", \"cuatro\", \"tres\", \"dos\", \"as\"),  \n  palo = c(\"picas\", \"picas\", \"picas\", \"picas\", \"picas\", \"picas\", \n    \"picas\", \"picas\", \"picas\", \"picas\", \"picas\", \"picas\", \"picas\", \n    \"treboles\", \"treboles\", \"treboles\", \"treboles\", \"treboles\", \"treboles\", \"treboles\", \"treboles\", \n    \"treboles\", \"treboles\", \"treboles\", \"treboles\", \"treboles\", \"diamantes\", \"diamantes\", \n    \"diamantes\", \"diamantes\", \"diamantes\", \"diamantes\", \"diamantes\", \"diamantes\", \n    \"diamantes\", \"diamantes\", \"diamantes\", \"diamantes\", \"diamantes\", \"corazones\", \n    \"corazones\", \"corazones\", \"corazones\", \"corazones\", \"corazones\", \"corazones\", \"corazones\", \n    \"corazones\", \"corazones\", \"corazones\", \"corazones\", \"corazones\"), \n  valor = c(13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 13, 12, 11, 10, 9, 8, \n    7, 6, 5, 4, 3, 2, 1, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 13, 12, 11, \n    10, 9, 8, 7, 6, 5, 4, 3, 2, 1)\n)\nDebe evitar escribir grandes conjuntos de datos a mano siempre que sea posible. Escribir invita a errores tipográficos y errores. Siempre es mejor adquirir grandes conjuntos de datos como un archivo de computadora. Luego puede pedirle a R que lea el archivo y almacene el contenido como un objeto.\nCreé un archivo para que lo cargues que contiene un data frame de información de naipes, así que no te preocupes por escribir el código. En su lugar, dirija su atención hacia la carga de datos en R.",
    "crumbs": [
      "Proyecto 2: Baraja de Cartas",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Objectos de R</span>"
    ]
  },
  {
    "objectID": "objects.html#loading",
    "href": "objects.html#loading",
    "title": "3  Objectos de R",
    "section": "\n3.9 Cargar Datos",
    "text": "3.9 Cargar Datos\nPuede cargar el data frame Mazo desde el archivo mazo.csv. Tómese un momento para descargar el archivo antes de seguir leyendo. Visite el sitio web, haga clic en “Descargar Zip” y luego descomprima y abra la carpeta que descarga su navegador web. mazo.csv estará dentro.\nmazo.csv es un archivo de valores separados por comas, o CSV para abreviar. Los CSV son archivos de texto sin formato, lo que significa que puede abrirlos en un editor de texto (así como en muchos otros programas). Si abre mazo.csv, notará que contiene una tabla de datos similar a la siguiente tabla. Cada fila de la tabla se guarda en su propia línea y se usa una coma para separar las celdas dentro de cada fila. Cada archivo CSV comparte este formato básico:\n\"cara\",\"palo\",\"valor\"\n\"rey\",\"picas\",13\n\"reina\",\"picas\",12\n\"jota\",\"picas\",11\n\"diez\",\"picas\",10\n\"nueve\",\"picas\",9\n... y así sucesivamente.\nLa mayoría de las aplicaciones de ciencia de datos pueden abrir archivos de texto sin formato y exportar datos como archivos de texto sin formato. Esto hace que los archivos de texto sin formato sean una especie de lingua franca para la ciencia de datos.\nPara cargar un archivo de texto sin formato en R, haga clic en el icono Import Dataset en RStudio, que se muestra en la Figura Figura 3.3. Luego seleccione “From text file (base)”.\n\n\n\n\n\n\n\nFigura 3.3: Puede importar datos desde archivos de texto sin formato con Import Dataset de RStudio.\n\n\n\n\nRStudio le pedirá que seleccione el archivo que desea importar, luego abrirá un asistente para ayudarlo a importar los datos, como en la Figura Figura 3.4. Utilice el asistente para decirle a RStudio qué nombre dar al conjunto de datos. También puede usar el asistente para decirle a RStudio qué carácter usa el conjunto de datos como separador, qué carácter usa para representar decimales (generalmente un punto en los Estados Unidos y una coma en Europa) y si el conjunto de datos viene o no con una fila de nombres de columna (conocido como header). Para ayudarlo, el asistente le muestra cómo se ve el archivo sin procesar, así como también cómo se verán los datos cargados según la configuración de entrada.\nTambién puede desmarcar la casilla “Strings as factors” en el asistente. Recomiendo hacer esto. Si lo hace, R cargará todas sus cadenas de caracteres como cadenas de caracteres. Si no lo hace, R los convertirá en factores.\n\n\n\n\n\n\n\nFigura 3.4: Asistente de importación de RStudio.\n\n\n\n\nUna vez que todo se vea bien, haga clic en Import. RStudio leerá los datos y los guardará en un data frame. RStudio también abrirá un visor de datos, para que pueda ver sus nuevos datos en un formato de hoja de cálculo. Esta es una buena manera de verificar que todo salió como se esperaba. Si todo funcionó bien, su archivo debería aparecer en una pestaña View de RStudio, como se ve en la Figura Figura 3.5. Puede examinar el data frame en la consola con head(mazo)\n\n\n\n\n\n\nDatos en Línea\nPuede cargar un archivo de texto sin formato directamente desde Internet haciendo click en Import Dataset &gt; From Text (readr) y copiando la url del archivo en la casilla “File/URL” del asistente de importación de RStudio. Para poder utlizar esta opción debera instalar el paquete readr.\n\n\n\n\n\n\n\n\n\n\nFigura 3.5: Cuando importa un conjunto de datos, RStudio guardará los datos en un data frame y luego mostrará el data frame en una pestaña View. Puede abrir cualquier data frame en una pestaña View en cualquier momento con la función View.\n\n\n\n\nAhora es tu turno. Descargue mazo.csv e impórtelo a RStudio. Asegúrese de guardar la salida en un objeto de R llamado mazo: lo usará en los próximos capítulos. Si todo va correctamente, las primeras líneas de su data frame deberían verse así:\nhead(mazo)\n##  cara   palo valor\n##   rey  picas    13\n## reina  picas    12\n##  jota  picas    11\n##  diez  picas    10\n## nueve  picas     9\n##  ocho  picas     8\n\n\n\n\n\n\nhead y tail son dos funciones que proporcionan una manera fácil de echar un vistazo a grandes conjuntos de datos. head devolverá solo las primeras seis filas del conjunto de datos, y tail devolverá solo las últimas seis filas. Para ver un número diferente de filas, dé a head o tail un segundo argumento, el número de filas que le gustaría ver, por ejemplo, head (mazo, 10).\n\n\n\nR puede abrir muchos tipos de archivos, no solo CSV. Visite Cargar y Guardar Datos en R para obtener información sobre cómo abrir otros tipos comunes de archivos en R.",
    "crumbs": [
      "Proyecto 2: Baraja de Cartas",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Objectos de R</span>"
    ]
  },
  {
    "objectID": "objects.html#guardar-datos",
    "href": "objects.html#guardar-datos",
    "title": "3  Objectos de R",
    "section": "\n3.10 Guardar Datos",
    "text": "3.10 Guardar Datos\nAntes de continuar, guardemos una copia de mazo como un nuevo archivo .csv. De esa manera, puede enviarlo por correo electrónico a un colega, almacenarlo en una memoria USB o abrirlo en un programa diferente. Puede guardar cualquier data frame en R en un archivo .csv con el comando write.csv. Para guardar mazo, ejecute:\nwrite.csv(mazo, file = \"cartas.csv\", row.names = FALSE)\nR convertirá su data frame en un archivo de texto sin formato con el formato de valores separados por comas y guardará el archivo en su directorio de trabajo. Para ver dónde está su directorio de trabajo, ejecute getwd(). Para cambiar la ubicación de su directorio de trabajo, visite Session &gt; Set Working Directory &gt; Choose Directory en la barra de menú de RStudio.\nPuede personalizar el proceso de guardado con el amplio conjunto de argumentos opcionales de write.csv (consulte ?write.csv para obtener más detalles). Sin embargo, hay tres argumentos que debería usar cada vez que ejecute write.csv.\nPrimero, debe darle a write.csv el nombre del data frame que desea guardar. A continuación, debe proporcionar un nombre de archivo para darle a su archivo. R tomará este nombre literalmente, así que asegúrese de proporcionar una extensión.\nFinalmente, debe agregar el argumento row.names = FALSE. Esto evitará que R agregue una columna de números al comienzo de su data frame. Estos números identificarán sus filas del 1 al 52, pero es poco probable que cualquier programa en el que abra cartas.csv comprenda el sistema de nombres de fila. Lo más probable es que el programa asuma que los nombres de las filas son la primera columna de datos en su data frame. De hecho, esto es exactamente lo que asumirá R si vuelve a abrir cartas.csv. Si guarda y abre cartas.csv varias veces en R, notará que se forman columnas duplicadas de números de fila al comienzo de su data frame. No puedo explicar por qué R hace esto, pero puedo explicar cómo evitarlo: use row.names = FALSE siempre que guarde datos con write.csv.\nPara obtener más detalles sobre cómo guardar archivos, incluido cómo comprimir archivos guardados y cómo guardar archivos en otros formatos, consulte Cargar y Guardar Datos en R.\nBuen trabajo. Ahora tiene una baraja de cartas virtual con la que trabajar. Tómese un respiro y, cuando regrese, comenzaremos a escribir algunas funciones para usar en su mazo.",
    "crumbs": [
      "Proyecto 2: Baraja de Cartas",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Objectos de R</span>"
    ]
  },
  {
    "objectID": "objects.html#resumen",
    "href": "objects.html#resumen",
    "title": "3  Objectos de R",
    "section": "\n3.11 Resumen",
    "text": "3.11 Resumen\nPuede guardar datos en R con cinco objetos diferentes, que le permiten almacenar diferentes tipos de valores en diferentes tipos de relaciones, como en la Figura Figura 3.6. De estos objetos, los data frame son, por mucho, los más útiles para la ciencia de datos. Los data frame almacenan una de las formas de datos más comunes utilizadas en la ciencia de datos, los datos tabulares.\n\n\n\n\n\n\n\nFigura 3.6: Las estructuras de datos más comunes de R son vectores, matrices, arreglos, listas y marcos de datos.\n\n\n\n\nPuede cargar datos tabulares en un data frame con el botón Import Dataset de RStudio, siempre que los datos se guarden como un archivo de texto sin formato. Este requisito no es tan limitante como parece. La mayoría de los programas de software pueden exportar datos como un archivo de texto sin formato. Entonces, si tiene un archivo de Excel (por ejemplo), puede abrir el archivo en Excel y exportar los datos como CSV para usar con R. De hecho, abrir un archivo en su programa original es una buena práctica. Los archivos de Excel usan metadatos, como hojas y fórmulas, que ayudan a Excel a trabajar con el archivo. R puede intentar extraer datos sin procesar del archivo, pero no será tan bueno para hacerlo como lo es Microsoft Excel. Ningún programa es mejor para convertir archivos de Excel que Excel. Del mismo modo, ningún programa es mejor para convertir archivos SAS Xport que SAS, y así sucesivamente.\nSin embargo, es posible que se encuentre con un archivo específico del programa, pero no con el programa que lo creó. No querría comprar una licencia SAS de varios miles de dólares solo para abrir un archivo SAS. Afortunadamente, R puede abrir muchos tipos de archivos, incluidos archivos de otros programas y bases de datos. R incluso tiene sus propios formatos específicos del programa que pueden ayudarlo a ahorrar memoria y tiempo si sabe que trabajará completamente en R. Si desea obtener más información sobre todas sus opciones para cargar y guardar datos en R, consulte Cargar y Guardar Datos en R.\nNotación de R se basará en las habilidades que aprendió en este capítulo. Aquí, aprendió cómo almacenar datos en R. En Notación de R, aprenderá cómo acceder a los valores una vez que se han almacenado. También escribirá dos funciones que le permitirán comenzar a usar su mazo, una función para barajar y una función para repartir.",
    "crumbs": [
      "Proyecto 2: Baraja de Cartas",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Objectos de R</span>"
    ]
  },
  {
    "objectID": "notation.html",
    "href": "notation.html",
    "title": "4  Notación de R",
    "section": "",
    "text": "4.1 Selección de Valores\nAhora que tiene una baraja de cartas, necesita una forma de hacer: Primero, querrás una forma de barajar el mazo de vez en cuando. Y luego, querrás repartir cartas del mazo (una carta a la vez, cualquiera que sea la carta que esté arriba, no somos tramposos).\nPara hacer estas cosas, deberá trabajar con los valores individuales dentro de su data frame, una tarea esencial para la ciencia de datos. Por ejemplo, para repartir una carta de la parte superior de su mazo, deberá escribir una función que seleccione la primera fila de valores en su data frame, como esta\nPuede seleccionar valores dentro de un objeto de R con el sistema de notación de R.\nR tiene un sistema de notación que le permite extraer valores de objetos de R. Para extraer un valor o un conjunto de valores de un data frame, escriba el nombre del data frame seguido de un par de corchetes:\nEntre paréntesis irán dos índices separados por una coma. Los índices le dicen a R qué valores devolver. R usará el primer índice para crear un subconjunto de las filas del data frame y el segundo índice para crear un subconjunto de las columnas.\nTiene una opción cuando se trata de escribir índices. Hay seis formas diferentes de escribir un índice para R, y cada una hace algo ligeramente diferente. Todas son muy simples y bastante prácticas, así que echemos un vistazo a cada una de ellas. Puede crear índices con:\nLa forma más simple de escribir índices es la de los números enteros positivos.",
    "crumbs": [
      "Proyecto 2: Baraja de Cartas",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Notación de R</span>"
    ]
  },
  {
    "objectID": "notation.html#selección-de-valores",
    "href": "notation.html#selección-de-valores",
    "title": "4  Notación de R",
    "section": "",
    "text": "mazo[ , ]\n\n\n\nEnteros positivos\nEnteros negativos\nCero\nEspacios en blanco\nValores lógicos\nNombres\n\n\n\n4.1.1 Números Enteros Positivos\nR trata los enteros positivos como la notación ij en álgebra lineal: mazo[i,j] devolverá el valor de mazo que está en la iésima fila y la jésima columna, Figura Figura 4.1. Tenga en cuenta que i y j solo necesitan ser números enteros en el sentido matemático. Se pueden guardar como números en R\nhead(mazo)\n##  cara  palo valor\n##   rey picas    13\n## reina picas    12\n##  jota picas    11\n##  diez picas    10\n## nueve picas     9\n##  ocho picas     8\n\nmazo[1, 1]\n## \"rey\"\nPara extraer más de un valor, utilice un vector de enteros positivos. Por ejemplo, puedes devolver la primera fila de mazo con mazo[1, c(1, 2, 3)] o mazo[1, 1:3]:\nmazo[1, c(1, 2, 3)]\n## cara  palo valor\n##  rey picas    13\nR devolverá los valores de mazo que están tanto en la primera fila como en la primera, segunda y tercera columna. Tenga en cuenta que R en realidad no eliminará estos valores de mazo. R le dará un nuevo conjunto de valores que son copias de los valores originales. Luego puede guardar este nuevo conjunto en un objeto de R con el operador de asignación de R:\nnuevo &lt;- mazo[1, c(1, 2, 3)]\nnuevo\n## cara  palo valor\n##  rey picas    13\n\n\n\n\n\n\nRepetición\nSi repite un número en su índice, R devolverá los valores correspondientes más de una vez en su “subconjunto”. Este código devolverá la primera fila de mazo dos veces:\nmazo[c(1, 1), c(1, 2, 3)]\n## cara  palo valor\n##  rey picas    13\n##  rey picas    13\n\n\n\n\n\n\n\n\n\n\nFigura 4.1: R usa el sistema de notación ij del álgebra lineal. Los comandos de esta figura devolverán los valores sombreados.\n\n\n\n\nEl sistema de notación de R no se limita a tramas de datos. Puede usar la misma sintaxis para seleccionar valores en cualquier objeto de R, siempre que proporcione un índice para cada dimensión del objeto. Entonces, por ejemplo, puede crear un subconjunto de un vector (que tiene una dimensión) con un solo índice:\nvec &lt;- c(6, 1, 3, 6, 10, 5)\nvec[1:3]\n## 6 1 3\n\n\n\n\n\n\nLa indexación comienza en 1\nEn algunos lenguajes de programación, la indexación comienza con 0. Esto significa que 0 devuelve el primer elemento de un vector, 1 devuelve el segundo elemento y así sucesivamente.\nEste no es el caso con R. La indexación en R se comporta como la indexación en álgebra lineal. El primer elemento siempre está indexado por 1. ¿Por qué R es diferente? Tal vez porque fue escrito para matemáticos. Aquellos de nosotros que aprendimos a indexar en un curso de álgebra lineal nos preguntamos por qué los programadores de computadoras comienzan con 0.\n\n\n\n\n\n\n\n\n\ndrop = FALSE\nSi selecciona dos o más columnas de un data frame, R devolverá un nuevo data frame:\nmazo[1:2, 1:2]\n##  cara  palo\n##   rey picas\n## reina picas\nSin embargo, si selecciona una sola columna, R devolverá un vector:\nmazo[1:2, 1]\n##  \"rey\"  \"reina\"\nSi prefiere un data frame, puede agregar el argumento opcional drop = FALSE entre corchetes:\nmazo[1:2, 1, drop = FALSE]\n##  cara\n##   rey\n## reina\nEste método también funciona para seleccionar una sola columna de una matriz o arreglo.\n\n\n\n\n4.1.2 Números Enteros Negativos\nLos enteros negativos hacen exactamente lo contrario de los enteros positivos al indexar. R devolverá todos los elementos excepto los elementos en un índice negativo. Por ejemplo, mazo[-1, 1:3] devolverá todo menos la primera fila de mazo. mazo[-(2:52), 1:3] devolverá la primera fila (y excluirá todo lo demás):\nmazo[-(2:52), 1:3]\n## cara  palo valor\n##  rey picas    13\nLos enteros negativos son una forma más eficaz de crear subconjuntos que los enteros positivos si desea incluir la mayoría de las filas o columnas de un data frame.\nR devolverá un error si intenta emparejar un entero negativo con un entero positivo en el mismo índice:\nmazo[c(-1, 1), 1]\n## Error in xj[i] : only 0's may be mixed with negative subscripts\nSin embargo, puede usar enteros negativos y positivos para crear subconjuntos de un objeto si los usa en índices diferentes (por ejemplo, si usa uno en el índice de filas y otro en el índice de columnas, como mazo[-1, 1]) .\n\n4.1.3 Cero\n¿Qué pasaría si usaras el cero como índice? El cero no es ni un entero positivo ni un entero negativo, pero R aún lo usará para hacer un tipo de subconjunto. R no devolverá nada de una dimensión cuando use cero como índice. Esto crea un objeto vacío:\nmazo[0, 0]\n## data frame with 0 columns and 0 rows\nPara ser honesto, la indexación con cero no es muy útil.\n\n4.1.4 Espacios en Blanco\nPuede usar un espacio en blanco para decirle a R que extraiga todos los valores en una dimensión. Esto le permite crear subconjuntos de un objeto en una dimensión pero no en las otras, lo cual es útil para extraer filas o columnas enteras de un data frame:\nmazo[1, ]\n## cara  palo valor\n##  rey picas    13\n\n4.1.5 Valores Lógicos\nSi proporciona un vector de TRUE y FALSE como su índice, R hará coincidir cada TRUE y FALSE con una fila en su data frame (o una columna dependiendo de dónde coloque el índice). R luego devolverá cada fila que corresponda a un TRUE, Figura Figura 4.2.\nPuede ser útil imaginar a R leyendo el data frame y preguntando: “¿Debería devolver la _i_ésima fila de la estructura de datos?” y luego consultando el valor _i_ésimo del índice para su respuesta. Para que este sistema funcione, su vector debe ser tan largo como la dimensión que está tratando de dividir en subconjuntos:\nmazo[1, c(TRUE, TRUE, FALSE)]\n## cara  palo \n##  rey picas\n\nfilas &lt;- c(TRUE, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, \n  F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, \n  F, F, F, F, F, F, F, F, F, F, F, F, F, F)\nmazo[filas, ]\n## cara  palo valor\n##  rey picas    13\n\n\n\n\n\n\n\nFigura 4.2: Puede usar vectores de TRUE y FALSE para decirle a R exactamente qué valores desea extraer y cuáles no. El comando devolvería solo los números 1, 6 y 5.\n\n\n\n\nEste sistema puede parecer extraño, ¿quién quiere escribir tantos TRUE y FALSE?, pero se volverá muy poderoso en Modificación de Valores.\n\n4.1.6 Nombres\nFinalmente, puede solicitar los elementos que desee por nombre, si su objeto tiene nombres (consulte Nombres). Esta es una forma común de extraer las columnas de un data frame, ya que las columnas casi siempre tienen nombres:\nmazo[1, c(\"cara\", \"palo\", \"valor\")]\n## cara  palo valor\n##  rey picas    13\n\n# toda la columna de valor\nmazo[ , \"valor\"]\n##  13 12 11 10  9  8  7  6  5  4  3  2  1 13 12 11 10  9  8\n##  7  6  5  4  3  2  1 13 12 11 10  9  8  7  6  5  4  3  2\n##  1 13 12 11 10  9  8  7  6  5  4  3  2  1",
    "crumbs": [
      "Proyecto 2: Baraja de Cartas",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Notación de R</span>"
    ]
  },
  {
    "objectID": "notation.html#repartir-una-carta",
    "href": "notation.html#repartir-una-carta",
    "title": "4  Notación de R",
    "section": "\n4.2 Repartir una Carta",
    "text": "4.2 Repartir una Carta\nAhora que conoce los conceptos básicos del sistema de notación de R, pongámoslo en práctica.\nEjercicio 6.1 (Repartir una Carta) Complete el siguiente código para crear una función que devuelva la primera fila de un data frame:\nrepartir &lt;- function(cartas) {\n   # ?\n}\nSolución. Puede usar cualquiera de los sistemas que devuelven la primera fila de su data frame para escribir una función de repartir. Usaré enteros positivos y espacios en blanco porque creo que son fáciles de entender:\nrepartir &lt;- function(cartas) {\n  cartas[1, ]\n}\nLa función hace exactamente lo que quieres: reparte la carta superior de tu conjunto de datos. Sin embargo, la función se vuelve menos impresionante si ejecuta `repartir`` una y otra vez:\nrepartir(mazo)\n## cara  palo valor\n##  rey picas    13\n\nrepartir(mazo)\n## cara  palo valor\n##  rey picas    13\n\nrepartir(mazo)\n## cara  palo valor\n##  rey picas    13\nrepartir siempre devuelve el rey de picas porque mazo no sabe que hemos repartido la carta. Por lo tanto, el rey de picas se queda donde está, en la parte superior de la baraja, listo para ser repartido nuevamente. Este es un problema difícil de resolver, y lo trataremos en Entornos. Mientras tanto, puedes solucionar el problema barajando tu mazo después de cada vez que repartes. Entonces una nueva tarjeta siempre estará en la parte superior.\nBarajar es un compromiso temporal: las probabilidades en juego en su mazo no coincidirán con las probabilidades que ocurren cuando juega un juego con un solo mazo de cartas. Por ejemplo, seguirá existiendo la probabilidad de que el rey de picas aparezca dos veces seguidas. Sin embargo, las cosas no son tan malas como pueden parecer. La mayoría de los casinos usan cinco o seis mazos a la vez en los juegos de cartas para evitar el conteo de cartas. Las probabilidades que encontraría en esas situaciones son muy parecidas a las que crearemos aquí.",
    "crumbs": [
      "Proyecto 2: Baraja de Cartas",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Notación de R</span>"
    ]
  },
  {
    "objectID": "notation.html#barajar-el-mazo",
    "href": "notation.html#barajar-el-mazo",
    "title": "4  Notación de R",
    "section": "\n4.3 Barajar el Mazo",
    "text": "4.3 Barajar el Mazo\nCuando barajas una baraja de cartas real, reorganizas aleatoriamente el orden de las cartas. En su mazo virtual, cada carta es una fila en un data frame. Para barajar el mazo, debe reordenar aleatoriamente las filas en el data frame. Se puede hacer esto? ¡Apuesta! Y ya sabes todo lo que necesitas para hacerlo.\nEsto puede sonar tonto, pero comience extrayendo cada fila en su data frame:\nmazo2 &lt;- mazo[1:52, ]\n\nhead(mazo2)\n##   cara  palo valor\n##    rey picas    13\n##  reina picas    12\n##   jota picas    11\n##   diez picas    10\n##  nueve picas     9\n##   ocho picas     8\n¿Qué obtienes? Un nuevo data frame cuyo orden no ha cambiado en absoluto. ¿Qué pasa si le pides a R que extraiga las filas en un orden diferente? Por ejemplo, podría pedir la fila 2, luego la fila 1 y luego el resto de las tarjetas:\nmazo3 &lt;- mazo[c(2, 1, 3:52), ]\n\nhead(mazo3)\n##   cara  palo valor\n##  reina picas    12\n##    rey picas    13\n##   jota picas    11\n##   diez picas    10\n##  nueve picas     9\n##   ocho picas     8\nR cumple. Obtendrá todas las filas de vuelta, y vendrán en el orden que las pida. Si desea que las filas aparezcan en un orden aleatorio, debe ordenar los números enteros del 1 al 52 en un orden aleatorio y usar los resultados como un índice de fila. ¿Cómo podrías generar una colección tan aleatoria de enteros? Con nuestra amigable función vecinal sample:\naleatorio &lt;- sample(1:52, size = 52)\naleatorio\n##  35 28 39  9 18 29 26 45 47 48 23 22 21 16 32 38  1 15 20\n##  11  2  4 14 49 34 25  8  6 10 41 46 17 33  5  7 44  3 27\n##  50 12 51 40 52 24 19 13 42 37 43 36 31 30\n\nmazo4 &lt;- mazo[aleatorio, ]\nhead(mazo4)\n##   cara      palo valor\n##  cinco diamantes     5\n##  reina diamantes    12\n##     as diamantes     1\n##  cinco     picas     5\n##  nueve  trevoles     9\n##   jota diamantes    11\nAhora el nuevo conjunto está verdaderamente barajado. Terminará una vez que ajuste estos pasos en una función.\nEjercicio 6.2 (Barajar el Mazo) Usa las ideas anteriores para escribir una función barajar. barajar debe tomar un data frame y devolver una copia aleatoria del data frame.\nSolución. Su función barajar se verá como la siguiente:\nbarajar &lt;- function(cartas) { \n  aleatorio &lt;- sample(1:52, size = 52)\n  cartas[aleatorio, ]\n}\n¡Buen trabajo! Ahora puedes barajar tus cartas entre cada vez que reparte:\nrepartir(mazo)\n## cara  palo valor\n##  rey picas    13\n\nmazo2 &lt;- barajar(mazo) \n\nrepartir(mazo2)\n## cara     palo valor\n## jota treboles    11",
    "crumbs": [
      "Proyecto 2: Baraja de Cartas",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Notación de R</span>"
    ]
  },
  {
    "objectID": "notation.html#signos-de-dólar-y-corchetes-dobles",
    "href": "notation.html#signos-de-dólar-y-corchetes-dobles",
    "title": "4  Notación de R",
    "section": "\n4.4 Signos de Dólar y Corchetes Dobles",
    "text": "4.4 Signos de Dólar y Corchetes Dobles\nDos tipos de objetos en R obedecen a un segundo sistema opcional de notación. Puede extraer valores de data frame y listas con la sintaxis $. Encontrará la sintaxis $ una y otra vez como programador de R, así que examinemos cómo funciona.\nPara seleccionar una columna de un data frame, escriba el nombre del data frame y el nombre de la columna separados por un $. Tenga en cuenta que no se deben colocar comillas alrededor del nombre de la columna:\nmazo$valor\n## 13 12 11 10  9  8  7  6  5  4  3  2  1 13 12 11 10  9  8  7\n##  6  5  4  3  2  1 13 12 11 10  9  8  7  6  5  4  3  2  1 13\n## 12 11 10  9  8  7  6  5  4  3  2  1\nR devolverá todos los valores de la columna como un vector. Esta notación $ es increíblemente útil porque a menudo almacenará las variables de sus conjuntos de datos como columnas en un data frame.De vez en cuando, querrá ejecutar una función como mean o median en los valores de una variable. En R, estas funciones esperan un vector de valores como entrada, y mazo$valor entrega tus datos en el formato correcto:\nmean(mazo$valor)\n## 7\n\nmedian(mazo$valor)\n## 7\nPuede usar la misma notación $ con los elementos de una lista, si tienen nombres. Esta notación también tiene una ventaja con las listas. Si crea subconjuntos de una lista de la manera habitual, R devolverá una lista nueva que tiene los elementos que solicitó. Esto es cierto incluso si solo solicita un solo elemento.\nPara ver esto, haz una lista:\nlst &lt;- list(numeros = c(1, 2), logicos = TRUE, caracteres = c(\"a\", \"b\", \"c\"))\nlst\n## $numeros\n## [1] 1 2\n\n## $logicos\n## [1] TRUE\n\n## $caracteres\n## [1] \"a\" \"b\" \"c\"\nY luego obten el subconjunto:\nlst[1]\n## $numeros\n## [1] 1 2\nEl resultado es una lista más pequeña con un elemento. Ese elemento es el vector c(1, 2). Esto puede resultar molesto porque muchas funciones de R no funcionan con listas. Por ejemplo, sum(lst[1]) devolverá un error. Sería horrible si una vez que almacena un vector en una lista, solo pudiera recuperarlo como una lista:\nsum(lst[1])\n## Error in sum(lst[1]) : invalid 'type' (list) of argument\nCuando usa la notación $, R devolverá los valores seleccionados tal como son, sin una estructura de lista a su alrededor:\nlst$numeros\n## 1 2\nLuego puede enviar inmediatamente los resultados a una función:\nsum(lst$numeros)\n## 3\nSi los elementos de su lista no tienen nombres (o no desea usar los nombres), puede usar dos corchetes, en lugar de uno, para crear un subconjunto de la lista. Esta notación hará lo mismo que la notación $:\nlst[[1]]\n## 1 2\nEn otras palabras, si crea un subconjunto de una lista con notación de corchete único, R devolverá una lista más pequeña. Si crea un subconjunto de una lista con notación de corchetes dobles, R devolverá solo los valores que estaban dentro de un elemento de la lista. Puede combinar esta función con cualquiera de los métodos de indexación de R:\nlst[\"numeros\"]\n## $numeros\n## [1] 1 2\n\nlst[[\"numeros\"]]\n## 1 2\nEsta diferencia es sutil pero importante. En la comunidad de R, hay una forma popular y útil de pensar en ello, Figure Figura 4.3. Imagina que cada lista es un tren y cada elemento es un vagón de tren. Cuando usa corchetes individuales, R selecciona vagones de tren individuales y los devuelve como un tren nuevo. Cada vagón mantiene su contenido, pero ese contenido todavía está dentro de un vagón de tren (es decir, una lista). Cuando usa corchetes dobles, R en realidad descarga el automóvil y le devuelve el contenido.\n\n\n\n\n\n\n\nFigura 4.3: Puede ser útil pensar en su lista como un tren. Use corchetes simples para seleccionar vagones de tren, corchetes dobles para seleccionar el contenido dentro de un vagón.\n\n\n\n\n\n\n\n\n\n\nNunca use attach\nEn los primeros días de R, se hizo popular usar attach() en un conjunto de datos una vez que lo tenía cargado. ¡No hagas esto! attach recrea un entorno informático similar a los utilizados en otras aplicaciones estadísticas como Stata y SPSS, que gustaron a los usuarios cruzados. Sin embargo, R no es Stata o SPSS. R está optimizado para usar el entorno informático de R, y ejecutar attach() puede causar confusión con algunas funciones de R.\n¿Qué hace attach()? En la superficie, attach te ahorra escribir. Si adjunta el conjunto de datos mazo, puede hacer referencia a cada una de sus variables por nombre; en lugar de escribir mazo$cara, puedes simplemente escribir cara. Pero escribir no está mal. Te da la oportunidad de ser explícito, y en la programación de computadoras, explícito es bueno. Adjuntar un conjunto de datos crea la posibilidad de que R confunda dos nombres de variables. Si esto ocurre dentro de una función, es probable que obtenga resultados inutilizables y un mensaje de error inútil para explicar lo que sucedió.\n\n\n\nAhora que es un experto en recuperar valores almacenados en R, resumamos lo que ha logrado.",
    "crumbs": [
      "Proyecto 2: Baraja de Cartas",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Notación de R</span>"
    ]
  },
  {
    "objectID": "notation.html#resumen",
    "href": "notation.html#resumen",
    "title": "4  Notación de R",
    "section": "\n4.5 Resumen",
    "text": "4.5 Resumen\nHa aprendido a acceder a los valores que se han almacenado en R. Puede recuperar una copia de los valores que viven dentro de un data frame y usar las copias para nuevos cálculos.\nDe hecho, puede usar el sistema de notación de R para acceder a valores en cualquier objeto R. Para usarlo, escriba el nombre de un objeto seguido de corchetes e índices. Si su objeto es unidimensional, como un vector, solo necesita proporcionar un índice. Si es bidimensional, como un data frame, debe proporcionar dos índices separados por una coma. Y, si es n-dimensional, debe proporcionar n índices, cada uno separado por una coma.\nEn Modificación de Valores, llevará este sistema un paso más allá y aprenderá a cambiar los valores reales que se almacenan dentro de su data frame. Todo esto se suma a algo especial: control completo de sus datos. Ahora puede almacenar sus datos en su computadora, recuperar valores individuales a voluntad y usar su computadora para realizar cálculos correctos con esos valores.\n¿Suena esto básico? Puede serlo, pero también es poderoso y esencial para una ciencia de datos eficiente. Ya no necesitas memorizar todo en tu cabeza, ni preocuparte por hacer mal el cálculo mental. Este control de bajo nivel sobre sus datos también es un requisito previo para programas de R más eficientes, el tema del Proyecto 3: Máquina Tragamonedas.",
    "crumbs": [
      "Proyecto 2: Baraja de Cartas",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Notación de R</span>"
    ]
  },
  {
    "objectID": "modifying.html",
    "href": "modifying.html",
    "title": "5  Modificación de Valores",
    "section": "",
    "text": "¿Estás listo para jugar algunos juegos con tu mazo virtual? ¡No tan rápido! El sistema de puntos en su mazo de cartas no se alinea bien con muchos juegos de cartas. Por ejemplo, en la guerra y el póquer, los ases suelen tener una puntuación más alta que los reyes. Tendrían un valor en puntos de 14, no de 1.\nEn esta tarea, cambiará el sistema de puntos de su mazo tres veces para que coincida con tres juegos diferentes: guerra, corazones y blackjack. Cada uno de estos juegos te enseñará algo diferente sobre cómo modificar los valores dentro de un conjunto de datos. Comience por hacer una copia de mazo que pueda manipular. Esto asegurará que siempre tenga una copia impecable de mazo a la que recurrir (en caso de que las cosas salgan mal):\nmazo2 &lt;- mazo\n\n5.0.1 Cambio de Valores en el Lugar\nPuede usar el sistema de notación de R para modificar valores dentro de un objeto de R. Primero, describa el valor (o valores) que desea modificar. Luego use el operador de asignación &lt;- para sobrescribir esos valores. R actualizará los valores seleccionados en el objeto original. Pongamos esto en práctica con un ejemplo real:\nvec &lt;- c(0, 0, 0, 0, 0, 0)\nvec\n##  0 0 0 0 0 0\nAsí es como puede seleccionar el primer valor de vec:\nvec[1]\n##  0\nY así es como puedes modificarlo:\nvec[1] &lt;- 1000\nvec\n## 1000    0    0    0    0    0\nPuede reemplazar varios valores a la vez siempre que la cantidad de valores nuevos sea igual a la cantidad de valores seleccionados:\nvec[c(1, 3, 5)] &lt;- c(1, 1, 1)\nvec\n##  1 0 1 0 1 0\n\nvec[4:6] &lt;- vec[4:6] + 1\nvec\n## 1 0 1 1 2 1\nTambién puede crear valores que aún no existen en su objeto. R expandirá el objeto para acomodar los nuevos valores:\nvec[7] &lt;- 0\nvec\n## 1 0 1 1 2 1 0\nEsto proporciona una excelente manera de agregar nuevas variables a su conjunto de datos:\nmazo2$nuevo &lt;- 1:52\n\nhead(mazo2)\n##   cara  palo valor nuevo\n##    rey picas    13   1\n##  reina picas    12   2\n##   jota picas    11   3\n##   diez picas    10   4\n##  nueve picas     9   5\n##   ocho picas     8   6\nTambién puede eliminar columnas de un data frame (y elementos de una lista) asignándoles el símbolo NULL:\nmazo2$nuevo &lt;- NULL\n\nhead(mazo2)\n##   cara  palo valor \n##    rey picas    13\n##  reina picas    12\n##   jota picas    11\n##   diez picas    10\n##  nueve picas     9\n##   ocho picas     8\nEn el juego de la guerra, los ases son el rey (en sentido figurado). Reciben el valor más alto de todas las cartas, que sería algo así como 14. Todas las demás cartas obtienen el valor que ya tienen en el mazo. Para jugar a la guerra, solo necesitas cambiar los valores de tus ases del 1 al 14.\nSiempre que no hayas barajado tu mazo, sabes dónde están los ases. Aparecen cada 13 cartas. Por lo tanto, puede describirlos con el sistema de notación de R:\nmazo2[c(13, 26, 39, 52), ]\n##  cara      palo valor\n##    as     picas     1\n##    as  treboles     1\n##    as diamantes     1\n##    as corazones     1\nPuede seleccionar solo los valores de los ases subdividiendo la dimensión de las columnas de mazo2. O, mejor aún, puede crear un subconjunto del vector de columna mazo2$valor:\nmazo2[c(13, 26, 39, 52), 3]\n## 1 1 1 1\n\nmazo2$valor[c(13, 26, 39, 52)]\n## 1 1 1 1\nAhora todo lo que tiene que hacer es asignar un nuevo conjunto de valores a estos valores antiguos. El conjunto de valores nuevos deberá tener el mismo tamaño que el conjunto de valores que está reemplazando. Por lo tanto, podría guardar c(14, 14, 14, 14) en los valores as, o simplemente podría guardar 14 y confiar en las reglas de reciclaje de R para expandir 14 a c(14, 14, 14, 14):\nmazo2$valor[c(13, 26, 39, 52)] &lt;- c(14, 14, 14, 14)\n\n# or\n\nmazo2$valor[c(13, 26, 39, 52)] &lt;- 14\nObserve que los valores cambian en su lugar. No terminas con una copia modificada de mazo2; los nuevos valores aparecerán dentro de mazo2:\nhead(mazo2, 13)\n##   cara  palo valor\n##    rey picas    13\n##  reina picas    12\n##   jota picas    11\n##   diez picas    10\n##  nueve picas     9\n##   ocho picas     8\n##  siete picas     7\n##   seis picas     6\n##  cinco picas     5\n## cuatro picas     4\n##   tres picas     3\n##    dos picas     2\n##     as picas    14\nLa misma técnica funcionará ya sea que almacene sus datos en un vector, matriz, arreglo, lista o data frame. Simplemente describa los valores que desea cambiar con el sistema de notación de R, luego asigne sobre esos valores con el operador de asignación de R.\nLas cosas funcionaron muy fácilmente en este ejemplo porque sabías exactamente dónde estaba cada as. Las cartas se ordenaron de manera ordenada y apareció un as cada 13 filas.\nPero, ¿y si se hubiera barajado la baraja? Podrías mirar todas las cartas y anotar las ubicaciones de los ases, pero eso sería tedioso. Si su data frame fuera más grande, podría ser imposible:\nmazo3 &lt;- barajar(mazo)\n¿Dónde están los ases ahora?\nhead(mazo3)\n##  cara      palo valor\n## reina  treboles    12\n##   rey  treboles    13\n##    as     picas     1   # un as\n## nueve  treboles     9\n## siete     picas     7\n## reina diamantes    12\n¿Por qué no pedirle a R que encuentre los ases por ti? Puede hacer esto con subconjuntos lógicos. La creación de subconjuntos lógicos proporciona una forma de realizar una extracción y modificación específicas con objetos R, una especie de misión de búsqueda y destrucción dentro de sus propios conjuntos de datos.\n\n5.0.2 Subconjunto Lógico\n¿Recuerdas el sistema de índice lógico de R, lógicos? Para recapitular, puede seleccionar valores con un vector de TRUE y FALSE. El vector debe tener la misma longitud que la dimensión que desea dividir en subconjuntos. R devolverá todos los elementos que coincidan con un VERDADERO:\nvec\n## 1 0 1 1 2 1 0\n\nvec[c(FALSE, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE)]\n## 2\nA primera vista, este sistema puede parecer poco práctico. ¿Quién quiere escribir largos vectores de TRUE y FALSE? Nadie. Pero no tienes que hacerlo. Puede dejar que una prueba lógica cree un vector de VERDADEROS y FALSOS para usted.\n\n5.0.2.1 Pruebas Lógicas\nUna prueba lógica es una comparación como “¿es uno menos que dos?”, 1 &lt; 2 o “¿tres son mayores que cuatro?”, 3 &gt; 4. R proporciona siete operadores lógicos que puede usar para hacer comparaciones, que se muestran en la tabla Tabla 5.1.\n\n\nTabla 5.1: Operadores Lógicos de R\n\n\n\nOperador\nSintaxis\nPruebas\n\n\n\n&gt;\na &gt; b\n¿Es a mayor que b?\n\n\n&gt;=\na &gt;= b\n¿Es a mayor que o igual que b?\n\n\n&lt;\na &lt; b\n¿Es a menor que b?\n\n\n&lt;=\na &lt;= b\n¿Es a menor que o igual que b?\n\n\n==\na == b\n¿Es a igual que b?\n\n\n!=\na != b\n¿Es a distinto que b?\n\n\n%in%\na %in% c(a, b, c)\n¿Es a en el grupo c(a, b, c)?\n\n\n\n\n\n\nCada operador devuelve un TRUE o un FALSE. Si usa un operador para comparar vectores, R hará comparaciones por elementos, tal como lo hace con los operadores aritméticos:\n1 &gt; 2\n## FALSE\n\n1 &gt; c(0, 1, 2)\n## TRUE FALSE FALSE\n\nc(1, 2, 3) == c(3, 2, 1)\n## FALSE  TRUE FALSE\n%in% es el único operador que no realiza una ejecución normal de elementos. %in% comprueba si los valores del lado izquierdo están en el vector del lado derecho. Si proporciona un vector en el lado izquierdo, %in% no emparejará los valores de la izquierda con los valores de la derecha y luego realizará pruebas por elementos. En su lugar, %in% probará de forma independiente si cada valor de la izquierda está en algún lugar en el vector de la derecha:\n1 %in% c(3, 4, 5)\n## FALSE\n\nc(1, 2) %in% c(3, 4, 5)\n## FALSE FALSE\n\nc(1, 2, 3) %in% c(3, 4, 5)\n## FALSE FALSE  TRUE\n\nc(1, 2, 3, 4) %in% c(3, 4, 5)\n## FALSE FALSE  TRUE  TRUE\nTenga en cuenta que comprueba la igualdad con un signo igual doble, ==, y no con un solo signo igual, =, que es otra forma de escribir &lt;-. Es fácil olvidar y usar a = b para probar si a es igual a b. Desafortunadamente, te llevarás una desagradable sorpresa. R no devolverá un TRUE o FALSE, porque no tendrá que hacerlo: a será igual a b, porque acabas de ejecutar el equivalente de a &lt;- b.\n\n\n\n\n\n\n= es un operador de asignación\nTenga cuidado de no confundir = con ==. = hace lo mismo que &lt;-: asigna un valor a un objeto.\n\n\n\nPuede comparar dos objetos R cualquiera con un operador lógico; sin embargo, los operadores lógicos tienen más sentido si compara dos objetos del mismo tipo de datos. Si compara objetos de diferentes tipos de datos, R usará sus reglas de coerción para forzar los objetos al mismo tipo antes de realizar la comparación.\nEjercicio 7.1 ¿Cuántas ases? Extraiga la columna cara de mazo2 y pruebe si cada valor es igual a as. Como desafío, use R para contar rápidamente cuántas cartas son iguales a as.\nSolución. Puede extraer la columna cara con la notación $ de R:\nmazo2$cara\n##  \"rey\"  \"reina\" \"jota\"  \"diez\"   \"nueve\" \n##  \"ocho\" \"siete\" \"seis\"   \"cinco\"  \"cuatro\" \n##  \"tres\" \"dos\"   \"as\" \"rey\"  \"reina\"\n##  \"jota\"  \"diez\"   \"nueve\"  \"ocho\" \"siete\"\n##  \"seis\"   \"cinco\"  \"cuatro\"  \"tres\" \"dos\"  \n##  \"as\"   \"rey\"  \"reina\" \"jota\"  \"diez\"  \n##  \"nueve\"  \"ocho\" \"siete\" \"seis\"   \"cinco\" \n##  \"cuatro\"  \"tres\" \"dos\"   \"as\"   \"rey\" \n##  \"reina\" \"jota\"  \"diez\"   \"nueve\"  \"ocho\"\n##  \"siete\" \"seis\"   \"cinco\"  \"cuatro\"  \"tres\"\n##  \"dos\"   \"as\"\nA continuación, puede utilizar el operador == para probar si cada valor es igual a as. En el siguiente código, R usará sus reglas de reciclaje para comparar individualmente cada valor de mazo2$cara con \"as\". Tenga en cuenta que las comillas son importantes. Si los omite, R intentará encontrar un objeto llamado as para compararlo con mazo2$cara:\nmazo2$cara == \"as\"\n##  FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n##  FALSE FALSE FALSE FALSE FALSE  TRUE FALSE\n##  FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n##  FALSE FALSE FALSE FALSE  TRUE FALSE FALSE\n##  FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n##  FALSE FALSE FALSE  TRUE FALSE FALSE FALSE\n##  FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n##  FALSE FALSE  TRUE\nPuede usar sum para contar rápidamente el número de TRUE en el vector anterior. Recuerde que R convertirá los lógicos en numéricos cuando haga operaciones matemáticas con ellos. R convertirá TRUE en unos y FALSE en ceros. Como resultado, sum contará el número de TRUE:\nsum(mazo2$cara == \"as\")\n## 4\nPuede usar este método para detectar y luego cambiar los ases en su mazo, incluso si ha barajado sus cartas. Primero, crea una prueba lógica que identifique los ases en tu baraja barajada:\nmazo3$cara == \"as\"\nLuego use la prueba para seleccionar los valores de puntos as. Dado que la prueba devuelve un vector lógico, puede usarlo como índice:\nmazo3$valor[mazo3$cara == \"as\"]\n##  1 1 1 1\nFinalmente, usa la asignación para cambiar los valores de as en mazo3:\nmazo3$valor[mazo3$cara == \"as\"] &lt;- 14\n\nhead(mazo3)\n##  cara      palo valor\n## queen  treboles    12\n##   rey  treboles    13\n##    as     picas    14  # un as\n## nueve  treboles     9\n## siete     picas     7\n## reina diamantes    12\nPara resumir, puede usar una prueba lógica para seleccionar valores dentro de un objeto.\nLa creación de subconjuntos lógicos es una técnica poderosa porque le permite identificar, extraer y modificar rápidamente valores individuales en su conjunto de datos. Cuando trabaja con subconjuntos lógicos, no necesita saber dónde en su conjunto de datos existe un valor. Solo necesita saber cómo describir el valor con una prueba lógica.\nEl subconjunto lógico es una de las cosas que R hace mejor. De hecho, el subconjunto lógico es un componente clave de la programación vectorizada, un estilo de codificación que le permite escribir código R rápido y eficiente, que estudiaremos en Velocidad.\nUsemos subconjuntos lógicos con un nuevo juego: corazones. En corazones, cada carta tiene un valor de cero:\nmazo4 &lt;- mazo\nmazo4$valor &lt;- 0\n\nhead(mazo4, 13)\n##   cara  palo valor\n##    rey picas     0\n##  reina picas     0\n##   jota picas     0\n##   diez picas     0\n##  nueve picas     0\n##   ocho picas     0\n##  siete picas     0\n##   seis picas     0\n##  cinco picas     0\n## cuatro picas     0\n##   tres picas     0\n##    dos picas     0\n##     as picas     0\nexcepto las cartas del palo de corazones y la reina de picas. Cada carta del palo de corazones tiene un valor de 1. ¿Puedes encontrar estas cartas y reemplazar sus valores? Intentalo.\nEjercicio 7.2 (Dar Valor al Mazo para el Juego Corazones) Asigne un valor de 1 a cada carta en mazo4 que tenga un palo de corazones.\nSolución. Para hacer esto, primero escribe una prueba que identifique las cartas en el palo corazones:\nmazo4$palo == \"corazones\"\n##  FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n##  FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n##  FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n##  FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n##  FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n##  FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE\n##   TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n##   TRUE  TRUE  TRUE\nLuego usa tu prueba para seleccionar los valores de estas cartas:\nmazo4$valor[mazo4$palo == \"corazones\"]\n## 0 0 0 0 0 0 0 0 0 0 0 0 0\nFinalmente, asigne un nuevo número a estos valores:\nmazo4$valor[mazo4$palo == \"corazones\"] &lt;- 1\nAhora todas sus cartas de corazones han sido actualizadas:\nmazo4$valor[mazo4$palo == \"corazones\"]\n## 1 1 1 1 1 1 1 1 1 1 1 1 1\nEn corazones, la reina de picas tiene el valor más inusual de todos: vale 13 puntos. Debería ser sencillo cambiar su valor, pero es sorprendentemente difícil de encontrar. Podrías encontrar todas las reinas:\nmazo4[mazo4$cara == \"reina\", ]\n##   cara      palo valor\n##  reina     picas     0\n##  reina  treboles     0\n##  reina diamantes     0\n##  reina corazones     1\nPero son tres cartas de más. Por otro lado, podrías encontrar todas las cartas en picas:\nmazo4[mazo4$palo == \"picas\", ]\n##   cara  palo valor\n##    rey picas     0\n##  reina picas     0\n##   jota picas     0\n##   diez picas     0\n##  nueve picas     0\n##   ocho picas     0\n##  siete picas     0\n##   seis picas     0\n##  cinco picas     0\n## cuatro picas     0\n##   tres picas     0\n##    dos picas     0\n##     as picas     0\nPero son 12 cartas de más. Lo que realmente quiere encontrar es todas las cartas que tienen un valor de cara igual a la reina y un valor del palo igual a las picas. Puede hacerlo con un operador booleano. Los operadores booleanos combinan varias pruebas lógicas en una sola prueba.\n\n5.0.2.2 Operadores Booleanos\nLos operadores booleanos son cosas como y (&) y o (|). Colapsan los resultados de múltiples pruebas lógicas en un solo TRUE o FALSE. R tiene seis operadores booleanos, que se muestran en la tabla Tabla 5.2.\n\n\nTabla 5.2: Operadores Booleanos\n\n\n\n\n\n\n\n\nOperador\nSintaxis\nPruebas\n\n\n\n&\ncond1 & cond2\n¿Son verdaderas cond1 y cond2?\n\n\n|\ncond1 | cond2\n¿Es verdadera una o más de cond1 ycond2?\n\n\nxor\nxor(cond1, cond2)\n¿Es exactamente una de cond1 y cond2 verdadera?\n\n\n!\n!cond1\n¿Es cond1 falsa? (por ejemplo, ! invierte los resultados de una prueba lógica)\n\n\nany\nany(cond1, cond2, cond3, ...)\n¿Alguna de las condiciones es verdadera?\n\n\nall\nall(cond1, cond2, cond3, ...)\n¿Son verdaderas todas las condiciones?\n\n\n\n\n\n\nPara usar un operador booleano, colóquelo entre dos pruebas lógicas completas. R ejecutará cada prueba lógica y luego usará el operador booleano para combinar los resultados en un solo TRUE o FALSE, figura Figura 5.1.\n\n\n\n\n\n\nEl error más común con los operadores Booleanos\nEs fácil olvidar poner una prueba completa a cada lado de un operador booleano. En español, es eficiente decir “¿Es x mayor que dos y menor que nueve?” Pero en R, necesitas escribir el equivalente de “¿Es x mayor que dos y es x menor que nueve?” Esto se muestra en la Figura Figura 5.1.\n\n\n\n\n\n\n\n\n\n\nFigura 5.1: R evaluará las expresiones en cada lado de un operador booleano por separado y luego combinará los resultados en un solo TRUE o FALSE. Si no proporciona una prueba completa a cada lado del operador, R devolverá un error.\n\n\n\n\nCuando se usan con vectores, los operadores booleanos seguirán la misma ejecución de elementos que los operadores aritméticos y lógicos:\na &lt;- c(1, 2, 3)\nb &lt;- c(1, 2, 3)\nc &lt;- c(1, 2, 4)\n\na == b\n##  TRUE TRUE TRUE\n\nb == c\n##  TRUE  TRUE FALSE\n\na == b & b == c\n##  TRUE  TRUE FALSE\n¿Podría usar un operador booleano para ubicar la reina de picas en su mazo? Por supuesto que puede. Desea probar cada carta para ver si es tanto una reina como una pica. Puedes escribir esta prueba en R con:\nmazo4$cara == \"reina\" & mazo4$palo == \"picas\"\n##  FALSE  TRUE FALSE FALSE FALSE FALSE FALSE\n##  FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n##  FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n##  FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n##  FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n##  FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n##  FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n##  FALSE FALSE FALSE\nGuardaré los resultados de esta prueba en su propio objeto. Eso hará que sea más fácil trabajar con los resultados:\nreinaDePicas &lt;- mazo4$cara == \"reina\" & mazo4$palo == \"picas\"\nA continuación, puede utilizar la prueba como índice para seleccionar el valor de la reina de picas. Asegúrese de que la prueba realmente seleccione el valor correcto:\nmazo4[reinaDePicas, ]\n##  cara  palo valor\n## reina picas     0\n\nmazo4$valor[reinaDePicas]\n## 0\nAhora que encontraste la reina de picas, puedes actualizar su valor:\nmazo4$valor[reinaDePicas] &lt;- 13\n\nmazo4[reinaDePicas, ]\n##  cara  palo valor\n## reina picas    13\nTu mazo está listo para jugar corazones.\nEjercicio 7.3 (Practica con Pruebas) Si cree que domina las pruebas lógicas, intente convertir estas oraciones en pruebas escritas con código R. Para ayudarte, he definido algunos objetos de R después de las oraciones que puedes usar para probar tus respuestas:\n\n¿Es w positivo?\n¿Es x mayor que 10 y menor que 20?\n¿Es objeto y la palabra Febrero?\n¿Son todos los valores de z un día de la semana?\n\nw &lt;- c(-1, 0, 1)\nx &lt;- c(5, 15)\ny &lt;- \"Febrero\"\nz &lt;- c(\"Lunes\", \"Martes\", \"Viernes\")\nSolución. Aquí hay algunas respuestas de ejemplo. Si se quedó atascado, asegúrese de volver a leer cómo R evalúa las pruebas lógicas que usan valores booleanos:\nw &gt; 0\n10 &lt; x & x &lt; 20\ny == \"Febrero\"\nall(z %in% c(\"Lunes\", \"Martes\", \"Miercoles\", \"Jueves\", \"Viernes\", \n  \"Sabado\", \"Domingo\"))\nConsideremos un último juego, el blackjack. En el blackjack, cada carta numérica tiene un valor igual a su valor nominal. Cada figura (rey, reina o jota) tiene un valor de 10. Finalmente, cada as tiene un valor de 11 o 1, dependiendo de los resultados finales del juego.\nComencemos con una copia nueva de mazo; de esa manera, las cartas numéricas (dos a diez) comenzarán con el valor correcto:\nmako5 &lt;- mazo\n\nhead(mazo5, 13)\n##    rey picas    13\n##  reina picas    12\n##   jota picas    11\n##   diez picas    10\n##  nueve picas     9\n##   ocho picas     8\n##  siete picas     7\n##   seis picas     6\n##  cinco picas     5\n## cuatro picas     4\n##   tres picas     3\n##    dos picas     2\n##     as picas     1\nPuedes cambiar el valor de las figuras de una sola vez con %in%:\ncaracartas &lt;- mazo5$cara %in% c(\"rey\", \"reina\", \"jota\")\n\nmazo5[caracartas, ]\n##   cara      palo valor\n##    rey     picas    13\n##  reina     picas    12\n##   jota     picas    11\n##    rey  treboles    13\n##  reina  treboles    12\n##   jota  treboles    11\n##    rey diamantes    13\n##  reina diamantes    12\n##   jota diamantes    11\n##    rey corazones    13\n##  reina corazones    12\n##   jota corazones    11\n\nmazo5$valor[caracartas] &lt;- 10\n\nhead(mazo5, 13)\n##   cara   palo valor\n##    rey picas    10\n##  reina picas    10\n##   jota picas    10\n##   diez picas    10\n##  nueve picas     9\n##   ocho picas     8\n##  siete picas     7\n##   seis picas     6\n##  cinco picas     5\n## cuatro picas     4\n##   tres picas     3\n##    dos picas     2\n##     as picas     1\nAhora solo necesita corregir los valores de as, ¿o no? Es difícil decidir qué valor dar a los ases porque su valor exacto cambiará de una mano a otra. Al final de cada mano, un as será igual a 11 si la suma de las cartas del jugador no supera los 21. De lo contrario, el as será igual a 1. El valor real del as dependerá de las otras cartas en la mano del jugador. Este es un caso de falta de información. Por el momento, no tiene suficiente información para asignar un valor de puntos correcto a las cartas de as.\n\n5.0.3 Información Faltante\nLos problemas de falta de información ocurren con frecuencia en la ciencia de datos. Por lo general, son más sencillos: no conoce un valor porque la medida se perdió, se corrompió o nunca se tomó para empezar. R tiene una manera de ayudarlo a administrar estos valores faltantes.\nEl carácter NA es un símbolo especial en R. Significa “no disponible” y se puede utilizar como marcador de posición para la información que falta. R tratará a NA exactamente como usted debería querer que se trate la información faltante. Por ejemplo, ¿qué resultado esperaría si suma 1 a la información que falta?\n1 + NA\n## NA\nR devolverá una segunda pieza de información faltante. No sería correcto decir que 1 + NA = 1 porque existe una buena posibilidad de que la cantidad que falta no sea cero. No tienes suficiente información para determinar el resultado.\n¿Qué pasa si prueba si una parte de la información que falta es igual a 1?\nNA == 1\n## NA\nNuevamente, su respuesta sería algo como “No sé si esto es igual a uno”, es decir, NA. Generalmente, los NA se propagarán cada vez que los use en una operación o función de R. Esto puede evitar que cometa errores basados en datos faltantes.\n\n5.0.3.1 na.rm\nLos valores faltantes pueden ayudarlo a solucionar los agujeros en sus conjuntos de datos, pero también pueden crear algunos problemas frustrantes. Suponga, por ejemplo, que ha recopilado 1.000 pases:[observaciones] y desea tomar su promedio con la función mean de R. Si incluso uno de los valores es NA, su resultado será NA:\nc(NA, 1:50)\n## NA  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16\n## 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33\n## 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50\n\nmean(c(NA, 1:50))\n## NA\nEs comprensible que prefieras un comportamiento diferente. La mayoría de las funciones de R vienen con el argumento opcional, na.rm, que significa remove los NA. R ignorará NAs cuando evalúa una función si agrega el argumento na.rm = TRUE:\nmean(c(NA, 1:50), na.rm = TRUE)\n## 25.5\n\n5.0.3.2 is.na\nEn ocasiones, es posible que desee identificar las NA en su conjunto de datos con una prueba lógica, pero eso también crea un problema. ¿Cómo lo harías? Si algo es un valor faltante, cualquier prueba lógica que lo use devolverá un valor faltante, incluso esta prueba:\nNA == NA\n## NA\nLo que significa que pruebas como esta no te ayudarán a encontrar valores faltantes:\nc(1, 2, 3, NA) == NA\n## NA NA NA NA\nPero no te preocupes demasiado; R proporciona una función especial que puede probar si un valor es un NA. La función se llama sensatamente is.na:\nis.na(NA)\n## TRUE\n\nvec &lt;- c(1, 2, 3, NA)\nis.na(vec)\n## FALSE FALSE FALSE  TRUE\nEstablezcamos todos sus valores de as en NA. Esto logrará dos cosas. Primero, te recordará que no sabes el valor final de cada as. En segundo lugar, evitará que anotes accidentalmente una mano que tenga un as antes de determinar el valor final del as.\nPuede establecer sus valores de as en NA de la misma manera que los establecería en un número:\nmazo5$valor[mazo5$cara == \"as\"] &lt;- NA\n\nhead(mazo5, 13)\n##   cara   palo valor\n##    rey picas    10\n##  reina picas    10\n##   jota picas    10\n##   diez picas    10\n##  nueve picas     9\n##   ocho picas     8\n##  siete picas     7\n##   seis picas     6\n##  cinco picas     5\n## cuatro picas     4\n##   tres picas     3\n##    dos picas     2\n##     as picas    NA\nFelicidades. Su mazo ahora está listo para un juego de blackjack.\n\n5.0.4 Resumen\nPuede modificar valores en su lugar dentro de un objeto de R cuando combina la sintaxis de notación de R con el operador de asignación, &lt;-. Esto le permite actualizar sus datos y limpiar sus conjuntos de datos.\nCuando trabaja con grandes conjuntos de datos, modificar y recuperar valores crea un problema logístico propio. ¿Cómo puede buscar en los datos para encontrar los valores que desea modificar o recuperar? Como usuario de R, puede hacer esto con subconjuntos lógicos. Cree una prueba lógica con operadores lógicos y booleanos y luego use la prueba como un índice en la notación de paréntesis de R. R devolverá los valores que está buscando, incluso si no sabe dónde están.\nRecuperar valores individuales no será su única preocupación como programador de R. También deberá recuperar conjuntos de datos completos; por ejemplo, puede llamar a uno en una función. Entornos le enseñará cómo R busca y guarda conjuntos de datos y otros objetos R en su sistema de entorno. Luego usará este conocimiento para corregir las funciones repartir y barajar.",
    "crumbs": [
      "Proyecto 2: Baraja de Cartas",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Modificación de Valores</span>"
    ]
  },
  {
    "objectID": "environments.html",
    "href": "environments.html",
    "title": "6  Entornos",
    "section": "",
    "text": "6.1 Entornos\nSu mazo ahora está listo para un juego de blackjack (o de corazones o de guerra), pero ¿sus funciones de barajar y repartir están a la altura? Definitivamente no. Por ejemplo, repartir reparte la misma carta una y otra vez:\nY la función barajar en realidad no baraja el mazo (devuelve una copia del mazo que se ha barajado). En resumen, ambas funciones usan mazo, pero ninguna manipula mazo, y nos gustaría que lo hicieran.\nPara corregir estas funciones, deberá aprender cómo R almacena, busca y manipula objetos como mazo. R hace todas estas cosas con la ayuda de un sistema de entorno.\nConsidere por un momento cómo su computadora almacena archivos. Cada archivo se guarda en una carpeta y cada carpeta se guarda en otra carpeta, lo que forma un sistema de archivos jerárquico. Si su computadora quiere abrir un archivo, primero debe buscar el archivo en este sistema de archivos.\nPuede ver su sistema de archivos abriendo una ventana del buscador. Por ejemplo, la figura Figura 6.1 muestra parte del sistema de archivos de mi computadora. Tengo toneladas de carpetas. Dentro de uno de ellos hay una subcarpeta llamada Documentos, dentro de esa subcarpeta hay una subsubcarpeta llamada ggsubplot, dentro de esa carpeta hay una carpeta llamada inst, dentro de esa subcarpeta hay una carpeta llamada doc, y dentro de eso hay un archivo llamado manual .pdf.\nFigura 6.1: Su computadora organiza los archivos en una jerarquía de carpetas y subcarpetas. Para mirar un archivo, necesita encontrar dónde está guardado en el sistema de archivos.\nR usa un sistema similar para guardar objetos de R. Cada objeto se guarda dentro de un entorno, un objeto similar a una lista que se asemeja a una carpeta en su computadora. Cada entorno está conectado a un entorno principal, un entorno de nivel superior, que crea una jerarquía de entornos.\nPuede ver el sistema de entorno de R con la función parenvs en el paquete pryr (tenga en cuenta que parenvs venía en el paquete pryr cuando este libro se publicó por primera vez). parenvs(all = TRUE) devolverá una lista de los entornos que utiliza su sesión de R. El resultado real variará de una sesión a otra según los paquetes que haya cargado. Aquí está el resultado de mi sesión actual:\nSe necesita algo de imaginación para interpretar este resultado, así que visualicemos los entornos como un sistema de carpetas, Figura Figura 6.2. Puedes pensar en el árbol del entorno de esta manera. El entorno de nivel más bajo se llama R_GlobalEnv y se guarda dentro de un entorno llamado package:pryr, que se guarda dentro del entorno llamado 0x7fff3321c388, y así sucesivamente, hasta llegar al entorno final de más alto nivel. R_EmptyEnv. R_EmptyEnv es el único entorno de R que no tiene un entorno principal.\nFigura 6.2: R almacena objetos de R en un árbol de entorno que se asemeja al sistema de carpetas de su computadora.\nRecuerde que este ejemplo es solo una metáfora. Los entornos de R existen en su memoria RAM y no en su sistema de archivos. Además, los entornos de R técnicamente no se guardan uno dentro de otro. Cada entorno está conectado a un entorno principal, lo que facilita la búsqueda en el árbol de entornos de R. Pero esta conexión es unidireccional: no hay forma de mirar un entorno y decir cuáles son sus “hijos”. Por lo tanto, no puede buscar en el árbol de entorno de R. Sin embargo, en otras formas, el sistema de entorno de R funciona de manera similar a un sistema de archivos.",
    "crumbs": [
      "Proyecto 2: Baraja de Cartas",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Entornos</span>"
    ]
  },
  {
    "objectID": "environments.html#entornos",
    "href": "environments.html#entornos",
    "title": "6  Entornos",
    "section": "",
    "text": "library(pryr)\nparenvs(all = TRUE)\n##    label                            name               \n## 1  &lt;environment: R_GlobalEnv&gt;       \"\"                 \n## 2  &lt;environment: package:pryr&gt;  \"package:pryr\" \n## 3  &lt;environment: 0x7fff3321c388&gt;    \"tools:rstudio\"    \n## 4  &lt;environment: package:stats&gt;     \"package:stats\"    \n## 5  &lt;environment: package:graphics&gt;  \"package:graphics\" \n## 6  &lt;environment: package:grDevices&gt; \"package:grDevices\"\n## 7  &lt;environment: package:utils&gt;     \"package:utils\"    \n## 8  &lt;environment: package:datasets&gt;  \"package:datasets\" \n## 9  &lt;environment: package:methods&gt;   \"package:methods\"  \n## 10 &lt;environment: 0x7fff3193dab0&gt;    \"Autoloads\"        \n## 11 &lt;environment: base&gt;              \"\"                 \n## 12 &lt;environment: R_EmptyEnv&gt;        \"\"",
    "crumbs": [
      "Proyecto 2: Baraja de Cartas",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Entornos</span>"
    ]
  },
  {
    "objectID": "environments.html#trabajar-con-entornos",
    "href": "environments.html#trabajar-con-entornos",
    "title": "6  Entornos",
    "section": "\n6.2 Trabajar con Entornos",
    "text": "6.2 Trabajar con Entornos\nR viene con algunas funciones de ayuda que puede usar para explorar su árbol de entorno. Primero, puede referirse a cualquiera de los entornos en su árbol con as.environment. as.environment toma un nombre de entorno (como una cadena de caracteres) y devuelve el entorno correspondiente:\nas.environment(\"package:stats\")\n## &lt;environment: package:stats&gt;\n## attr(,\"name\")\n## [1] \"package:stats\"\n## attr(,\"path\")\n## [1] \"/Library/Frameworks/R.framework/Versions/3.0/Resources/library/stats\"\nTres entornos en su árbol también vienen con sus propias funciones de acceso. Estos son el entorno global (R_GlobalEnv), el entorno base (base) y el entorno vacío (R_EmptyEnv). Puedes referirte a ellos con:\nglobalenv()\n## &lt;environment: R_GlobalEnv&gt;\n\nbaseenv()\n## &lt;environment: base&gt;\n\nemptyenv()\n##&lt;environment: R_EmptyEnv&gt;\nA continuación, puede buscar el padre de un entorno con parent.env:\nparent.env(globalenv())\n## &lt;environment: package:pryr&gt;\n## attr(,\"name\")\n## [1] \"package:pryr\"\n## attr(,\"path\")\n## [1] \"/Library/Frameworks/R.framework/Versions/3.0/Resources/library/pryr\"\nTenga en cuenta que el entorno vacío es el único entorno R sin padre:\nparent.env(emptyenv())\n## Error in parent.env(emptyenv()) : the empty environment has no parent\nPuede ver los objetos guardados en un entorno con ls o ls.str. ls devolverá solo los nombres de los objetos, pero ls.str mostrará un poco sobre la estructura de cada objeto:\nls(emptyenv())\n## character(0)\n\nls(globalenv())\n##  \"ahora\"   \"barajar\"   \"dado\"    \"genero\"    \"lst\"   \"mano\"\n##   \"mazo\"   \"mazo2\"   \"mazo3\"   \"mazo4\"   \"mazo5\"    \"millon\"        \n##  \"nuevo\"   \"repartir\"    \"vec\"  \nEl entorno vacío es, como es lógico, vacío; el entorno base tiene demasiados objetos para enumerarlos aquí; y el entorno global tiene algunas caras conocidas. Es donde R ha guardado todos los objetos que ha creado hasta ahora.\n\n\n\n\n\n\nEl panel de Global Environment de RStudio muestra todos los objetos en su entorno global.\n\n\n\nPuede usar la sintaxis $ de R para acceder a un objeto en un entorno específico. Por ejemplo, puedes acceder a mazo desde el entorno global:\nhead(globalenv()$mazo, 3)\n##  cara  palo valor\n##   rey picas    13\n## reina picas    12\n##  jota picas    11\nY puede usar la función assign para guardar un objeto en un entorno particular. Primero dale a assign el nombre del nuevo objeto (como una cadena de caracteres). Luego dale a assign el valor del nuevo objeto, y finalmente el entorno para guardar el objeto:\nassign(\"nuevo\", \"Hola Global\", envir = globalenv())\n\nglobalenv()$nuevo\n## \"Hola Global\"\nTenga en cuenta que assign funciona de forma similar a &lt;-. Si un objeto ya existe con el nombre dado en el entorno dado, assign lo sobrescribirá sin pedir permiso. Esto hace que assign sea útil para actualizar objetos.\nAhora que puede explorar el árbol de entorno de R, examinemos cómo lo usa R. R trabaja en estrecha colaboración con el árbol del entorno para buscar objetos, almacenar objetos y evaluar funciones. La forma en que R realice cada una de estas tareas dependerá del entorno activo actual.\n\n6.2.1 El Entorno Activo\nEn cualquier momento, R está trabajando en estrecha colaboración con un solo entorno. R almacenará nuevos objetos en este entorno (si crea alguno), y R utilizará este entorno como punto de partida para buscar objetos existentes (si llama a alguno). Llamaré a este entorno especial el entorno activo. El entorno activo suele ser el entorno global, pero esto puede cambiar cuando ejecuta una función.\nPuede usar environment para ver el entorno activo actual:\nenvironment()\n&lt;environment: R_GlobalEnv&gt;\nEl entorno global juega un papel especial en R. Es el entorno activo para cada comando que ejecuta en la línea de comandos. Como resultado, cualquier objeto que cree en la línea de comandos se guardará en el entorno global. Puede pensar en el entorno global como su espacio de trabajo de usuario.\nCuando llama a un objeto en la línea de comando, R lo buscará primero en el entorno global. Pero, ¿y si el objeto no está allí? En ese caso, R seguirá una serie de reglas para buscar el objeto.",
    "crumbs": [
      "Proyecto 2: Baraja de Cartas",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Entornos</span>"
    ]
  },
  {
    "objectID": "environments.html#reglas-de-alcance",
    "href": "environments.html#reglas-de-alcance",
    "title": "6  Entornos",
    "section": "\n6.3 Reglas de Alcance",
    "text": "6.3 Reglas de Alcance\nR sigue un conjunto especial de reglas para buscar objetos. Estas reglas se conocen como reglas de alcance de R y ya conoce un par de ellas:\n\nR busca objetos en el entorno activo actual.\nCuando trabaja en la línea de comandos, el entorno activo es el entorno global. Por lo tanto, R busca objetos a los que llama en la línea de comando en el entorno global.\n\nAquí hay una tercera regla que explica cómo R encuentra objetos que no están en el entorno activo.\n\nCuando R no encuentra un objeto en un entorno, R busca en el entorno principal del entorno, luego en el principal del principal, y así sucesivamente, hasta que R encuentra el objeto o llega al entorno vacío.\n\nEntonces, si llama a un objeto en la línea de comando, R lo buscará en el entorno global. Si R no puede encontrarlo allí, R buscará en el padre del entorno global, y luego en el padre del padre, y así sucesivamente, ascendiendo por el árbol del entorno hasta que encuentre el objeto, como en la Figura Figura 6.3. Si R no puede encontrar el objeto en ningún entorno, devolverá un error que dice que no se encuentra el objeto.\n\n\n\n\n\n\n\nFigura 6.3: R buscará un objeto por su nombre en el entorno activo, aquí el entorno global. Si R no encuentra el objeto allí, buscará en el padre del entorno activo y luego en el padre del padre, y así sucesivamente hasta que R encuentre el objeto o se quede sin entornos.\n\n\n\n\n\n\n\n\n\n\nRecuerde que las funciones son un tipo de objeto en R. R almacenará y buscará funciones de la misma manera que almacena y busca otros objetos, buscándolos por nombre en el árbol del entorno.",
    "crumbs": [
      "Proyecto 2: Baraja de Cartas",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Entornos</span>"
    ]
  },
  {
    "objectID": "environments.html#asignación",
    "href": "environments.html#asignación",
    "title": "6  Entornos",
    "section": "\n6.4 Asignación",
    "text": "6.4 Asignación\nCuando asigna un valor a un objeto, R guarda el valor en el entorno activo bajo el nombre del objeto. Si ya existe un objeto con el mismo nombre en el entorno activo, R lo sobrescribirá.\nPor ejemplo, existe un objeto llamado nuevo en el entorno global:\nnuevo\n## \"Hola Global\"\nPuede guardar un nuevo objeto llamado nuevo en el entorno global con este comando. R sobrescribirá el objeto anterior como resultado:\nnuevo &lt;- \"Hola Activo\"\n\nnuevo\n## \"Hola Activo\"\nEste arreglo crea un dilema para R cada vez que R ejecuta una función. Muchas funciones guardan objetos temporales que les ayudan a hacer su trabajo. Por ejemplo, la función tirar del Proyecto 1: Dados Ponderados guardó un objeto llamado dado y un objeto llamado dados:\ntirar &lt;- function() {\n  dado &lt;- 1:6\n  dados &lt;- sample(dado, size = 2, replace = TRUE)\n  sum(dados)\n}\nR debe guardar estos objetos temporales en el entorno activo; pero si R hace eso, puede sobrescribir los objetos existentes. Los autores de funciones no pueden adivinar de antemano qué nombres pueden existir ya en su entorno activo. ¿Cómo evita R este riesgo? Cada vez que R ejecuta una función, crea un nuevo entorno activo para evaluar la función.",
    "crumbs": [
      "Proyecto 2: Baraja de Cartas",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Entornos</span>"
    ]
  },
  {
    "objectID": "environments.html#evaluación",
    "href": "environments.html#evaluación",
    "title": "6  Entornos",
    "section": "\n6.5 Evaluación",
    "text": "6.5 Evaluación\nR crea un nuevo entorno cada vez que evalúa una función. R usará el nuevo entorno como el entorno activo mientras ejecuta la función, y luego R volverá al entorno desde el que llamó a la función, trayendo consigo el resultado de la función. Llamemos a estos nuevos entornos entornos de tiempo de ejecución porque R los crea en tiempo de ejecución para evaluar funciones.\nUsaremos la siguiente función para explorar los entornos de tiempo de ejecución de R. Queremos saber cómo son los entornos: ¿cuáles son sus entornos principales y qué objetos contienen? show_env está diseñado para decirnos:\nshow_env &lt;- function(){\n  list(ran.in = environment(), \n    parent = parent.env(environment()), \n    objects = ls.str(environment()))\n}\nshow_env es en sí mismo una función, por lo que cuando llamamos a show_env(), R creará un entorno de tiempo de ejecución para evaluar la función. Los resultados de show_env nos dirán el nombre del entorno de tiempo de ejecución, su padre y qué objetos entorno de tiempo de ejecución contiene:\nshow_env()\n## $ran.in\n## &lt;environment: 0x7ff711d12e28&gt;\n## \n## $parent\n## &lt;environment: R_GlobalEnv&gt;\n## \n## $objects\nLos resultados revelan que R creó un nuevo entorno llamado 0x7ff711d12e28 para ejecutar show_env(). El entorno no tenía objetos y su padre era el entorno global. Entonces, para ejecutar show_env, el árbol de entorno de R se parecía a la figura Figura 6.4.\nEjecutemos show_env de nuevo:\nshow_env()\n## $ran.in\n## &lt;environment: 0x7ff715f49808&gt;\n## \n## $parent\n## &lt;environment: R_GlobalEnv&gt;\n## \n## $objects\nEsta vez show_env se ejecutó en un nuevo entorno, 0x7ff715f49808. R crea un nuevo entorno cada vez que ejecuta una función. El entorno 0x7ff715f49808 se ve exactamente igual que 0x7ff711d12e28. Está vacío y tiene el mismo entorno global que su padre.\n\n\n\n\n\n\n\nFigura 6.4: R crea un nuevo entorno para ejecutar show_env. El entorno es un elemento secundario del entorno global.\n\n\n\n\nAhora, consideremos qué entorno usará R como padre del entorno de tiempo de ejecución.\nR conectará el entorno de tiempo de ejecución de una función con el entorno en el que la función fue creada por primera vez. Este entorno juega un papel importante en la vida de la función, porque todos los entornos de tiempo de ejecución de la función lo utilizarán como padre. Llamemos a este entorno el entorno de origen. Puede buscar el entorno de origen de una función ejecutando environment en la función:\nenvironment(show_env)\n## &lt;environment: R_GlobalEnv&gt;\nEl entorno de origen de show_env es el entorno global porque creamos show_env en la línea de comando, pero no es necesario que el entorno de origen sea el entorno global. Por ejemplo, el entorno de parenvs es el paquete pryr:\nenvironment(parenvs)\n## &lt;environment: namespace:pryr&gt;\nEn otras palabras, el padre de un entorno de tiempo de ejecución no siempre será el entorno global; será el entorno en el que se creó la función por primera vez.\nFinalmente, veamos los objetos contenidos en un entorno de tiempo de ejecución. Por el momento, los entornos de ejecución de show_env no contienen ningún objeto, pero eso es fácil de arreglar. Simplemente haga que show_env cree algunos objetos en el cuerpo de su código. R almacenará cualquier objeto creado por show_env en su entorno de ejecución. ¿Por qué? Debido a que el entorno de tiempo de ejecución será el entorno activo cuando se creen esos objetos:\nshow_env &lt;- function(){\n  a &lt;- 1\n  b &lt;- 2\n  c &lt;- 3\n  list(ran.in = environment(), \n    parent = parent.env(environment()), \n    objects = ls.str(environment()))\n}\nEsta vez, cuando ejecutamos show_env, R almacena a, b y c en el entorno de ejecución:\nshow_env()\n## $ran.in\n## &lt;environment: 0x7ff712312cd0&gt;\n## \n## $parent\n## &lt;environment: R_GlobalEnv&gt;\n## \n## $objects\n## a :  num 1\n## b :  num 2\n## c :  num 3\nAsí es como R se asegura de que una función no sobrescriba nada que no debería. Todos los objetos creados por la función se almacenan en un entorno de tiempo de ejecución seguro y apartado.\nR también pondrá un segundo tipo de objeto en un entorno de tiempo de ejecución. Si una función tiene argumentos, R copiará cada argumento en el entorno de tiempo de ejecución. El argumento aparecerá como un objeto que tiene el nombre del argumento pero el valor de cualquier entrada que el usuario proporcionó para el argumento. Esto asegura que una función podrá encontrar y usar cada uno de sus argumentos:\nfoo &lt;- \"llevame a tu tiempo de ejecucion\"\n\nshow_env &lt;- function(x = foo){\n  list(ran.in = environment(), \n    parent = parent.env(environment()), \n    objects = ls.str(environment()))\n}\n\nshow_env()\n## $ran.in\n## &lt;environment: 0x7ff712398958&gt;\n## \n## $parent\n## &lt;environment: R_GlobalEnv&gt;\n## \n## $objects\n## x :  chr \"llevame a tu tiempo de ejecucion\"\nPongamos todo esto junto para ver cómo R evalúa una función. Antes de llamar a una función, R está trabajando en un entorno activo; llamemos a esto el entorno de llamadas. Es el entorno desde el que R llama a la función.\nLuego llamas a la función. R responde configurando un nuevo entorno de tiempo de ejecución. Este entorno será un elemento secundario del entorno de origen de la función. R copiará cada uno de los argumentos de la función en el entorno de tiempo de ejecución y luego hará que el entorno de tiempo de ejecución sea el nuevo entorno activo.\nA continuación, R ejecuta el código en el cuerpo de la función. Si el código crea objetos, R los almacena en el entorno activo, es decir, en tiempo de ejecución. Si el código llama a algún objeto, R usa sus reglas de alcance para buscarlos. R buscará el entorno de tiempo de ejecución, luego el padre del entorno de tiempo de ejecución (que será el entorno de origen), luego el padre del entorno de origen, y así sucesivamente. Tenga en cuenta que es posible que el entorno de llamada no esté en la ruta de búsqueda. Por lo general, una función solo llamará a sus argumentos, que R puede encontrar en el entorno de tiempo de ejecución activo.\nFinalmente, R termina de ejecutar la función. Cambia el entorno activo de nuevo al entorno de llamada. Ahora R ejecuta cualquier otro comando en la línea de código que llamó a la función. Entonces, si guarda el resultado de la función en un objeto con &lt;-, el nuevo objeto se almacenará en el entorno de llamada.\nEn resumen, R almacena sus objetos en un sistema de entorno. En cualquier momento, R está trabajando en estrecha colaboración con un único entorno activo. Almacena nuevos objetos en este entorno y utiliza el entorno como punto de partida cuando busca objetos existentes. El entorno activo de R suele ser el entorno global, pero R ajustará el entorno activo para hacer cosas como ejecutar funciones de forma segura.\n¿Cómo puedes usar este conocimiento para arreglar las funciones repartir y barajar?\nPrimero, comencemos con una pregunta de calentamiento. Supongamos que redefino repartir en la línea de comando de esta manera:\nrepartir &lt;- function() {\n  mazo[1, ]\n}\nTenga en cuenta que repartir ya no toma un argumento y llama al objeto mazo, que vive en el entorno global.\nEjercicio 8.1 (¿Funcionará repartir?) ¿Podrá R encontrar mazo y devolver una respuesta cuando llame a la nueva versión de repartir, como repartir()?\nSolución. Sí. repartir seguirá funcionando igual que antes. R ejecutará repartir en un entorno de tiempo de ejecución que es un elemento secundario del entorno global. ¿Por qué será un hijo del entorno global? Debido a que el entorno global es el entorno de origen de repartir (definimos repartir en el entorno global):\nenvironment(repartir)\n## &lt;environment: R_GlobalEnv&gt;\nCuando repartir llama a mazo, R necesitará buscar el objeto mazo. Las reglas de alcance de R lo llevarán a la versión de repartir en el entorno global, como en la Figura Figura 6.5. mazo funciona como se esperaba como resultado:\nrepartir()\n##  cara  palo valor\n##   rey picas    13\n\n\n\n\n\n\n\nFigura 6.5: R encuentra el mazo mirando en el padre del entorno de tiempo de ejecución de repartir. El padre es el entorno global, el entorno de origen de repartir. Aquí, R encuentra la copia del mazo.\n\n\n\n\nAhora arreglemos la función repartir para eliminar las cartas que ha repartido del mazo. Recuerde que repartir devuelve la carta superior de mazo pero no elimina la carta de la baraja. Como resultado, repartir siempre devuelve la misma carta:\nrepartir()\n##  cara  palo valor\n##   rey picas    13\n\nrepartir()\n##  cara  palo valor\n##   rey picas    13\nConoces suficiente sintaxis de R para eliminar la carta superior de mazo. El siguiente código guardará una copia prístina de mazo y luego eliminará la carta superior:\nMAZO &lt;- mazo\n\nmazo &lt;- mazo[-1, ]\n\nhead(mazo, 3)\n##  cara  palo valor\n## reina picas    12\n##  jota picas    11\n##  diez picas    10\nAhora agreguemos el código a repartir. Aquí repartir guarda (y luego devuelve) la carta superior de mazo. En el medio, quita la carta del mazo… ¿o no?\nrepartir &lt;- function() {\n  carta &lt;- mazo[1, ]\n  mazo &lt;- mazo[-1, ]\n  carta\n}\nEste código no funcionará porque R estará en un entorno de tiempo de ejecución cuando ejecute mazo &lt;- mazo[-1, ]. En lugar de sobrescribir la copia global de mazo con mazo[-1, ], repartir simplemente creará una copia ligeramente alterada de mazo en su entorno de tiempo de ejecución, como en la Figura Figura 6.6.\n\n\n\n\n\n\n\nFigura 6.6: La función de repartir busca el mazo en el entorno global pero guarda el mazo[-1, ] en el entorno de tiempo de ejecución como un nuevo objeto llamado mazo.\n\n\n\n\nEjercicio 8.2 (Sobreescribir el mazo) Vuelva a escribir la línea mazo &lt;- mazo[-1, ] de repartir para asignar mazo[-1, ] a un objeto llamado mazo en el entorno global. Sugerencia: considere la función assign.\nSolución. Puede asignar un objeto a un entorno específico con la función assign:\nrepartir &lt;- function() {\n  carta &lt;- mazo[1, ]\n  assign(\"mazo\", mazo[-1, ], envir = globalenv())\n  carta\n}\nAhora repartir finalmente limpiará la copia global de mazo, y podemos repartir cartas tal como lo haríamos en la vida real:\nrepartir()\n##  cara  palo valor\n## reina picas    12\n\nrepartir()\n## cara  palo valor\n## jota picas    11\n\nrepartir()\n## cara  palo valor\n## diez picas    10\nVolvamos nuestra atención a la función barajar:\nbarajar &lt;- function(cartas) { \n  aleatorio &lt;- sample(1:52, size = 52)\n  cartas[aleatorio, ]\n}\nbarajar(mazo) no mezcla el objeto mazo; devuelve una copia barajada del objeto mazo:\nhead(mazo, 3)\n##  cara  palo valor\n## nueve picas     9\n##  ocho picas     8\n## siete picas     7\n\na &lt;- barajar(mazo)\n\nhead(mazo, 3)\n##  cara  palo valor\n## nueve picas     9\n##  ocho picas     8\n## siete picas     7\n\nhead(a, 3)\n##  cara      palo valor\n##    as diamantes     1\n## siete  treboles     7\n##   dos  treboles     2\nEste comportamiento es ahora indeseable de dos maneras. Primero, barajr falla al barajar mazo. En segundo lugar, barajar devuelve una copia de mazo, a la que pueden faltarle las cartas que se han repartido. Sería mejor si barajar devolviera las cartas repartidas a la baraja y luego se barajaran. Esto es lo que sucede cuando barajas una baraja de cartas en la vida real.\nEjercicio 8.3 (Rescribir barajr) Vuelva a escribir barajar para que reemplace la copia de mazo que vive en el entorno global con una versión barajada de MAZO, la copia intacta de mazo que también vive en el entorno global. La nueva versión de barajar no debería tener argumentos y no devolver ningún resultado.\nSolución. Puede actualizar barajar de la misma manera que actualizó repartir. La siguiente versión hará el trabajo:\nbarajar &lt;- function(){\n  aleatorio &lt;- sample(1:52, size = 52)\n  assign(\"mazo\", MAZO[aleatorio, ], envir = globalenv())\n}\nDado que MAZO vive en el entorno global, el entorno de origen de barajar, barajar podrá encontrar MAZO en tiempo de ejecución. R buscará MAZO primero en el entorno de tiempo de ejecución de barajar y luego en el entorno de origen de barajar, el entorno global, que es donde se almacena MAZO.\nLa segunda línea de barajar creará una copia reordenada de MAZO y la guardará como mazo en el entorno global. Esto sobrescribirá la versión anterior, no barajada, de mazo.",
    "crumbs": [
      "Proyecto 2: Baraja de Cartas",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Entornos</span>"
    ]
  },
  {
    "objectID": "environments.html#cierres",
    "href": "environments.html#cierres",
    "title": "6  Entornos",
    "section": "\n6.6 Cierres",
    "text": "6.6 Cierres\nNuestro sistema finalmente funciona. Por ejemplo, puede barajar las cartas y luego repartir una mano de blackjack:\nbarajar()\n\nrepartir()\n##  cara      palo valor\n## reina corazones    12\n\nrepartir()\n## cara      palo valor\n## ocho corazones     8\nPero el sistema requiere que mazo y MAZO existan en el entorno global. Muchas cosas suceden en este entorno, y es posible que el mazo se modifique o borre por accidente.\nSería mejor si pudiéramos almacenar mazo en un lugar seguro y apartado, como uno de esos entornos seguros y apartados que R crea para ejecutar funciones. De hecho, almacenar mazo en un entorno de tiempo de ejecución no es tan mala idea.\nPodrías crear una función que tome mazo como argumento y guarde una copia de mazo como MAZO. La función también podría guardar sus propias copias de repartir y barajar:\nsetup &lt;- function(mazo) {\n  MAZO &lt;- mazo\n\n  REPARTIR &lt;- function() {\n    carta &lt;- mazo[1, ]\n    assign(\"mazo\", mazo[-1, ], envir = globalenv())\n    carta\n  }\n\n  BARAJAR &lt;- function(){\n    aleatorio &lt;- sample(1:52, size = 52)\n    assign(\"mazo\", MAZO[aleatorio, ], envir = globalenv())\n }\n}\nCuando ejecuta setup, R creará un entorno de tiempo de ejecución para almacenar estos objetos. El entorno se verá como la Figura Figura 6.7.\nAhora todas estas cosas están seguras fuera del camino en un hijo del entorno global. Eso los hace seguros pero difíciles de usar. Pidamos a setup que devuelva REPARTIR y BARAJAR para poder usarlos. La mejor manera de hacer esto es devolver las funciones como una lista:\nsetup &lt;- function(mazo) {\n  MAZO &lt;- mazo\n\n  REPARTIR &lt;- function() {\n    carta &lt;- mazo[1, ]\n    assign(\"mazo\", mazo[-1, ], envir = globalenv())\n    carta\n  }\n\n  BARAJAR &lt;- function(){\n    aleatorio &lt;- sample(1:52, size = 52)\n    assign(\"mazo\", MAZO[aleatorio, ], envir = globalenv())\n }\n\n list(repartir = REPARTIR, barajar = BARAJAR)\n}\n\ncartas &lt;- setup(mazo)\n\n\n\n\n\n\n\nFigura 6.7: Ejecutar setup almacenará mazo y MAZO en un lugar apartado y creará una función REPARTIR y BARAJAR. Cada uno de estos objetos se almacenará en un entorno cuyo padre es el entorno global.\n\n\n\n\nLuego puede guardar cada uno de los elementos de la lista en un objeto dedicado en el entorno global:\nrepartir &lt;- cartas$repartir\nbarajar &lt;- cartas$barajar\nAhora puedes ejecutar repartir y barajar como antes. Cada objeto contiene el mismo código que el repartir y barajar originales:\nrepartir\n## function() {\n##     carta &lt;- mazo[1, ]\n##     assign(\"mazo\", mazo[-1, ], envir = globalenv())\n##     carta\n##   }\n## &lt;environment: 0x7ff7169c3390&gt;\n\nbarajar\n## function(){\n##     aleatorio &lt;- sample(1:52, size = 52)\n##     assign(\"mazo\", MAZO[aleatorio, ], envir = globalenv())\n##  }\n## &lt;environment: 0x7ff7169c3390&gt;\nSin embargo, las funciones ahora tienen una diferencia importante. Su entorno de origen ya no es el entorno global (aunque repartir y barajar están actualmente guardados allí). Su entorno de origen es el entorno de tiempo de ejecución que creó R cuando ejecutó setup. Ahí es donde R creó REPARTIR y BARAJAR, las funciones copiadas en el nuevo repartir y barajar, como se muestra en:\nenvironment(repartir)\n## &lt;environment: 0x7ff7169c3390&gt;\n\nenvironment(barajar)\n## &lt;environment: 0x7ff7169c3390&gt;\n¿Por qué importa esto? Porque ahora, cuando ejecuta repartir o barajar, R evaluará las funciones en un entorno de tiempo de ejecución que usa 0x7ff7169c3390 como padre. MAZO y mazo estarán en este entorno principal, lo que significa que repartir y barajar podrán encontrarlos en tiempo de ejecución. MAZO y mazo estarán en la ruta de búsqueda de funciones, pero seguirán fuera del camino en todos los demás aspectos, como se muestra en la Figura Figura 6.8.\n\n\n\n\n\n\n\nFigura 6.8: Ahora, repartir y barajar se ejecutará en un entorno que tenga el mazo protegido y el MAZO en su ruta de búsqueda.\n\n\n\n\nEste arreglo se llama cierre. El entorno de tiempo de ejecución de setup “encierra” las funciones repartir y barajar. Tanto repartir como barajar pueden trabajar de cerca con los objetos contenidos en el entorno circundante, pero casi nada más puede hacerlo. El entorno envolvente no está en la ruta de búsqueda de ninguna otra función o entorno de R.\nEs posible que haya notado que repartir y barajar aún actualizan el objeto mazo en el entorno global. No te preocupes, estamos a punto de cambiar eso. Queremos que repartir y barajar funcionen exclusivamente con los objetos en el entorno principal (incluyente) de sus entornos de tiempo de ejecución. En lugar de hacer que cada función haga referencia al entorno global para actualizar mazo, puede hacer que hagan referencia a su entorno principal en tiempo de ejecución, como se muestra en la Figura Figura 6.9:\nsetup &lt;- function(mazo) {\n  MAZO &lt;- mazo\n\n  REPARTIR &lt;- function() {\n    carta &lt;- mazo[1, ]\n    assign(\"mazo\", mazo[-1, ], envir = parent.env(environment()))\n    carta\n  }\n\n  BARAJAR &lt;- function(){\n    aleatorio &lt;- sample(1:52, size = 52)\n    assign(\"mazo\", MAZO[aleatorio, ], envir = parent.env(environment()))\n }\n\n list(repartir = REPARTIR, barajar = BARAJAR)\n}\n\ncartas &lt;- setup(mazo)\nrepartir &lt;- cartas$repartir\nbarajar &lt;- cartas$barajar\n\n\n\n\n\n\n\nFigura 6.9: Cuando cambie su código, repartir y barajar pasarán de actualizar el entorno global (izquierda) a actualizar su entorno principal (derecha).\n\n\n\n\nFinalmente tenemos un juego de cartas autónomo. Puedes borrar (o modificar) la copia global de mazo tanto como quieras y seguir jugando cartas. repartir y barajar utilizarán la copia protegida y prístina de mazo:\nrm(mazo)\n\nbarajar()\n\nrepartir()\n## cara      palo value\n##   as corazones     1\n\nrepartir()\n## cara     palo valor\n## jota treboles    11\nBlackjack!",
    "crumbs": [
      "Proyecto 2: Baraja de Cartas",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Entornos</span>"
    ]
  },
  {
    "objectID": "environments.html#resumen",
    "href": "environments.html#resumen",
    "title": "6  Entornos",
    "section": "\n6.7 Resumen",
    "text": "6.7 Resumen\nR guarda sus objetos en un sistema de entorno que se asemeja al sistema de archivos de su computadora. Si comprende este sistema, puede predecir cómo R buscará objetos. Si llama a un objeto en la línea de comando, R buscará el objeto en el entorno global y luego los padres del entorno global, ascendiendo en el árbol de entornos, un entorno a la vez.\nR usará una ruta de búsqueda ligeramente diferente cuando llame a un objeto desde dentro de una función. Cuando ejecuta una función, R crea un nuevo entorno para ejecutar comandos. Este entorno será un elemento secundario del entorno donde se definió originalmente la función. Este puede ser el entorno global, pero también puede no serlo. Puede usar este comportamiento para crear cierres, que son funciones vinculadas a objetos en entornos protegidos.\nA medida que se familiarice con el sistema de entorno de R, puede usarlo para producir resultados elegantes, como lo hicimos aquí. Sin embargo, el valor real de comprender el sistema de entorno proviene de saber cómo las funciones de R hacen su trabajo. Puede usar este conocimiento para descubrir qué está fallando cuando una función no funciona como se esperaba.",
    "crumbs": [
      "Proyecto 2: Baraja de Cartas",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Entornos</span>"
    ]
  },
  {
    "objectID": "environments.html#resumen-del-proyecto-2",
    "href": "environments.html#resumen-del-proyecto-2",
    "title": "6  Entornos",
    "section": "\n6.8 Resumen del Proyecto 2",
    "text": "6.8 Resumen del Proyecto 2\nAhora tiene control total sobre los conjuntos de datos y los valores que carga en R. Puede almacenar datos como objetos de R, puede recuperar y manipular valores de datos a voluntad e incluso puede predecir cómo R almacenará y buscará sus objetos en la memoria de tu computadora.\nEs posible que aún no se dé cuenta, pero su experiencia lo convierte en un poderoso usuario de datos aumentados por computadora. Puede usar R para guardar y trabajar con conjuntos de datos más grandes de los que podría manejar de otra manera. Hasta ahora solo hemos trabajado con mazo, un pequeño conjunto de datos; pero puede usar las mismas técnicas para trabajar con cualquier conjunto de datos que quepa en la memoria de su computadora.\nSin embargo, el almacenamiento de datos no es la única tarea logística a la que se enfrentará como científico de datos. A menudo querrá realizar tareas con sus datos que son tan complejas o repetitivas que son difíciles de realizar sin una computadora. Algunas de las cosas se pueden hacer con funciones que ya existen en R y sus paquetes, pero otras no. Serás el más versátil como científico de datos si puedes escribir tus propios programas para que los sigan las computadoras. R puede ayudarte a hacer esto. Cuando esté listo, Project 3: Máquina Tragamonedas le enseñará las habilidades más útiles para escribir programas en R.",
    "crumbs": [
      "Proyecto 2: Baraja de Cartas",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Entornos</span>"
    ]
  },
  {
    "objectID": "slots.html",
    "href": "slots.html",
    "title": "Proyecto 3: Máquina Tragamonedas",
    "section": "",
    "text": "Las máquinas tragamonedas son el juego más popular en los casinos modernos. Si nunca has visto una, una máquina tragamonedas se parece a un juego de arcade que tiene una palanca en un costado. Por una pequeña tarifa, puede tirar de la palanca y la máquina generará una combinación aleatoria de tres símbolos. Si aparece la combinación correcta, puede ganar un premio, tal vez incluso el mejor premio.\nLas máquinas tragamonedas generan ganancias fantásticas para los casinos porque ofrecen una tasa de pago muy baja. En muchos juegos, como el Blackjack y la Ruleta, las probabilidades están ligeramente a favor del casino. A la larga, el casino paga de 97 a 98 centavos en premios por cada dólar que gasta un jugador en estos juegos. Con las máquinas tragamonedas, es típico que un casino solo pague de 90 a 95 centavos, y el casino se queda con el resto. Si esto parece turbio, tenga en cuenta que las máquinas tragamonedas son uno de los juegos más populares en un casino; a pocas personas parece importarles. Y si considera que las loterías estatales tienen tasas de pago mucho más cercanas a los 50 centavos por dólar, las máquinas tragamonedas no se ven tan mal.\nEn este proyecto, construirá una máquina tragamonedas real que funcione, modelada a partir de algunas Terminales de Lotería de Video de la vida real de Manitoba, Canadá. Los terminales fueron motivo de escándalo en la década de los 90. Llegarás al fondo de este escándalo escribiendo un programa que recree las máquinas tragamonedas. Luego hará algunos cálculos y ejecutará algunas simulaciones que revelarán la verdadera tasa de pago de las máquinas.\nEste proyecto le enseñará a escribir programas y ejecutar simulaciones en R. También aprenderá a:\n\nUsar una estrategia práctica para diseñar programas\nUsar declaraciones if y else para decirle a R qué hacer y cuando\nCrear tablas de búsqueda para encontrar valores\nUsar bucles for, while y repeat para automatizar operaciones repetitivas\nUsar métodos S3, la versión de R de Programación Orientada a Objetos\nMedir la velocidad del código R\nEscribir código R rápido y vectorizado",
    "crumbs": [
      "Proyecto 3: Máquina Tragamonedas"
    ]
  },
  {
    "objectID": "programs.html",
    "href": "programs.html",
    "title": "7  Programas",
    "section": "",
    "text": "7.1 Estrategia\nEn este capítulo, construirá una máquina tragamonedas real y funcional que puede jugar ejecutando una función R. Cuando termines, podrás jugarlo así:\nLa función play necesitará hacer dos cosas. Primero, necesitará generar aleatoriamente tres símbolos; y, segundo, necesitará calcular un premio basado en esos símbolos.\nEl primer paso es fácil de simular. Puede generar aleatoriamente tres símbolos con la función sample, tal como “lanzó” aleatoriamente dos dados en Proyecto 1: Dados Ponderados. La siguiente función genera tres símbolos de un grupo de símbolos comunes de máquinas tragamonedas: diamantes (DD), sietes (7), barras triples (BBB), barras dobles (BB), barras simples (B), cerezas (C) y ceros (0). Los símbolos se seleccionan al azar y cada símbolo aparece con una probabilidad diferente:\nPuedes usar obt_simbolos() para generar los símbolos usados en tu máquina tragamonedas:\nobt_simbolos utiliza las probabilidades observadas en un grupo de Terminales de Video Lotería de Manitoba, Canadá. Estas máquinas tragamonedas se volvieron brevemente controvertidas en la década de 1990, cuando un reportero decidió probar su tasa de pago. Las máquinas parecían pagar solo 40 centavos por dólar, aunque el fabricante afirmó que pagarían 92 centavos por dólar. Los datos originales recopilados en las máquinas y una descripción de la controversia están disponibles en línea en un artículo de revista de W. John Braun. La controversia se calmó cuando las pruebas adicionales mostraron que el fabricante tenía razón.\nLas máquinas tragamonedas de Manitoba utilizan el complicado esquema de pagos que se muestra en la Tabla Tabla 7.1. Un jugador ganará un premio si obtiene:\nDe lo contrario, el jugador no recibe ningún premio.\nEl valor monetario del premio está determinado por la combinación exacta de símbolos y se modifica aún más por la presencia de diamantes. Los diamantes se tratan como “comodines”, lo que significa que pueden considerarse cualquier otro símbolo si aumentara el premio de un jugador. Por ejemplo, un jugador que lanza 7 7 DD ganaría un premio por obtener tres sietes. Sin embargo, hay una excepción a esta regla: un diamante no se puede considerar una cereza a menos que el jugador también obtenga una cereza real. Esto evita que una tirada sin fondos como 0 DD 0 se puntúe como 0 C 0.\nLos diamantes también son especiales de otra manera. Cada diamante que aparece en una combinación duplica el importe del premio final. Así que 7 7 DD en realidad tendría una puntuación más alta que 7 7 7. Tres sietes te darían $80, pero dos sietes y un diamante te darían $160. Un siete y dos diamantes sería aún mejor, lo que daría como resultado un premio que se ha duplicado dos veces, o $320. Un premio mayor ocurre cuando un jugador lanza DD DD DD. Luego, un jugador gana $100 duplicados tres veces, lo que equivale a $800.\nPara crear su función play, necesitará escribir un programa que pueda tomar la salida de obt_simbolos y calcular el premio correcto basado en Tabla Tabla 7.1.\nEn R, los programas se guardan como scripts de R o como funciones. Guardaremos su programa como una función llamada puntuacion. Cuando termines, podrás usar puntuacion para calcular un premio como este:\nDespués de eso, será fácil crear la máquina tragamonedas completa, así:\nPuede notar que play llama a una nueva función, print. Esto ayudará a play a mostrar los tres símbolos de máquinas tragamonedas, ya que la última línea de la función no los devuelve. El comando print imprime su salida en la ventana de la consola, incluso si R lo llama desde dentro de una función.\nEn Proyecto 1: Dados Ponderados, lo animé a escribir todo su código R en un script R, un archivo de texto donde puede redactar y guardar el código. Ese consejo será muy importante a medida que avance en este capítulo. Recuerde que puede abrir un script R en RStudio yendo a la barra de menú y haciendo clic en File &gt; New File &gt; R Script.\nLa puntuación de los resultados de las máquinas tragamonedas es una tarea compleja que requerirá un algoritmo complejo. Puede facilitar esta y otras tareas de codificación utilizando una estrategia simple:\nComencemos por ver cómo puede dividir un programa en subtareas con las que es fácil trabajar.\nUn programa es un conjunto de instrucciones paso a paso que debe seguir su computadora. En conjunto, estas instrucciones pueden lograr algo muy sofisticado. Por separado, cada paso individual probablemente será simple y directo.\nPuede facilitar la codificación identificando los pasos o subtareas individuales dentro de su programa. A continuación, puede trabajar en cada subtarea por separado. Si una subtarea parece complicada, intente dividirla nuevamente en subtareas pares que sean aún más simples. A menudo, puede reducir un programa de R en subtareas tan simples que cada una se puede realizar con una función preexistente.\nLos programas de R contienen dos tipos de subtareas: pasos secuenciales y casos paralelos.",
    "crumbs": [
      "Proyecto 3: Máquina Tragamonedas",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Programas</span>"
    ]
  },
  {
    "objectID": "programs.html#estrategia",
    "href": "programs.html#estrategia",
    "title": "7  Programas",
    "section": "",
    "text": "Dividir tareas complejas en subtareas simples.\nUtilice ejemplos concretos.\nDescriba sus soluciones en español, luego conviértalas a R.\n\n\n\n\n\n\n7.1.1 Pasos Secuenciales\nUna forma de subdividir un programa es en una serie de pasos secuenciales. La función play toma el enfoque que se muestra en la Figura Figura 7.1. Primero, genera tres símbolos (paso 1), luego los muestra en la ventana de la consola (paso 2) y luego los puntúa (paso 3):\nplay &lt;- function() {\n\n  # step 1: genera simbolos\n  simbolos &lt;- obt_simbolos()\n\n  # step 2: muestra los simbolos\n  print(simbolos)\n\n  # step 3: puntua los simbolos\n  puntuacion(simbolos)\n}\nPara que R ejecute los pasos en secuencia, coloque los pasos uno tras otro en un script de R o en el cuerpo de una función.\n\n\n\n\n\n\n\nFigura 7.1: La función play utiliza una serie de pasos.\n\n\n\n\n\n7.1.2 Casos Paralelos\nOtra forma de dividir una tarea es detectar grupos de casos similares dentro de la tarea. Algunas tareas requieren diferentes algoritmos para diferentes grupos de entrada. Si puede identificar esos grupos, puede resolver sus algoritmos uno a la vez.\nPor ejemplo, puntuacion necesitará calcular el premio de una manera si simbolos contiene tres de una clase (en ese caso, puntuacion necesitará hacer coincidir el símbolo común con un premio). puntuacion necesitará calcular el premio de una segunda manera si los símbolos son todos barras (en ese caso, puntuacion puede asignar un premio de $5). Y, por último, puntuacion necesitará calcular el premio de una tercera forma si los símbolos no contienen tríos o todas las barras (en ese caso, puntuacion debe contar el número de cerezas presentes). puntuacion nunca usará estos tres algoritmos a la vez; siempre elegirá solo un algoritmo para ejecutar en función de la combinación de símbolos.\nLos diamantes complican todo esto porque los diamantes pueden ser tratados como comodines. Ignoremos eso por ahora y concentrémonos en el caso más simple donde los diamantes duplican el premio pero no son comodines. puntuacion puede duplicar el premio según sea necesario después de ejecutar uno de los siguientes algoritmos, como se muestra en la Figura Figura 7.2.\nAgregar los casos de puntuación a los pasos de play revela una estrategia para el programa completo de máquinas tragamonedas, como se muestra en la Figura Figura 7.3.\nYa hemos resuelto los primeros pasos de esta estrategia. Nuestro programa puede obtener tres símbolos de máquinas tragamonedas con la función obt_simbolos. Entonces puede mostrar los símbolos con la función print. Ahora examinemos cómo el programa puede manejar los casos de puntuación paralela.\n\n\n\n\n\n\n\nFigura 7.2: La función de puntuación debe distinguir entre casos paralelos.\n\n\n\n\n\n\n\n\n\n\n\nFigura 7.3: La simulación completa de la máquina tragamonedas implicará subtareas que se organizan tanto en serie como en paralelo.",
    "crumbs": [
      "Proyecto 3: Máquina Tragamonedas",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Programas</span>"
    ]
  },
  {
    "objectID": "programs.html#declaraciones-if",
    "href": "programs.html#declaraciones-if",
    "title": "7  Programas",
    "section": "\n7.2 Declaraciones if",
    "text": "7.2 Declaraciones if\nVincular casos en paralelo requiere un poco de estructura; su programa se enfrenta a una bifurcación en el camino cada vez que debe elegir entre casos. Puedes ayudar al programa a navegar por esta bifurcación con una instrucción if.\nUna declaración if le dice a R que haga una tarea determinada para un caso determinado. En español dirías algo como: “Si esto es cierto, haz aquello”. En R, dirías:\nif (esto) {\n  aquello\n}\nEl objeto esto debe ser una prueba lógica o una expresión de R que se evalúe a un solo TRUE o FALSE. Si esto se evalúa como TRUE, R ejecutará todo el código que aparece entre las llaves que siguen a la instrucción if (es decir, entre los símbolos { y }). Si esto se evalúa como FALSE, R omitirá el código entre llaves sin ejecutarlo.\nPor ejemplo, podría escribir una declaración if que asegure que algún objeto, num, sea positivo:\nif (num &lt; 0) {\n  num &lt;- num * -1\n}\nSi num &lt; 0 es TRUE, R multiplicará num por uno negativo, lo que hará que num sea positivo:\nnum &lt;- -2\n\nif (num &lt; 0) {\n  num &lt;- num * -1\n}\n\nnum\n## 2\nSi num &lt; 0 es FALSE, R no hará nada y num permanecerá como está: positivo (o cero):\nnum &lt;- 4\n\nif (num &lt; 0) {\n  num &lt;- num * -1\n}\n\nnum\n## 4\nLa condición de una declaración if debe evaluarse como un único TRUE o FALSE. Si la condición crea un vector de TRUE y FALSE (que es más fácil de hacer de lo que piensa), su declaración if imprimirá un mensaje de advertencia y usará solo el primer elemento del vector. Recuerda que puedes condensar vectores de valores lógicos en un solo TRUE o FALSE con las funciones any y all.\nNo tienes que limitar tus declaraciones if a una sola línea de código; puede incluir tantas líneas como desee entre las llaves. Por ejemplo, el siguiente código usa muchas líneas para asegurar que num sea positivo. Las líneas adicionales imprimen algunas declaraciones informativas si num comienza como un número negativo. R omitirá todo el bloque de código, declaraciones print y todo, si num comienza como un número positivo:\nnum &lt;- -1\n\nif (num &lt; 0) {\n  print(\"num es negativo.\")\n  print(\"No te preocupes, lo arreglaré.\")\n  num &lt;- num * -1\n  print(\"Ahora num es positivo.\")\n}\n## \"num es negativo.\"\n## \"No te preocupes, lo arreglaré.\"\n## \"Ahora num es positivo.\"\n\nnum\n## 1\nPruebe las siguientes pruebas para desarrollar su comprensión de las declaraciones if.\nEjercicio 10.1 (Cuestionario A) ¿Qué devolverá esto?\nx &lt;- 1\nif (3 == 3) {\n  x &lt;- 2\n}\nx\nSolución. El código devolverá el número 2. x comienza como 1, y luego R encuentra la declaración if. Dado que la condición se evalúa como TRUE, R ejecutará x &lt;- 2, cambiando el valor de x.\nEjercicio 10.2 (Cuestionario B) ¿Qué devolverá esto?\nx &lt;- 1\nif (TRUE) {\n  x &lt;- 2\n}\nx\nSolución. Este código también devolverá el número 2. Funciona igual que el código en la prueba A, excepto que la condición en esta declaración ya es TRUE. R ni siquiera necesita evaluarlo. Como resultado, se ejecutará el código dentro de la instrucción if y x se establecerá en 2.\nEjercicio 10.3 (Cuestionario C) ¿Qué devolverá esto?\nx &lt;- 1\nif (x == 1) {\n  x &lt;- 2\n  if (x == 1) {\n    x &lt;- 3\n  }\n}\nx\nSolución. Una vez más, el código devolverá el número 2. x comienza como 1, y la condición de la primera declaración if se evaluará como TRUE, lo que hace que R ejecute el código en el cuerpo de la esa declaración if. Primero, R establece x igual a 2, luego R evalúa la segunda declaración if, que está en el cuerpo de la primera. Esta vez x == 1 se evaluará como FALSE porque x ahora es igual a 2. Como resultado, R ignora x &lt;- 3 y sale de ambas declaraciones if.",
    "crumbs": [
      "Proyecto 3: Máquina Tragamonedas",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Programas</span>"
    ]
  },
  {
    "objectID": "programs.html#declaraciones-else",
    "href": "programs.html#declaraciones-else",
    "title": "7  Programas",
    "section": "\n7.3 Declaraciones else",
    "text": "7.3 Declaraciones else\nLas declaraciones if le dicen a R qué hacer cuando su condición es verdadera, pero también puede decirle a R qué hacer cuando la condición es falsa. else es una contraparte de if que extiende una declaración if para incluir un segundo caso. En español, dirías: “Si esto es cierto, haz el plan A; de lo contrario, haz el plan B”. En R, dirías:\nif (esto) {\n  Plan A\n} else {\n  Plan B\n}\nCuando esto se evalúa como TRUE, R ejecutará el código en el primer conjunto de llaves, pero no el código en el segundo. Cuando esto se evalúa como FALSE, R ejecutará el código en el segundo conjunto de llaves, pero no en el primero. Puede utilizar este arreglo para cubrir todos los casos posibles. Por ejemplo, podría escribir algún código que redondee un decimal al entero más cercano.\nComience con un decimal:\na &lt;- 3.14\nLuego aísle el componente decimal con trunc:\ndec &lt;- a - trunc(a)\ndec\n## 0.14\n\n\n\n\n\n\ntrunc toma un número y devuelve solo la parte del número que aparece a la izquierda del lugar decimal (es decir, la parte entera del número).\n\n\n\n\n\n\n\n\n\na - trunc(a) es una forma conveniente de devolver la parte decimal de a.\n\n\n\nLuego use un árbol if else para redondear el número (hacia arriba o hacia abajo):\nif (dec &gt;= 0.5) {\n  a &lt;- trunc(a) + 1\n} else {\n  a &lt;- trunc(a)\n}\n\na\n## 3\nSi su situación tiene más de dos casos que se excluyen mutuamente, puede unir varias declaraciones if y else agregando una nueva declaración if inmediatamente después de else. Por ejemplo:\na &lt;- 1\nb &lt;- 1\n\nif (a &gt; b) {\n  print(\"¡A gana!\")\n} else if (a &lt; b) {\n  print(\"¡B gana!\")\n} else {\n  print(\"Empate.\")\n}\n## \"Empate.\"\nR trabajará a través de las condiciones if hasta que una se evalúe como TRUE, entonces R ignorará cualquier cláusula if y else restante en el árbol. Si ninguna condición se evalúa como TRUE, R ejecutará la declaración else final.\nSi dos sentencias if describen eventos que se excluyen mutuamente, es mejor unir las sentencias if con else if que listarlas por separado. Esto le permite a R ignorar la segunda declaración if siempre que la primera devuelva un TRUE, lo que ahorra trabajo.\nPuede usar if y else para vincular las subtareas en su función de máquina tragamonedas. Abra un script R nuevo y copie este código en él. El código será el esqueleto de nuestra función puntuación final. Compáralo con el diagrama de flujo para puntuación en la Figura Figura 7.2:\nif ( # Caso 1: todos son iguales &lt;1&gt;) {\n  premio &lt;- # Buscar el premio &lt;3&gt;\n} else if ( # Caso 2: todos barras &lt;2&gt; ) {\n  premio &lt;- # asignar $5 &lt;4&gt;\n} else {\n  # contar cerezas &lt;5&gt;\n  premio &lt;- # calcular el premio &lt;7&gt;\n}\n\n# contar diamantes &lt;6&gt;\n# duplicar el premio si es necesario &lt;8&gt;\nNuestro esqueleto es bastante incompleto; hay muchas secciones que son solo comentarios de código en lugar de código real. Sin embargo, hemos reducido el programa a ocho subtareas simples:\n\nPrueba si los símbolos son tres de una clase.\nPrueba si los símbolos son solo barras.\nBusque el premio de tres iguales según el símbolo común.\nAsigne un premio de $5.\nCuenta el número de cerezas.\nCuenta el número de diamantes.\nCalcula un premio basado en el número de cerezas.\nAjustar el premio por diamantes.\n\nSi lo desea, puede reorganizar su diagrama de flujo en torno a estas tareas, como en la Figura Figura 7.4. El gráfico describirá la misma estrategia, pero de una manera más precisa. Usaré una forma de diamante para simbolizar una decisión if else.\n\n\n\n\n\n\n\nFigura 7.4: puntuacion puede navegar tres casos con dos decisiones if else. También podemos dividir algunas de nuestras tareas en dos pasos.\n\n\n\n\nAhora podemos trabajar en las subtareas una a la vez, agregando código de R al árbol if a medida que avanzamos. Cada subtarea será fácil de resolver si configura un ejemplo concreto para trabajar e intenta describir una solución en español antes de codificar en R.\nLa primera subtarea le pide que pruebe si los símbolos son tres de una clase. ¿Cómo debería comenzar a escribir el código para esta subtarea?\nSabes que la función puntuacion final se verá así:\npuntuacion &lt;- function(simbolos) {\n\n  # calcular el premio\n\n  premio\n}\nSu argumento, simbolos, será la salida de obt_simbolos, un vector que contiene tres cadenas de caracteres. Podría comenzar a escribir puntuacion como lo he escrito, definiendo un objeto llamado puntuacion y luego completando lentamente el cuerpo de la función. Sin embargo, esto sería una mala idea. La función eventual tendrá ocho partes separadas, y no funcionará correctamente hasta que todas esas partes estén escritas (y funcionen correctamente). Esto significa que tendría que escribir toda la función puntuacion antes de poder probar cualquiera de las subtareas. Si puntuacion no funciona, lo cual es muy probable, no sabrá qué subtarea debe corregirse.\nPuede ahorrarse tiempo y dolores de cabeza si se enfoca en una subtarea a la vez. Para cada subtarea, cree un ejemplo concreto en el que pueda probar su código. Por ejemplo, sabe que puntuacion necesitará trabajar en un vector llamado simbolos que contiene tres cadenas de caracteres. Si crea un vector real llamado simbolos, puede ejecutar el código para muchas de sus subtareas en el vector a medida que avanza:\nsimbolos &lt;- c(\"7\", \"7\", \"7\")\nSi una pieza de código no funciona en simbolos, sabrá que necesita arreglarlo antes de continuar. Puedes cambiar el valor de simbolos de subtarea a subtarea para asegurarte de que tu código funcione en todas las situaciones:\nsimbolos &lt;- c(\"B\", \"BB\", \"BBB\")\nsimbolos &lt;- c(\"C\", \"DD\", \"0\")\nSolo combine sus subtareas en una función de puntuacion una vez que cada subtarea funcione en un ejemplo concreto. Si sigue este plan, pasará más tiempo usando sus funciones y menos tratando de averiguar por qué no funcionan.\nDespués de establecer un ejemplo concreto, intente describir cómo realizará la subtarea en español. Cuanto más precisamente pueda describir su solución, más fácil será escribir su código de R.\nNuestra primera subtarea nos pide que “probemos si los símbolos son tres iguales”. Esta frase no me sugiere ningún código de R útil. Sin embargo, podría describir una prueba más precisa para el trío: tres símbolos serán iguales si el primer símbolo es igual al segundo y el segundo símbolo es igual al tercero. O, aún más precisamente:\nUn vector llamado simbolos contendrá tres del mismo símbolo si el primer elemento de simbolos es igual al segundo elemento de simbolos y el segundo elemento de simbolos es igual al tercer elemento de simbolos.\nEjercicio 10.4 (Escribe una Prueba) Convierta la declaración anterior en una prueba lógica escrita en R. Use su conocimiento de pruebas lógicas, operadores booleanos y subconjuntos de Notación de R. La prueba debería funcionar con el vector simbolos y devolver un TRUE si y solo si cada elemento en simbolos es el mismo. Asegúrese de probar su código en simbolos.\nSolución. Aquí hay un par de formas de probar que simbolos contiene tres del mismo símbolo. El primer método es paralelo a la sugerencia en español anterior, pero hay otras formas de hacer la misma prueba. No hay una respuesta correcta o incorrecta, siempre y cuando su solución funcione, lo cual es fácil de comprobar porque ha creado un vector llamado simbolos:\nsimbolos\n##  \"7\" \"7\" \"7\"\n\nsimbolos[1] == simbolos[2] & simbolos[2] == simbolos[3]\n## TRUE\n\nsimbolos[1] == simbolos[2] & simbolos[1] == simbolos[3]\n## TRUE\n\nall(simbolos == simbolos[1])\n## TRUE\nA medida que su vocabulario de funciones de R se amplíe, pensará en más formas de realizar tareas básicas. Un método que me gusta para verificar si tres son iguales es:\nlength(unique(simbolos)) == 1\nLa función unique devuelve cada término único que aparece en un vector. Si su vector simbolos contiene tres iguales (es decir, un término único que aparece tres veces), entonces unique(simbolos) devolverá un vector de longitud 1.\nAhora que tiene una prueba que funciona, puede agregarla a la secuencia de comandos de su máquina tragamonedas:\niguales &lt;- simbolos[1] == simbolos[2] && simbolos[2] == simbolos[3]\n\nif (iguales) {\n  premio &lt;- # Buscar el premio\n} else if ( # Caso 2: todos barras) {\n  premio &lt;- # asignar $5\n} else {\n  # contar cerezas\n  premio &lt;- # calcular el premio\n}\n\n# contar diamantes\n# duplicar el premio si es necesario\n\n\n\n\n\n\n&& y || se comportan como & y | pero a veces pueden ser más eficientes. Los operadores dobles no evaluarán la segunda prueba en un par de pruebas si la primera prueba aclara el resultado. Por ejemplo, si simbolos[1] no es igual a simbolos[2] en la siguiente expresión, && no evaluará simbolos[2] == simbolos[3]; puede devolver inmediatamente un FALSE para toda la expresión (porque FALSE & TRUE y FALSE & FALSE ambos se evalúan como FALSE). Esta eficiencia puede acelerar sus programas; sin embargo, los operadores dobles no son apropiados en todas partes. && y || no están vectorizados, lo que significa que solo pueden manejar una sola prueba lógica en cada lado del operador.\n\n\n\nEl segundo caso de premio ocurre cuando todos los símbolos son un tipo de barra, por ejemplo, B, BB y BBB. Empecemos por crear un ejemplo concreto con el que trabajar:\nsimbolos &lt;- c(\"B\", \"BBB\", \"BB\")\nEjercicio 10.5 (Probar si todos son barras) Use los operadores lógicos y booleanos de R para escribir una prueba que determinará si un vector llamado simbolos contiene solo símbolos que son un tipo de barra. Compruebe si su prueba funciona con nuestro vector de simbolos de ejemplo. Recuerde describir cómo debería funcionar la prueba en español y luego convertir la solución a R.\nSolución. Al igual que con muchas cosas en R, hay varias formas de probar si los simbolos contienen todos barras. Por ejemplo, podría escribir una prueba muy larga que use múltiples operadores booleanos, como esta:\n(simbolos[1] == \"B\" | simbolos[1] == \"BB\" | simbolos[1] == \"BBB\") &\n  (simbolos[2] == \"B\" | simbolos[2] == \"BB\" | simbolos[2] == \"BBB\") &\n  (simbolos[3] == \"B\" | simbolos[3] == \"BB\" | simbolos[3] == \"BBB\")\n## TRUE\nSin embargo, esta no es una solución muy eficiente, porque R tiene que ejecutar nueve pruebas lógicas (y usted tiene que escribirlas). A menudo puede reemplazar múltiples operadores | con un único %in%. Además, puede verificar que una prueba sea verdadera para cada elemento en un vector con all. Estos dos cambios acortan el código anterior a:\nall(simbolos %in% c(\"B\", \"BB\", \"BBB\"))\n## TRUE\nAgreguemos este código a nuestro script:\niguales &lt;- simbolos[1] == simbolos[2] && simbolos[2] == simbolos[3]\nbarras &lt;- simbolos %in% c(\"B\", \"BB\", \"BBB\")\n\nif (iguales) {\n  prize &lt;- # Buscar el premio\n} else if (all(barras)) {\n  prize &lt;- # asiganr $5\n} else {\n  # contar cerezas\n  premio &lt;- # calcular el premio\n}\n\n# contar diamantes\n# duplicar el premio si es necesario\nEs posible que haya notado que dividí esta prueba en dos pasos, barras y all(barras). Eso es solo una cuestión de preferencia personal. Siempre que sea posible, me gusta escribir mi código para que pueda leerse con nombres de funciones y objetos que transmitan lo que hacen.\nTambién puede haber notado que nuestra prueba para el Caso 2 capturará algunos símbolos que deberían estar en el Caso 1 porque contienen tres de una clase:\nsimbolos &lt;- c(\"B\", \"B\", \"B\")\nall(simbolos %in% c(\"B\", \"BB\", \"BBB\"))\n## TRUE\nEso no será un problema, sin embargo, porque hemos conectado nuestros casos con else if en el árbol if. Tan pronto como R llegue a un caso que se evalúe como VERDADERO, se saltará el resto del árbol. Piénselo de esta manera: cada else le dice a R que solo ejecute el código que le sigue si no se ha cumplido ninguna de las condiciones anteriores. Entonces, cuando tenemos tres del mismo tipo de barra, R evaluará el código para el Caso 1 y luego omitirá el código para el Caso 2 (y el Caso 3).\nNuestra próxima subtarea es asignar un premio a los simbolos. Cuando el vector de simbolos contiene tres del mismo símbolo, el premio dependerá de qué símbolo haya tres. Si hay tres DDs, el premio será de $100; si hay tres 7s, el premio será de $80; y así.\nEsto sugiere otro árbol if. Podrías asignar un premio con algún código como este:\nif (iguales) {\n  simbolo &lt;- simbolos[1]\n  if (simbolo == \"DD\") {\n    premmio &lt;- 800\n  } else if (simbolo == \"7\") {\n    premio &lt;- 80\n  } else if (simbolo == \"BBB\") {\n    premio &lt;- 40\n  } else if (simbolo == \"BB\") {\n    premio &lt;- 5\n  } else if (simbolo == \"B\") {\n    premio &lt;- 10\n  } else if (simbolo == \"C\") {\n    premio &lt;- 10\n  } else if (simbol == \"0\") {\n    premio &lt;- 0\n  }\n}\nSi bien este código funcionará, es un poco largo de escribir y leer, y puede requerir que R realice varias pruebas lógicas antes de entregar el premio correcto. Podemos hacerlo mejor con un método diferente.",
    "crumbs": [
      "Proyecto 3: Máquina Tragamonedas",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Programas</span>"
    ]
  },
  {
    "objectID": "programs.html#tablas-de-búsqueda",
    "href": "programs.html#tablas-de-búsqueda",
    "title": "7  Programas",
    "section": "\n7.4 Tablas de Búsqueda",
    "text": "7.4 Tablas de Búsqueda\nMuy a menudo en R, la forma más sencilla de hacer algo implicará la creación de subconjuntos. ¿Cómo podrías usar subconjuntos aquí? Como conoce la relación exacta entre los símbolos y sus premios, puede crear un vector que capture esta información. Este vector puede almacenar símbolos como nombres y valores de premios como elementos:\npagos &lt;- c(\"DD\" = 100, \"7\" = 80, \"BBB\" = 40, \"BB\" = 25, \n  \"B\" = 10, \"C\" = 10, \"0\" = 0)\npagos\n##  DD   7 BBB  BB   B   C   0 \n## 100  80  40  25  10  10   0 \nAhora puede extraer el premio correcto para cualquier símbolo subdividiendo el vector con el nombre del símbolo:\npagos[\"DD\"]\n##  DD \n## 100 \n\npagos[\"B\"]\n##  B\n## 10\nSi desea dejar atrás el nombre del símbolo al crear subconjuntos, puede ejecutar la función unname en la salida:\nunname(pagos[\"DD\"])\n## 100 \nunname devuelve una copia de un objeto con el atributo de nombres eliminado.\npagos es un tipo de tabla de búsqueda, un objeto de R que puede usar para buscar valores. Subdividir pagos proporciona una forma sencilla de encontrar el premio de un símbolo. No requiere muchas líneas de código y hace la misma cantidad de trabajo ya sea que su símbolo sea DD o 0. Puede crear tablas de búsqueda en R mediante la creación de objetos con nombre que se pueden dividir en subconjuntos de formas inteligentes.\nLamentablemente, nuestro método no es del todo automático; necesitamos decirle a R qué símbolo buscar en pagos. ¿Tenemos? ¿Qué pasaría si dividieras los pagos por simbolos[1]? Probemos:\nsimbolos &lt;- c(\"7\", \"7\", \"7\")\nsimbolos[1]\n## \"7\"\n\npagos[simbolos[1]]\n##  7 \n## 80 \n\nsimbolos &lt;- c(\"C\", \"C\", \"C\")\npagos[simbolos[1]]\n##  C \n## 10 \nNo necesita saber el símbolo exacto para buscar porque puede decirle a R que busque cualquier símbolo que esté en simbolos. Puede encontrar este símbolo con simbolos[1], simbolos[2] o simbolos[3], porque cada uno contiene el mismo símbolo en este caso. Ahora tiene una forma sencilla y automatizada de calcular el premio cuando los simbolos contienen tres iguales. Vamos a agregarlo a nuestro código y luego veamos el Caso 2:\niguales &lt;- simbolos[1] == simbolos[2] && simbolos[2] == simbolos[3]\nbarras &lt;- simbolos %in% c(\"B\", \"BB\", \"BBB\")\n\nif (iguales) {\n  pagos &lt;- c(\"DD\" = 100, \"7\" = 80, \"BBB\" = 40, \"BB\" = 25, \n    \"B\" = 10, \"C\" = 10, \"0\" = 0)\n  premio &lt;- unname(pagos[simbolos[1]])\n} else if (all(barras)) {\n  premio &lt;- # asignar $5\n} else {\n  # contar cerezas\n  premio &lt;- # calcular el premio\n}\n\n# contar diamantes\n# duplicar el premio si es necesario\nEl caso 2 ocurre cuando los símbolos son todos barras. En ese caso, el premio será de $5, que es fácil de asignar:\niguales &lt;- simbolos[1] == simbolos[2] && simbolos[2] == simbolos[3]\nbarras &lt;- simbolos %in% c(\"B\", \"BB\", \"BBB\")\n\nif (iguales) {\n  pagos &lt;- c(\"DD\" = 100, \"7\" = 80, \"BBB\" = 40, \"BB\" = 25, \n    \"B\" = 10, \"C\" = 10, \"0\" = 0)\n  premio &lt;- unname(pagos[simbolos[1]])\n} else if (all(barras)) {\n  premio &lt;- 5\n} else {\n  # contar cerezas\n  premio &lt;- # calcular el premio\n}\n\n# contar diamantes\n# duplicar el premio si es necesario\nAhora podemos trabajar en el último caso. Aquí, necesitará saber cuántas cerezas hay en los simbolos antes de poder calcular un premio.\nEjercicio 10.6 (Encuentra las C) ¿Cómo puedes saber qué elementos de un vector llamado simbolos son una C? Diseñe una prueba y pruébela.\n\n\n\n\n\n\nDesafío\n¿Cómo podrías contar el número de ‘C’ en un vector llamado ‘símbolos’? Recuerda las reglas de coerción de R.\n\n\n\nSolución. Como siempre, trabajemos con un ejemplo real:\nsimbolos &lt;- c(\"C\", \"DD\", \"C\")\nUna forma de probar las cerezas sería verificar cuál de los símbolos, si alguno, es una C:\nsimbolos == \"C\"\n## TRUE FALSE  TRUE\nSería aún más útil contar cuántos de los símbolos son cerezas. Puede hacer esto con sum, que espera una entrada numérica, no lógica. Sabiendo esto, R forzará los TRUE y FALSE a 1 y 0 antes de hacer la suma. Como resultado, sum devolverá el número de TRUE, que también es el número de cerezas:\nsum(simbolos == \"C\")\n## 2\nPuede usar el mismo método para contar la cantidad de diamantes en simbolos:\nsum(simbolos == \"DD\")\n## 1\nAgreguemos estas dos subtareas al esqueleto del programa:\niguales &lt;- simbolos[1] == simbolos[2] && simbolos[2] == simbolos[3]\nbarras &lt;- simbolos %in% c(\"B\", \"BB\", \"BBB\")\n\nif (iguales) {\n  pagos &lt;- c(\"DD\" = 100, \"7\" = 80, \"BBB\" = 40, \"BB\" = 25, \n    \"B\" = 10, \"C\" = 10, \"0\" = 0)\n  premio &lt;- unname(pagos[simbolos[1]])\n} else if (all(barras)) {\n  premio &lt;- 5\n} else {\n  cerezas &lt;- sum(simbolos == \"C\")\n  premio &lt;- # calcular el premio\n}\n\ndiamantes &lt;- sum(simbolos == \"DD\")\n# duplicar el premio si es necesario\nDado que el Caso 3 aparece más abajo en el árbol if que los Casos 1 y 2, el código del Caso 3 solo se aplicará a los jugadores que no tengan trío o todas las barras. De acuerdo con el esquema de pagos de la máquina tragamonedas, estos jugadores ganarán $5 si tienen dos cerezas y $2 si tienen una cereza. Si el jugador no tiene cerezas, obtiene un premio de $0. No necesitamos preocuparnos por tres cerezas porque ese resultado ya está cubierto en el Caso 1.\nComo en el Caso 1, podría escribir un árbol if que maneje cada combinación de cerezas, pero al igual que en el Caso 1, esta sería una solución ineficiente:\nif (cerezas == 2) {\n  premio &lt;- 5\n} else if (cerezas == 1) {\n  premio &lt;- 2\n} else {}\n  premio &lt;- 0\n}\nNuevamente, creo que la mejor solución implicará subconjuntos. Si se siente ambicioso, puede intentar resolver esta solución por su cuenta, pero aprenderá con la misma rapidez trabajando mentalmente en la siguiente solución propuesta.\nSabemos que nuestro premio debe ser $0 si no tenemos cerezas, $2 si tenemos una cereza y $5 si tenemos dos cerezas. Puede crear un vector que contenga esta información. Esta será una tabla de búsqueda muy simple:\nc(0, 2, 5)\nAhora, como en el Caso 1, puede crear subconjuntos del vector para recuperar el premio correcto. En este caso, los premios no se identifican con el nombre de un símbolo, sino con el número de cerezas presentes. ¿Tenemos esa información? Sí, se almacena en cerezas. Podemos usar subconjuntos enteros básicos para obtener el premio correcto de la tabla de búsqueda anterior, por ejemplo, c(0, 2, 5)[1].\ncerezas no es exactamente adecuado para subconjuntos enteros porque podría contener un cero, pero eso es fácil de arreglar. Podemos crear un subconjunto con cerezas + 1. Ahora, cuando cerezas es igual a cero, tenemos:\ncerezas + 1\n## 1\n\nc(0, 2, 5)[cerezas + 1]\n## 0\nCuando cerezas es igual a uno, tenemos:\ncerezas + 1\n## 2\n\nc(0, 2, 5)[cerezas + 1]\n## 2\nY cuando cerezas es igual a dos, tenemos:\ncerezas + 1\n## 3\n\nc(0, 2, 5)[cerezas + 1]\n## 5\nExamine estas soluciones hasta que esté seguro de que arrojan el premio correcto por cada número de cerezas. Luego agregue el código a su secuencia de comandos, de la siguiente manera:\niguales &lt;- simbolos[1] == simbolos[2] && simbolos[2] == simbolos[3]\nbarras &lt;- simbolos %in% c(\"B\", \"BB\", \"BBB\")\n\nif (iguales) {\n  pagos &lt;- c(\"DD\" = 100, \"7\" = 80, \"BBB\" = 40, \"BB\" = 25, \n    \"B\" = 10, \"C\" = 10, \"0\" = 0)\n  premio &lt;- unname(pagos[simbolos[1]])\n} else if (all(barras)) {\n  premio &lt;- 5\n} else {\n  cerezas &lt;- sum(simbolos == \"C\")\n  premio &lt;- c(0, 2, 5)[cerezas + 1]\n}\n\ndiamantes &lt;- sum(simbolos == \"DD\")\n# duplicar el premio si es necesario\n\n\n\n\n\n\nTablas de Búsqueda vs Árboles if\nEsta es la segunda vez que creamos una tabla de búsqueda para evitar escribir un árbol if. ¿Por qué es útil esta técnica y por qué sigue apareciendo? Muchos árboles if en R son esenciales. Proporcionan una forma útil de decirle a R que use diferentes algoritmos en diferentes casos. Sin embargo, los árboles if no son apropiados en todas partes.\nLos if árboles tienen un par de inconvenientes. En primer lugar, requieren que R ejecute varias pruebas a medida que avanza por el árbol if, lo que puede generar trabajo innecesario. En segundo lugar, como verá en Velocidad, puede ser difícil usar árboles if en código vectorizado, un estilo de código que aprovecha las fortalezas de programación de R para crear programas rápidos. Las tablas de búsqueda no sufren ninguno de estos inconvenientes.\nNo podrá reemplazar cada árbol if con una tabla de búsqueda, ni debería hacerlo. Sin embargo, generalmente puede usar tablas de búsqueda para evitar asignar variables con árboles if. Como regla general, use un árbol if si cada rama del árbol ejecuta un código diferente. Use una tabla de búsqueda si cada rama del árbol solo asigna un valor diferente.\nPara convertir un árbol if en una tabla de búsqueda, identifique los valores que se asignarán y guárdelos en un vector. A continuación, identifique los criterios de selección utilizados en las condiciones del árbol if. Si las condiciones usan cadenas de caracteres, proporcione los nombres de sus vectores y use subconjuntos basados en nombres. Si las condiciones usan números enteros, use subconjuntos basados en números enteros.\n\n\n\nLa subtarea final es duplicar el premio una vez por cada diamante presente. Esto significa que el premio final será un múltiplo del premio actual. Por ejemplo, si no hay diamantes presentes, el premio será:\npremio * 1      # 1 = 2 ^ 0\nSi un diamante está presente, será:\npremio * 2      # 2 = 2 ^ 1\nSi hay dos diamantes presentes, será:\npremio * 4      # 4 = 2 ^ 2\nY si hay tres diamantes presentes, será:\npremio * 8      # 8 = 2 ^ 3\n¿Puedes pensar en una manera fácil de manejar esto? ¿Qué tal algo similar a estos ejemplos?\nEjercicio 10.7 (Adjuste para Diamantes) Escribe un método para ajustar el premio basado en diamantes. Describa primero una solución en español y luego escriba su código.\nSolución. Aquí hay una solución concisa inspirada en el patrón anterior. El premio ajustado será igual a:\npremio * 2 ^ diamantes\nlo que nos da nuestro script final de puntuacion:\niguales &lt;- simbolos[1] == simbolos[2] && simbolos[2] == simbolos[3]\nbarras &lt;- simbolos %in% c(\"B\", \"BB\", \"BBB\")\n\nif (iguales) {\n  pagos &lt;- c(\"DD\" = 100, \"7\" = 80, \"BBB\" = 40, \"BB\" = 25, \n             \"B\" = 10, \"C\" = 10, \"0\" = 0)\n  premio &lt;- unname(pagos[simbolos[1]])\n} else if (all(barras)) {\n  premio &lt;- 5\n} else {\n  cerezas &lt;- sum(simbolos == \"C\")\n  premio &lt;- c(0, 2, 5)[cerezas + 1]\n}\n\ndiamantes &lt;- sum(simbolos == \"DD\")\npremio * 2 ^ diamantes",
    "crumbs": [
      "Proyecto 3: Máquina Tragamonedas",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Programas</span>"
    ]
  },
  {
    "objectID": "programs.html#comentarios-de-código",
    "href": "programs.html#comentarios-de-código",
    "title": "7  Programas",
    "section": "\n7.5 Comentarios de Código",
    "text": "7.5 Comentarios de Código\nAhora tiene un script de puntuacion que puede guardar en una función. Sin embargo, antes de guardar su secuencia de comandos, considere agregar comentarios a su código con un #. Los comentarios pueden hacer que su código sea más fácil de entender al explicar por qué el código hace lo que hace. También puede usar comentarios para dividir programas largos en fragmentos escaneables. Por ejemplo, incluiría tres comentarios en el código puntuacion:\n# identificar caso\niguales &lt;- simbolos[1] == simbolos[2] && simbolos[2] == simbolos[3]\nbarras &lt;- simbolos %in% c(\"B\", \"BB\", \"BBB\")\n\n# obtener premio\nif (iguales) {\n  pagos &lt;- c(\"DD\" = 100, \"7\" = 80, \"BBB\" = 40, \"BB\" = 25, \n             \"B\" = 10, \"C\" = 10, \"0\" = 0)\n  premio &lt;- unname(pagos[simbolos[1]])\n} else if (all(barras)) {\n  premio &lt;- 5\n} else {\n  cerezas &lt;- sum(simbolos == \"C\")\n  premio &lt;- c(0, 2, 5)[cerezas + 1]\n}\n\n# ajustar para diamantes\ndiamantes &lt;- sum(simbolos == \"DD\")\npremio * 2 ^ diamantes\nAhora que cada parte de tu código funciona, puedes envolverlo en una función con los métodos que aprendiste en Escribir tus propias funciones. Utilice la opción Extract Function de RStudio en la barra de menú en Code, o utilice la función function. Asegúrese de que la última línea de la función devuelva un resultado (lo hace) e identifique los argumentos utilizados por su función. A menudo, los ejemplos concretos que utilizó para probar su código, como símbolos, se convertirán en los argumentos de su función. Ejecute el siguiente código para comenzar a usar la función puntuacion:\npuntuacion &lt;- function (simbolos) {\n  # identificar caso\n  iguales &lt;- simbolos[1] == simbolos[2] && simbolos[2] == simbolos[3]\n  barras &lt;- simbolos %in% c(\"B\", \"BB\", \"BBB\")\n\n  # obtener premio\n  if (iguales) {\n    pagos &lt;- c(\"DD\" = 100, \"7\" = 80, \"BBB\" = 40, \"BB\" = 25, \n             \"B\" = 10, \"C\" = 10, \"0\" = 0)\n    premio &lt;- unname(pagos[simbolos[1]])\n  } else if (all(barras)) {\n    premio &lt;- 5\n  } else {\n    cerezas &lt;- sum(simbolos == \"C\")\n    premio &lt;- c(0, 2, 5)[cerezas + 1]\n  }\n\n  # ajustar para diamantes\n  diamantes &lt;- sum(simbolos == \"DD\")\n  premio * 2 ^ diamantes\n}\nUna vez que haya definido la función puntuacion, la función play también funcionará:\nplay &lt;- function() {\n  simbolos &lt;- obt_simbolos()\n  print(simbolos)\n  puntuacion(simbolos)\n}\nAhora es fácil jugar en la máquina tragamonedas:\nplay()\n## \"0\"  \"BB\" \"B\" \n## 0\n\nplay()\n## \"DD\"  \"0\" \"B\"  \n## 0\n\nplay()\n## \"BB\" \"BB\" \"B\" \n## 25",
    "crumbs": [
      "Proyecto 3: Máquina Tragamonedas",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Programas</span>"
    ]
  },
  {
    "objectID": "programs.html#resumen",
    "href": "programs.html#resumen",
    "title": "7  Programas",
    "section": "\n7.6 Resumen",
    "text": "7.6 Resumen\nUn programa en R es un conjunto de instrucciones que su computadora debe seguir y que se ha organizado en una secuencia de pasos y casos. Esto puede hacer que los programas parezcan simples, pero no se deje engañar: puede crear resultados complicados con la combinación correcta de pasos simples (y casos).\nComo programador, es más probable que te engañen de la manera opuesta. Un programa puede parecer imposible de escribir cuando sabes que debe hacer algo impresionante. No se asuste en estas situaciones. Divida el trabajo que tiene delante en tareas simples y luego vuelva a dividir las tareas. Puede visualizar la relación entre las tareas con un diagrama de flujo si le ayuda. Luego trabaje en las subtareas una a la vez. Describa las soluciones en español y luego conviértalas a código de R. Pruebe cada solución con ejemplos concretos a medida que avanza. Una vez que cada una de sus subtareas funcione, combine su código en una función que pueda compartir y reutilizar.\nR proporciona herramientas que pueden ayudarlo a hacer esto. Puede administrar casos con declaraciones if y else. Puede crear una tabla de búsqueda con objetos y subconjuntos. Puede agregar comentarios de código con #. Y puede guardar sus programas como una función con function\nLas cosas suelen salir mal cuando la gente escribe programas. Dependerá de usted encontrar la fuente de cualquier error que ocurra y corregirlo. Debería ser fácil encontrar la fuente de sus errores si utiliza un enfoque paso a paso para escribir funciones, escribir y luego probar, un poco a la vez. Sin embargo, si la fuente de un error se le escapa, o se encuentra trabajando con grandes fragmentos de código no probado, considere usar las herramientas de depuración integradas de R, descritas en Depuración de Código de R.\nLos siguientes dos capítulos le enseñarán más herramientas que puede usar en sus programas. A medida que domine estas herramientas, le resultará más fácil escribir programas en R que le permitan hacer lo que desee con sus datos. En S3, aprenderá a usar el sistema S3 de R, una mano invisible que da forma a muchas partes de R. Usará el sistema para crear una clase personalizada para la salida de su máquina tragamonedas y le dirá a R cómo mostrar objetos que tienen tu clase.",
    "crumbs": [
      "Proyecto 3: Máquina Tragamonedas",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Programas</span>"
    ]
  },
  {
    "objectID": "s3.html",
    "href": "s3.html",
    "title": "8  S3",
    "section": "",
    "text": "8.1 El Sistema S3\nEs posible que haya notado que los resultados de su máquina tragamonedas no se ven como prometí. Sugerí que la máquina tragamonedas mostraría sus resultados así:\nPero la máquina actual muestra sus resultados en un formato menos bonito:\nAdemás, la máquina tragamonedas usa un truco para mostrar símbolos (llamamos print desde dentro de play). Como resultado, los símbolos no siguen la salida de su premio si lo guarda:\nPuede solucionar ambos problemas con el sistema S3 de R.\nS3 se refiere a un sistema de clases integrado en R. El sistema rige cómo R maneja objetos de diferentes clases. Ciertas funciones de R buscarán la clase S3 de un objeto y luego se comportarán de manera diferente en respuesta.\nLa función print es así. Cuando imprime un vector numérico, print mostrará un número:\nPero si le da ese número a la clase S3 POSIXct seguida de POSIXt, print mostrará una hora:\nSi usa objetos con clases, y lo hace, se encontrará con el sistema S3 de R. El comportamiento de S3 puede parecer extraño al principio, pero es fácil de predecir una vez que se familiariza con él.\nEl sistema S3 de R se basa en tres componentes: atributos (especialmente el atributo class), funciones genéricas y métodos.",
    "crumbs": [
      "Proyecto 3: Máquina Tragamonedas",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>S3</span>"
    ]
  },
  {
    "objectID": "s3.html#el-sistema-s3",
    "href": "s3.html#el-sistema-s3",
    "title": "8  S3",
    "section": "",
    "text": "num &lt;- 1000000000\nprint(num)\n## 1000000000\n\nclass(num) &lt;- c(\"POSIXct\", \"POSIXt\")\nprint(num)\n## \"2001-09-08 19:46:40 CST\"",
    "crumbs": [
      "Proyecto 3: Máquina Tragamonedas",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>S3</span>"
    ]
  },
  {
    "objectID": "s3.html#atributos",
    "href": "s3.html#atributos",
    "title": "8  S3",
    "section": "8.2 Atributos",
    "text": "8.2 Atributos\nEn Atributos, aprendió que muchos objetos de R vienen con atributos, piezas de información adicional a las que se les da un nombre y se agregan al objeto. Los atributos no afectan los valores del objeto, pero se adhieren al objeto como un tipo de metadatos que R puede usar para manejar el objeto. Por ejemplo, un data frame almacena sus nombres de fila y columna como atributos. Los data frame también almacenan su clase, \"data.frame\", como un atributo.\nPuede ver los atributos de un objeto con attribute. Si ejecuta attribute en el data frame mazo que creó en Proyecto 2: Baraja de Cartas, verá:\nattributes(mazo)\n## $names\n## [1] \"cara\"  \"palo\"  \"valor\"\n## \n## $class\n## [1] \"data.frame\"\n## \n## $row.names\n##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 \n## [20] 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36\n## [37] 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52\nR viene con muchas funciones auxiliares que le permiten establecer y acceder a los atributos más comunes utilizados en R. Ya conoce las funciones names, dim y class, cada una de las cuales funciona con un atributo con nombre homónimo. Sin embargo, R también tiene row.names, levels y muchas otras funciones auxiliares basadas en atributos. Puede utilizar cualquiera de estas funciones para recuperar el valor de un atributo:\nrow.names(mazo)\n##  [1] \"1\"  \"2\"  \"3\"  \"4\"  \"5\"  \"6\"  \"7\"  \"8\"  \"9\"  \"10\" \"11\" \"12\" \"13\"\n## [14] \"14\" \"15\" \"16\" \"17\" \"18\" \"19\" \"20\" \"21\" \"22\" \"23\" \"24\" \"25\" \"26\"\n## [27] \"27\" \"28\" \"29\" \"30\" \"31\" \"32\" \"33\" \"34\" \"35\" \"36\" \"37\" \"38\" \"39\"\n## [40] \"40\" \"41\" \"42\" \"43\" \"44\" \"45\" \"46\" \"47\" \"48\" \"49\" \"50\" \"51\" \"52\"\no para cambiar el valor de un atributo:\nrow.names(mazo) &lt;- 101:152\no para dar a un objeto un atributo completamente nuevo:\nlevels(mazo) &lt;- c(\"level 1\", \"level 2\", \"level 3\")\n\nattributes(mazo)\n## $names\n## [1] \"cara\"  \"palo\"  \"valor\"\n## \n## $class\n## [1] \"data.frame\"\n## \n## $row.names\n##  [1] 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117\n## [18] 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134\n## [35] 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151\n## [52] 152\n## \n## $levels\n## [1] \"level 1\" \"level 2\" \"level 3\"\nR es muy libre cuando se trata de atributos. Le permitirá agregar cualquier atributo que desee a un objeto (y luego generalmente los ignorará). La única vez que R se quejará es cuando una función necesita encontrar un atributo y no está allí.\nPuede agregar cualquier atributo general a un objeto con attr; también puede usar attr para buscar el valor de cualquier atributo de un objeto. Veamos cómo funciona esto con a_play, el resultado de jugar nuestra máquina tragamonedas una vez:\na_play &lt;- play()\na_play\n## 0\n\nattributes(a_play)\n## NULL\nattr toma dos argumentos: un objeto de R y el nombre de un atributo (como una cadena de caracteres). Para darle al objeto de R un atributo del nombre especificado, guarde un valor en la salida de attr. Démosle a a_play un atributo llamado simbolos que contiene un vector de cadenas de caracteres:\nattr(a_play, \"simbolos\") &lt;- c(\"B\", \"0\", \"B\")\n\nattributes(a_play)\n## $simbolos\n## [1] \"B\" \"0\" \"B\"\nPara buscar el valor de cualquier atributo, dale a attr un objeto R y el nombre del atributo que te gustaría buscar:\nattr(a_play, \"simbolos\")\n## \"B\" \"0\" \"B\"\nSi asigna un atributo a un vector atómico, como a_play, R generalmente mostrará el atributo debajo de los valores del vector. Sin embargo, si el atributo cambia la clase del vector, R puede mostrar toda la información en el vector de una nueva forma (como vimos con los objetos POSIXct):\na_play\n## [1] 0\n## attr(,\"simbolos\")\n## [1] \"B\" \"0\" \"B\"\nR generalmente ignorará los atributos de un objeto a menos que le des un nombre que busca una función de R, como names o class. Por ejemplo, R ignorará el atributo simbolos de a_play mientras manipulas a_play:\na_play + 1\n##  1\n## attr(,\"simbolos\")\n##  \"B\" \"0\" \"B\"\nEjercicio 11.1 (Añade un Atributo) Modifique play para devolver un premio que contenga los símbolos asociados a él como un atributo denominado simbolos. Elimine la llamada redundante a print(simbolos):\nplay &lt;- function() {\n  simbolos &lt;- obt_simbolos()\n  print(simbolos)\n  puntuacion(simbolos)\n}\nSolución. Puede crear una nueva versión de play capturando la salida de puntuacion(simbolos) y asignándole un atributo. play puede devolver la versión mejorada de la salida:\nplay &lt;- function() {\n  simbolos &lt;- obt_simbolos()\n  premio &lt;- puntuacion(simbolos)\n  attr(premio, \"simbolos\") &lt;- simbolos\n  premio\n}\nAhora play devuelve tanto el premio como los símbolos asociados con el premio. Puede que los resultados no se vean bonitos, pero los símbolos se quedan con el premio cuando lo copiamos a un nuevo objeto. Podemos trabajar en ordenar la pantalla en un minuto:\nplay()\n## [1] 0\n## attr(,\"simbolos\")\n## [1] \"B\"  \"BB\" \"0\" \n \nb_play &lt;- play()\n \nb_play\n## [1] 0\n## attr(,\"simbolos\")\n## [1] \"0\" \"B\" \"0\"\nTambién puede generar un premio y establecer sus atributos en un solo paso con la función structure. structure crea un objeto con un conjunto de atributos. El primer argumento de structure debe ser un objeto de R o un conjunto de valores, y los argumentos restantes deben ser atributos con nombre para que structure se agregue al objeto. Puede dar a estos argumentos cualquier nombre de argumento que desee. structure agregará los atributos al objeto bajo los nombres que proporcione como nombres de argumento:\nplay &lt;- function() {\n  simbolos &lt;- get_simbolos()\n  structure(puntuacion(simbolos), simbolos = simbolos)\n}\n\nc_play &lt;- play()\nc_play\n##  0\n##  attr(,\"simbolos\")\n##  \"0\"  \"BB\" \"B\" \nAhora que su salida play contiene un atributo simbolos, ¿qué puede hacer con él? Puede escribir sus propias funciones que busquen y usen el atributo. Por ejemplo, la siguiente función buscará el atributo simbolos de a_play y lo usará para mostrar a_play de una manera bonita. Usaremos esta función para mostrar los resultados de nuestra tragamonedas, así que tomemos un momento para estudiar lo que hace:\nmostrat_tragamoneda &lt;- function(premio){\n\n  # extraer simbolos\n  simbolos &lt;- attr(premio, \"simbolos\")\n\n  # colapsar símbolos en una sola cadena de caracteres\n  simbolos &lt;- paste(simbolos, collapse = \" \")\n\n  # combinar símbolo con premio como una cadena de caracteres\n  # \\n es una secuencia de escape especial para una nueva línea (i.e. return or enter)\n  texto &lt;- paste(simbolos, premio, sep = \"\\n$\")\n\n  # mostrar cadena de caracteres en la consola sin comillas\n  cat(texto)\n}\n\nmostrat_tragamoneda(a_play)\n## B 0 B\n## $0\nLa función espera un objeto como a_play que tiene tanto un valor numérico como un atributo de simbolos. La primera línea de la función buscará el valor del atributo simbolos y lo guardará como un objeto llamado simbolos. Hagamos un objeto simbolos de ejemplo para que podamos ver lo que hace el resto de la función. Podemos usar el atributo simbolos de a_play para hacer el trabajo. simbolos será un vector de cadenas de tres caracteres:\nsimbolos &lt;- attr(a_play, \"simbolos\")\n\nsimbolos\n## \"B\" \"0\" \"B\"\nA continuación, mostrat_tragamoneda usa paste para colapsar las tres cadenas en simbolos en una cadena de un solo carácter. paste colapsa un vector de cadenas de caracteres en una sola cadena cuando le das el argumento collapse. paste usará el valor de collapse para separar las cadenas anteriormente distintas. Por lo tanto, simbolos se convierte en B 0 B las tres cadenas separadas por un espacio:\nsimbolos &lt;- paste(simbolos, collapse = \" \")\n\nsimbolos\n## \"B 0 B\"\nNuestra función luego usa paste de una nueva forma para combinar simbolos con el valor de premio. paste combina objetos separados en una cadena de caracteres cuando le das un argumento sep. Por ejemplo, aquí paste combinará la cadena en simbolos, B 0 B, con el número en premio, 0. paste usará el valor del argumento sep para separar las entradas en el cadena nueva. Aquí, ese valor es \\n$, por lo que nuestro resultado se verá como \"B 0 B\\n$0\":\npremio &lt;- a_play\ntexto &lt;- paste(simbolos, premio, sep = \"\\n$\")\n\ntexto\n## \"B 0 B\\n$0\"\nLa última línea de mostrat_tragamoneda llama a cat en la nueva cadena. cat es como print; muestra su entrada en la línea de comando. Sin embargo, cat no encierra su salida entre comillas. cat también reemplaza cada \\n con una nueva línea o salto de línea. El resultado es lo que vemos. Tenga en cuenta que se ve exactamente como sugerí que nuestra salida play debería verse en Programas:\ncat(texto)\n## B 0 B\n## $0\nPuedes usar mostrat_tragamoneda para limpiar manualmente la salida de play:\nmostrat_tragamoneda(play())\n## C B 0\n## $2\n\nmostrat_tragamoneda(play())\n## 7 0 BB\n## $0\nEste método de limpieza de la salida requiere que intervengas manualmente en tu sesión de R (para llamar a mostrat_tragamoneda). Hay una función que puede usar para limpiar automáticamente la salida de play cada vez que se muestra. Esta función es print, y es una función genérica.",
    "crumbs": [
      "Proyecto 3: Máquina Tragamonedas",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>S3</span>"
    ]
  },
  {
    "objectID": "s3.html#funciones-genéricas",
    "href": "s3.html#funciones-genéricas",
    "title": "8  S3",
    "section": "8.3 Funciones Genéricas",
    "text": "8.3 Funciones Genéricas\nR usa print con más frecuencia de lo que piensas; R llama a print cada vez que muestra un resultado en la ventana de su consola. Esta llamada ocurre en segundo plano, por lo que no la nota; pero la llamada explica cómo la salida llega a la ventana de la consola (recuerde que print siempre imprime su argumento en la ventana de la consola). Esta llamada print también explica por qué la salida de print siempre coincide con lo que ve cuando muestra un objeto en la línea de comando:\nprint(pi)\n## 3.141593\n\npi\n## 3.141593\n\n\nprint(head(mazo))\n##  cara  palo valor\n##   rey picas    13\n## reina picas    12\n##  jota picas    11\n##  diez picas    10\n## nueve picas     9\n##  ocho picas     8\n\nhead(mazo)\n##  cara  palo valor\n##   rey picas    13\n## reina picas    12\n##  jota picas    11\n##  diez picas    10\n## nueve picas     9\n##  ocho picas     8\n\n\nprint(play())\n##  5\n## attr(,\"simbolos\")\n##  \"B\"  \"BB\" \"B\" \n\nplay()\n##  5\n## attr(,\"simbolos\")\n##  \"B\"  \"BB\" \"B\" \nPuede cambiar la forma en que R muestra la salida de su maquina tragamonedas reescribiendo print para que se vea como mostrat_tragamoneda. Entonces R mostraría la salida en el formato que hemos creado. Sin embargo, este método tendría efectos secundarios negativos. No desea que R llame a mostrat_tragamoneda cuando muestre un data frame, un vector numérico o cualquier otro objeto.\nAfortunadamente, print no es una función normal; es una función genérica. Esto significa que print está escrito de una manera que le permite hacer cosas diferentes en casos diferentes. Ya has visto este comportamiento en acción (aunque es posible que no te hayas dado cuenta). print hizo una cosa cuando miramos la versión sin clase de num:\nnum &lt;- 1000000000\nprint(num)\n## 1000000000\ny una cosa diferente cuando le dimos a num una clase:\nclass(num) &lt;- c(\"POSIXct\", \"POSIXt\")\nprint(num)\n## \"2001-09-08 19:46:40 CST\"\nEche un vistazo al código dentro de print para ver cómo lo hace. Puede imaginar que print busca el atributo de clase de su entrada y luego usa un árbol +if+ para elegir qué salida mostrar. Si esto te ocurrió, ¡buen trabajo! print hace algo muy similar, pero mucho más simple.",
    "crumbs": [
      "Proyecto 3: Máquina Tragamonedas",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>S3</span>"
    ]
  },
  {
    "objectID": "s3.html#métodos",
    "href": "s3.html#métodos",
    "title": "8  S3",
    "section": "8.4 Métodos",
    "text": "8.4 Métodos\nCuando llamas a print, print llama a una función especial, UseMethod:\nprint\n## function (x, ...) \n## UseMethod(\"print\")\n## &lt;bytecode: 0x7ffee4c62f80&gt;\n## &lt;environment: namespace:base&gt;\nUseMethod examina la clase de la entrada que proporcionas para el primer argumento de print y luego pasa todos tus argumentos a una nueva función diseñada para manejar esa clase de entrada. Por ejemplo, cuando le das a print un objeto POSIXct, UseMethod pasará todos los argumentos de print a print.POSIXct. R luego ejecutará print.POSIXct y devolverá los resultados:\nprint.POSIXct\n## function (x, ...) \n## {\n##     max.print &lt;- getOption(\"max.print\", 9999L)\n##     if (max.print &lt; length(x)) {\n##         print(format(x[seq_len(max.print)], usetz = TRUE), ...)\n##         cat(\" [ reached getOption(\\\"max.print\\\") -- omitted\", \n##             length(x) - max.print, \"entries ]\\n\")\n##     }\n##     else print(format(x, usetz = TRUE), ...)\n##     invisible(x)\n## }\n## &lt;bytecode: 0x7fa948f3d008&gt;\n## &lt;environment: namespace:base&gt;\nSi le das a print un objeto de factor, UseMethod pasará todos los argumentos de print a print.factor. R luego ejecutará print.factor y devolverá los resultados:\nprint.factor\n## function (x, quote = FALSE, max.levels = NULL, width = getOption(\"width\"), \n##     ...) \n## {\n##     ord &lt;- is.ordered(x)\n##     if (length(x) == 0L) \n##         cat(if (ord) \n##             \"ordered\"\n## ...\n##         drop &lt;- n &gt; maxl\n##         cat(if (drop) \n##             paste(format(n), \"\"), T0, paste(if (drop) \n##             c(lev[1L:max(1, maxl - 1)], \"...\", if (maxl &gt; 1) lev[n])\n##         else lev, collapse = colsep), \"\\n\", sep = \"\")\n##     }\n##     invisible(x)\n## }\n## &lt;bytecode: 0x7fa94a64d470&gt;\n## &lt;environment: namespace:base&gt;\nprint.POSIXct y print.factor se denominan métodos de print. Por sí mismos, print.POSIXct y print.factor funcionan como funciones regulares de R. Sin embargo, cada uno fue escrito específicamente para que ‘UseMethod’ pudiera llamarlo para manejar una clase específica de entrada de print.\nTenga en cuenta que print.POSIXct y print.factor hacen dos cosas diferentes (también tenga en cuenta que compendié la mitad de print.factor: es una función larga). Así es como print se las arregla para hacer diferentes cosas en diferentes casos. print llama a UseMethod, que llama a un método especializado basado en la clase del primer argumento de print.\nPuede ver qué métodos existen para una función genérica llamando a methods en la función. Por ejemplo, print tiene casi 200 métodos (lo que le da una idea de cuántas clases existen en R):\nmethods(print)\n##   [1] print.acf*                                   \n##   [2] print.anova                                  \n##   [3] print.aov*                                   \n##  ...                      \n## [176] print.xgettext*                              \n## [177] print.xngettext*                             \n## [178] print.xtabs*\n##\n##  Nonvisible functions are asterisked\nEste sistema de funciones genéricas, métodos y despacho basado en clases se conoce como S3 porque se originó en la tercera versión de S, el lenguaje de programación que se convertiría en S-PLUS y R. Muchas funciones comunes de R son genéricas de S3 que funcionan con un conjunto de métodos de clase. Por ejemplo, summary y head también llaman a UseMethod. Las funciones más básicas, como c, +, -, &lt; y otras también se comportan como funciones genéricas, aunque llaman a .primitive en lugar de UseMethod.\nEl sistema S3 permite que las funciones de R se comporten de diferentes maneras para diferentes clases. Puede usar S3 para formatear la salida de su tragamonedas. Primero, dé a su salida su propia clase. Luego escriba un método de impresión para esa clase. Para hacer esto de manera eficiente, necesitará saber un poco acerca de cómo UseMethod selecciona una función de método para usar.\n\n8.4.1 Selección de Método\nUseMethod utiliza un sistema muy simple para emparejar métodos con funciones.\nCada método S3 tiene un nombre de dos partes. La primera parte del nombre se referirá a la función con la que trabaja el método. La segunda parte se referirá a la clase. Estas dos partes estarán separadas por un punto. Entonces, por ejemplo, el método de print que funciona con funciones se llamará print.function. El método de summary que trabaja con matrices se llamará summary.matrix. Y así sucesivamente.\nCuando UseMethod necesita llamar a un método, busca una función de R con el nombre de estilo S3 correcto. La función no tiene que ser especial de ninguna manera; solo necesita tener el nombre correcto.\nPuede participar en este sistema escribiendo su propia función y dándole un nombre de estilo S3 válido. Por ejemplo, demos a a_play una clase propia. No importa cómo llames a la clase; R almacenará cualquier cadena de caracteres en el atributo de clase:\nclass(a_play) &lt;- \"tragamonedas\"\nAhora escribamos un método de impresión S3 para la clase +tragamonedas+. El método no necesita hacer nada especial, ni siquiera necesita imprimir a_play. Pero sí necesita llamarse print.tragamonedas; de lo contrario, UseMethod no lo encontrará. El método también debería tomar los mismos argumentos que print; de lo contrario, R dará un error cuando intente pasar los argumentos a print.tragamonedas:\nargs(print)\n## function (x, ...) \n## NULL\n\nprint.tragamonedas &lt;- function(x, ...) {\n  cat(\"Estoy usando el método print.tragamonedas\")\n}\n¿Funciona nuestro método? Sí, y no solo eso; R usa el método de impresión para mostrar el contenido de a_play. Este método no es muy útil, así que voy a eliminarlo. Tendrás la oportunidad de escribir uno mejor en un minuto:\nprint(a_play)\n## Estoy usando el método print.tragamonedas\n\na_play\n## Estoy usando el método print.tragamonedas\n\nrm(print.tragamonedas)\nAlgunos objetos de R tienen múltiples clases. Por ejemplo, la salida de Sys.time tiene dos clases. ¿Qué clase usará UseMethod para encontrar un método de impresión?\nahora &lt;- Sys.time()\nattributes(ahora)\n## $class\n## [1] \"POSIXct\" \"POSIXt\" \nUseMethod primero buscará un método que coincida con la primera clase listada en el vector de clase del objeto. Si UseMethod no puede encontrar uno, buscará el método que coincida con la segunda clase (y así sucesivamente si hay más clases en el vector de clase de un objeto).\nSi le das a print un objeto cuya clase o clases no tienen un método de impresión, UseMethod llamará a print.default, un método especial escrito para manejar casos generales.\nUsemos este sistema para escribir un mejor método de impresión para la salida de la máquina tragamonedas.\nEjercicio 11.2 (Hacer un Método de print) Escriba un nuevo método de print para la clase de tragamonedas. El método debería llamar a mostrat_tragamoneda para devolver una salida de máquina tragamonedas bien formateada.\n¿Qué nombre debe usar para este método?\nSolución. Es sorprendentemente fácil escribir un buen método print.tragamonedas porque ya hicimos todo el trabajo duro cuando escribimos mostrat_tragamoneda. Por ejemplo, el siguiente método funcionará. Solo asegúrese de que el método se llame print.tragamonedas para que UseMethod pueda encontrarlo, y asegúrese de que toma los mismos argumentos que print para que UseMethod pueda pasar esos argumentos a print.tragamonedas sin ningún problema:\nprint.tragamonedas &lt;- function(x, ...) {\n  mostrat_tragamoneda(x)\n}\nAhora R usará automáticamente mostrat_tragamoneda para mostrar objetos de clase +tragamonedas+ (y solo objetos de clase “tragamonedas”):\na_play\n## B 0 B\n## $0\nAsegurémonos de que cada salida de la máquina tragamonedas tenga la clase tragamonedas.\nEjercicio 11.3 (Añadir una Clase) Modifique la función play para que asigne tragamonedas al atributo class de su salida:\nplay &lt;- function() {\n  simbolos &lt;- get_simbolos()\n  structure(puntuacion(simbolos), simbolos = simbolos)\n}\nSolución. Puede establecer el atributo class de la salida al mismo tiempo que establece el atributo +simbolos+. Simplemente agregue class = \"tragamonedas\" a la llamada structure:\nplay &lt;- function() {\n  simbolos &lt;- get_simbolos()\n  structure(puntuacion(simbolos), simbolos = simbolos, class = \"tragamonedas\")\n}\nAhora cada uno de nuestras salidas de play tendrá la clase tragamonedas:\nclass(play())\n## \"tragamonedas\"\nComo resultado, R los mostrará en el formato de máquina tragamonedas correcto:\nplay()\n## BB BB BBB\n## $5\n\nplay()\n## BB 0 0\n## $0",
    "crumbs": [
      "Proyecto 3: Máquina Tragamonedas",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>S3</span>"
    ]
  },
  {
    "objectID": "s3.html#clases",
    "href": "s3.html#clases",
    "title": "8  S3",
    "section": "8.5 Clases",
    "text": "8.5 Clases\nPuede usar el sistema S3 para crear una nueva clase sólida de objetos en R. Luego, R tratará los objetos de su clase de manera consistente y sensata. Para hacer una clase:\n\nElija un nombre para su clase.\nAsigne a cada instancia de su clase un atributo +class+.\nEscriba métodos de clase para cualquier función genérica que pueda usar objetos de su clase.\n\nMuchos paquetes de R se basan en clases que se han creado de manera similar. Si bien este trabajo es simple, puede que no sea fácil. Por ejemplo, considere cuántos métodos existen para clases predefinidas.\nPuede llamar a methods en una clase con el argumento class, que toma una cadena de caracteres. methods devolverá todos los métodos escritos para la clase. Tenga en cuenta que methods no podrá mostrarle los métodos que vienen en un paquete R descargado:\nmethods(class = \"factor\")\n##  [1] [.factor             [[.factor           \n##  [3] [[&lt;-.factor          [&lt;-.factor          \n##  [5] all.equal.factor     as.character.factor \n##  [7] as.data.frame.factor as.Date.factor      \n##  [9] as.list.factor       as.logical.factor   \n## [11] as.POSIXlt.factor    as.vector.factor    \n## [13] droplevels.factor    format.factor       \n## [15] is.na&lt;-.factor       length&lt;-.factor     \n## [17] levels&lt;-.factor      Math.factor         \n## [19] Ops.factor           plot.factor*        \n## [21] print.factor         relevel.factor*     \n## [23] relist.factor*       rep.factor          \n## [25] summary.factor       Summary.factor      \n## [27] xtfrm.factor        \n## \n##    Nonvisible functions are asterisked\nEsta salida indica cuánto trabajo se requiere para crear una clase robusta y de buen comportamiento. Por lo general, necesitará escribir un método de class para cada operación básica de R.\nConsidere dos desafíos que enfrentará de inmediato. Primero, R descarta atributos (como class) cuando combina objetos en un vector:\nplay1 &lt;- play()\nplay1\n## B BBB BBB\n## $5\n\nplay2 &lt;- play()\nplay2\n## 0 B 0\n## $0\n\nc(play1, play2)\n## [1] 5 0\nAquí, R deja de usar print.tragamonedas para mostrar el vector porque el vector c(play1, play2) ya no tiene un atributo +class+ “tragamonedas”.\nA continuación, R eliminará los atributos de un objeto (como class) cuando subjunte el objeto:\nplay1[1]\n## [1] 5\nPuede evitar este comportamiento escribiendo un método c.tragamonedas y un método [.tragamonedas, pero luego se acumularán dificultades rápidamente. ¿Cómo combinaría los atributos de simbolos de múltiples jugadas en un vector de atributos de símbolos? ¿Cómo cambiarías print.tragamonedas para manejar vectores de salidas? Estos desafíos están abiertos para que los explores. Sin embargo, normalmente no tendrá que intentar este tipo de programación a gran escala como científico de datos.\nEn nuestro caso, es muy útil dejar que los objetos tragamonedas vuelvan a tener valores de premios únicos cuando combinamos grupos de ellos en un vector.",
    "crumbs": [
      "Proyecto 3: Máquina Tragamonedas",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>S3</span>"
    ]
  },
  {
    "objectID": "s3.html#s3-y-depuración",
    "href": "s3.html#s3-y-depuración",
    "title": "8  S3",
    "section": "8.6 S3 y Depuración",
    "text": "8.6 S3 y Depuración\nS3 puede ser molesto si está tratando de comprender las funciones de R. Es difícil saber qué hace una función si su cuerpo de código contiene una llamada a UseMethod. Ahora que sabe que UseMethod llama a un método específico de clase, puede buscar y examinar el método directamente. Será una función cuyo nombre siga la sintaxis &lt;function.class&gt;, o posiblemente &lt;function.default&gt;. También puede usar la función methods para ver qué métodos están asociados con una función o una clase.",
    "crumbs": [
      "Proyecto 3: Máquina Tragamonedas",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>S3</span>"
    ]
  },
  {
    "objectID": "s3.html#s4-y-r5",
    "href": "s3.html#s4-y-r5",
    "title": "8  S3",
    "section": "8.7 S4 y R5",
    "text": "8.7 S4 y R5\nR también contiene otros dos sistemas que crean un comportamiento específico de clase. Estos se conocen como S4 y R5 (o clases de referencia). Cada uno de estos sistemas es mucho más difícil de usar que S3 y quizás, como consecuencia, más raro. Sin embargo, ofrecen garantías que S3 no ofrece. Si desea obtener más información sobre estos sistemas, incluido cómo escribir y usar sus propias funciones genéricas, le recomiendo el libro Advanced R Programming de Hadley Wickham.",
    "crumbs": [
      "Proyecto 3: Máquina Tragamonedas",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>S3</span>"
    ]
  },
  {
    "objectID": "s3.html#resumen",
    "href": "s3.html#resumen",
    "title": "8  S3",
    "section": "8.8 Resumen",
    "text": "8.8 Resumen\nLos valores no son el único lugar para almacenar información en R, y las funciones no son la única forma de crear un comportamiento único. También puede hacer ambas cosas con el sistema S3 de R. El sistema S3 proporciona una forma sencilla de crear comportamientos específicos de objetos en R. En otras palabras, es la versión de programación orientada a objetos (OOP) de R. El sistema se implementa mediante funciones genéricas. Estas funciones examinan el atributo de clase de su entrada y llaman a un método específico de clase para generar salida. Muchos métodos de S3 buscarán y utilizarán información adicional que se almacena en los atributos de un objeto. Muchas funciones comunes de R son genéricas de S3.\nEl sistema S3 de R es más útil para las tareas de informática que para las tareas de ciencia de datos, pero comprender S3 puede ayudarlo a solucionar problemas en su trabajo en R como científico de datos\nAhora sabe bastante sobre cómo escribir código de R que realiza tareas personalizadas, pero ¿cómo podría repetir estas tareas? Como científico de datos, a menudo repetirá tareas, a veces miles o incluso millones de veces. ¿Por qué? Porque la repetición te permite simular resultados y estimar probabilidades. Bucles te mostrará cómo automatizar la repetición con las funciones for y while de R. Usará for para simular varios juegos de máquinas tragamonedas y para calcular la tasa de pago de su máquina tragamonedas.",
    "crumbs": [
      "Proyecto 3: Máquina Tragamonedas",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>S3</span>"
    ]
  },
  {
    "objectID": "loops.html",
    "href": "loops.html",
    "title": "9  Bucles",
    "section": "",
    "text": "9.1 Valores Esperados\nLos bucles son el método de R para repetir una tarea, lo que los convierte en una herramienta útil para programar simulaciones. Este capítulo le enseñará cómo usar las herramientas de bucle de R.\nUsemos la función puntuacion para resolver un problema del mundo real.\nSu máquina tragamonedas está modelada a partir de máquinas reales que fueron acusadas de fraude. Las máquinas parecían pagar 40 centavos por dólar, pero el fabricante afirmó que pagaban 92 centavos por dólar. Puede calcular la tasa de pago exacta de su máquina con el programa puntuacion. La tasa de pago será el valor esperado del premio de la máquina tragamonedas.\nEl valor esperado de un evento aleatorio es un tipo de promedio ponderado; es la suma de cada resultado posible del evento, ponderada por la probabilidad de que ocurra cada resultado:\n\\[\nE(x) = \\sum_{i = 1}^{n}\\left( x_{i} \\cdot P(x_{i}) \\right)\n\\]\nPuede pensar en el valor esperado como el premio promedio que observaría si jugara en la máquina tragamonedas una cantidad infinita de veces. Usemos la fórmula para calcular algunos valores esperados simples. Luego aplicaremos la fórmula a su máquina tragamonedas.\n¿Recuerdas el dado que creaste en Proyecto 1: Dados Ponderados?\nCada vez que lanzas el dado, devuelve un valor seleccionado al azar (de uno a seis). Puedes encontrar el valor esperado de tirar el dado con la fórmula:\n\\[\nE(\\text{dado}) = \\sum_{i = 1}^{n}\\left( \\text{dado}_{i} \\cdot P(\\text{dado}_{i}) \\right)\n\\]\nLos \\(\\text{dado}_{i}\\) son los posibles resultados de lanzar el dado: 1, 2, 3, 4, 5 y 6; y los \\(P(\\text{dado}_{i})\\) son las probabilidades asociadas con cada uno de los resultados. Si su dado es justo, cada resultado ocurrirá con la misma probabilidad: 1/6. Entonces nuestra ecuación se simplifica a:\n\\[\n\\begin{array}{rl}\nE(\\text{dado}) & = \\sum_{i = 1}^{n}\\left( \\text{dado}_{i} \\cdot P(\\text{dado}_{i}) \\right)\\\\\n& = 1 \\cdot \\frac{1}{6} +  2 \\cdot \\frac{1}{6} + 3 \\cdot \\frac{1}{6} + 4 \\cdot \\frac{1}{6} + 5 \\cdot \\frac{1}{6} + 6 \\cdot \\frac{1}{6}\\\\\n& = 3.5\\\\\n\\end{array}\n\\]\nPor lo tanto, el valor esperado de lanzar un dado justo es 3,5. Puede notar que este es también el valor promedio del dado. El valor esperado será igual al promedio si todos los resultados tienen la misma probabilidad de ocurrir.\nPero, ¿y si cada resultado tiene una probabilidad diferente de ocurrir? Por ejemplo, manipulamos nuestros dados en Paquetes y Páginas de Ayuda para que cada dado arrojara 1, 2, 3, 4 y 5 con una probabilidad de 1/8 y 6 con una probabilidad de 3/8. Puede usar la misma fórmula para calcular el valor esperado en estas condiciones:\n\\[\n\\begin{array}{rl}\n  E(dado) & = 1 \\cdot \\frac{1}{8} +  2 \\cdot \\frac{1}{8} + 3 \\cdot \\frac{1}{8} + 4 \\cdot \\frac{1}{8} + 5 \\cdot \\frac{1}{8} + 6 \\cdot \\frac{3}{8}\\\\\n  & = 4.125\\\\\n  \\end{array}\n\\]\nPor lo tanto, el valor esperado de un dado manipulado no es igual al valor promedio de un dado no manipulado. Si lanzaste un dado manipulado una cantidad infinita de veces, el resultado promedio sería 4.125, que es más alto de lo que esperarías de un dado justo.\nObserve que hicimos las mismas tres cosas para calcular estos dos valores esperados. Tenemos:\nEntonces, el valor esperado era solo la suma de los valores en el paso 2 multiplicada por las probabilidades en el paso 3.\nPuede utilizar estos pasos para calcular valores esperados más sofisticados. Por ejemplo, podría calcular el valor esperado de lanzar un par de dados ponderados. Hagamos esto paso a paso.\nPrimero, enumere todos los resultados posibles. Pueden aparecer un total de 36 resultados diferentes cuando lanzas dos dados. Por ejemplo, puede sacar (1, 1), que anota uno en el primer dado y uno en el segundo dado. O bien, puede tirar (1, 2), uno en el primer dado y dos en el segundo. Y así. Enumerar estas combinaciones puede ser tedioso, pero R tiene una función que puede ayudar.",
    "crumbs": [
      "Proyecto 3: Máquina Tragamonedas",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Bucles</span>"
    ]
  },
  {
    "objectID": "loops.html#valores-esperados",
    "href": "loops.html#valores-esperados",
    "title": "9  Bucles",
    "section": "",
    "text": "dado &lt;- c(1, 2, 3, 4, 5, 6)\n\n\n\n\n\n\n\n\n\n\nEnumeró todos los resultados posibles\nDeterminado el valor de cada resultado (aquí solo el valor del dado)\nCalculó la probabilidad de que ocurriera cada resultado",
    "crumbs": [
      "Proyecto 3: Máquina Tragamonedas",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Bucles</span>"
    ]
  },
  {
    "objectID": "loops.html#expand.grid",
    "href": "loops.html#expand.grid",
    "title": "9  Bucles",
    "section": "9.2 expand.grid",
    "text": "9.2 expand.grid\nLa función expand.grid en R proporciona una forma rápida de escribir cada combinación de los elementos en n vectores. Por ejemplo, puede hacer una lista de todas las combinaciones de dos dados. Para hacerlo, ejecuta expand.grid en dos copias de dado:\ntiradas &lt;- expand.grid(dado, dado)\nexpand.grid devolverá un data frame que contiene todas las formas de emparejar un elemento del primer vector dado con un elemento del segundo vector dado. Esto capturará las 36 posibles combinaciones de valores:\ntiradas\n##    Var1 Var2\n## 1     1    1\n## 2     2    1\n## 3     3    1\n## ...\n## 34    4    6\n## 35    5    6\n## 36    6    6\nPuede usar expand.grid con más de dos vectores si lo desea. Por ejemplo, podría enumerar cada combinación de tirar tres dados con expand.grid(dado, dado, dado) y cada combinación de tirar cuatro dados con expand.grid(dado, dado, dado, dado), y así en. expand.grid siempre devolverá un data frame que contiene cada combinación posible de n elementos de los n vectores. Cada combinación contendrá exactamente un elemento de cada vector.\nPuedes determinar el valor de cada tirada una vez que hayas hecho tu lista de resultados. Esta será la suma de los dos dados, que puedes calcular usando la ejecución por elementos de R:\ntiradas$valor &lt;- tiradas$Var1 + tiradas$Var2\nhead(tiradas, 3)\n## Var1 Var2 valor\n##    1    1     2\n##    2    1     3\n##    3    1     4\nR emparejará los elementos en cada vector antes de agregarlos. Como resultado, cada elemento de valor se referirá a los elementos de Var1 y Var2 que aparecen en la misma fila.\nA continuación, debes determinar la probabilidad de que aparezca cada combinación. Puedes calcular esto con una regla básica de probabilidad:\nLa probabilidad de que n eventos aleatorios independientes ocurran todos es igual al producto de las probabilidades de que ocurra cada evento aleatorio.\nO más sucintamente:\n\\[\nP(A \\& B \\& C \\& ...) = P(A) \\cdot P(B) \\cdot P(C) \\cdot ...\n\\]\nEntonces, la probabilidad de que saquemos (1, 1) será igual a la probabilidad de que saquemos un uno en el primer dado, 1/8, multiplicada por la probabilidad de que saquemos un uno en el segundo dado, 1/8:\n\\[\n\\begin{array}{rl}\nP(1 \\& 1) & = P(1) \\cdot P(1) \\\\\n& = \\frac{1}{8} \\cdot \\frac{1}{8}\\\\\n& = \\frac{1}{64}\n\\end{array}\n\\]\nY la probabilidad de que saquemos un (1, 2) será:\n\\[\n\\begin{array}{rl}\nP(1 \\& 2) & = P(1) \\cdot P(2) \\\\\n& = \\frac{1}{8} \\cdot \\frac{1}{8}\\\\\n& = \\frac{1}{64}\n\\end{array}\n\\]\nY así sucesivamente.\nPermítanme sugerir un proceso de tres pasos para calcular estas probabilidades en R. Primero, podemos buscar las probabilidades de rodar los valores en Var1. Haremos esto con la tabla de búsqueda que sigue:\nprob &lt;- c(\"1\" = 1/8, \"2\" = 1/8, \"3\" = 1/8, \"4\" = 1/8, \"5\" = 1/8, \"6\" = 3/8)\n\nprob\n##     1     2     3     4     5     6 \n## 0.125 0.125 0.125 0.125 0.125 0.375 \nSi crea un subconjunto de esta tabla con tiradas$Var1, obtendrá un vector de probabilidades perfectamente relacionado con los valores de Var1:\ntiradas$Var1\n## 1 2 3 4 5 6 1 2 3 4 5 6 1 2 3 4 5 6 1 2 3 4 5 6 1 2 3 4 5 6 1 2 3 4 5 6\n\nprob[tiradas$Var1]\n##     1     2     3     4     5     6     1     2     3     4     5     6 \n## 0.125 0.125 0.125 0.125 0.125 0.375 0.125 0.125 0.125 0.125 0.125 0.375 \n##     1     2     3     4     5     6     1     2     3     4     5     6 \n## 0.125 0.125 0.125 0.125 0.125 0.375 0.125 0.125 0.125 0.125 0.125 0.375 \n##     1     2     3     4     5     6     1     2     3     4     5     6 \n## 0.125 0.125 0.125 0.125 0.125 0.375 0.125 0.125 0.125 0.125 0.125 0.375 \n\ntiradas$prob1 &lt;- prob[tiradas$Var1]\nhead(tiradas, 3)\n## Var1 Var2 valor prob1\n##    1    1     2 0.125\n##    2    1     3 0.125\n##    3    1     4 0.125\nSecond, we can look up the probabilities of rolling the values in Var2:\ntiradas$prob2 &lt;- prob[tiradas$Var2]\n\nhead(tiradas, 3)\n## Var1 Var2 valor prob1 prob2\n##    1    1     2 0.125 0.125\n##    2    1     3 0.125 0.125\n##    3    1     4 0.125 0.125\nTercero, podemos calcular la probabilidad de obtener cada combinación multiplicando prob1 por prob2:\ntiradas$prob &lt;- tiradas$prob1 * tiradas$prob2\n\nhead(tiradas, 3)\n## Var1 Var2 valor prob1 prob2     prob\n##    1    1     2 0.125 0.125 0.015625\n##    2    1     3 0.125 0.125 0.015625\n##    3    1     4 0.125 0.125 0.015625\nEs fácil calcular el valor esperado ahora que tenemos cada resultado, el valor de cada resultado y la probabilidad de cada resultado. El valor esperado será la suma de los valores de los dados multiplicada por las probabilidades de los dados:\nsum(tiradas$valor * tiradas$prob)\n## 8.25\nEntonces, el valor esperado de lanzar dos dados cargados es 8.25. Si lanzaste un par de dados cargados un número infinito de veces, la suma promedio sería 8.25. (Si tiene curiosidad, el valor esperado de lanzar un par de dados justos es 7, lo que explica por qué 7 juega un papel tan importante en juegos de dados como los dados).\nAhora que se ha calentado, usemos nuestro método para calcular el valor esperado del premio de la máquina tragamonedas. Seguiremos los mismos pasos que acabamos de hacer:\n\nEnumeraremos todos los resultados posibles de jugar en la máquina. Esta será una lista de cada combinación de tres símbolos de tragamonedas.\nCalcularemos la probabilidad de obtener cada combinación cuando juegues en la máquina.\nDeterminaremos el premio que ganaríamos por cada combinación.\n\nCuando hayamos terminado, tendremos un conjunto de datos que se verá así:\n## Var1 Var2 Var3 prob1 prob2 prob3     prob premio\n##   DD   DD   DD  0.03  0.03  0.03 0.000027    800\n##    7   DD   DD  0.03  0.03  0.03 0.000027      0\n##  BBB   DD   DD  0.06  0.03  0.03 0.000054      0\n## ... y así sucesivamente.\nEl valor esperado será entonces la suma de los premios multiplicada por su probabilidad de ocurrencia:\n\\[\nE(\\text{premio}) = \\sum_{i = 1}^{n}\\left( \\text{premio}_{i} \\cdot P(\\text{premio}_{i}) \\right)\n\\]\n¿Listo para comenzar?\nEjercicio 12.1 (Liste las Combinaciones) Usa expand.grid para crear un data frame que contenga todas las combinaciones posibles de tres símbolos del vector rueda:\nrueda &lt;- c(\"DD\", \"7\", \"BBB\", \"BB\", \"B\", \"C\", \"0\")\nAsegúrese de agregar el argumento stringsAsFactors = FALSE a su llamada expand.grid; de lo contrario, expand.grid guardará las combinaciones como factores, una elección desafortunada que interrumpirá la función puntuacion\nSolución. Para crear un data frame de cada combinación de tres símbolos, debe ejecutar expand.grid y darle tres copias de wheel. El resultado será un data frame con 343 filas, una para cada combinación única de tres símbolos de ranura:\ncombos &lt;- expand.grid(rueda, rueda, rueda, stringsAsFactors = FALSE)\n\ncombos\n##   Var1 Var2 Var3\n## 1   DD   DD   DD\n## 2    7   DD   DD\n## 3  BBB   DD   DD\n## 4   BB   DD   DD\n## 5    B   DD   DD\n## 6    C   DD   DD\n## ...\n## 341    B    0    0\n## 342    C    0    0\n## 343    0    0    0\nAhora, calculemos la probabilidad de obtener cada combinación. Puedes usar las probabilidades contenidas en el argumento prob de obt_simbolos para hacer esto. Estas probabilidades determinan la frecuencia con la que se elige cada símbolo cuando su máquina tragamonedas genera símbolos. Se calcularon después de observar 345 jugadas de las terminales de video lotería de Manitoba. Los ceros tienen la mayor probabilidad de ser seleccionados (0,52) y las cerezas la menor (0,01):\nobt_simbolos() &lt;- function() {\n  rueda &lt;- c(\"DD\", \"7\", \"BBB\", \"BB\", \"B\", \"C\", \"0\")\n  sample(rueda, size = 3, replace = TRUE, \n    prob = c(0.03, 0.03, 0.06, 0.1, 0.25, 0.01, 0.52))\n}\nEjercicio 12.2 (Haz una Tabla de Búsqueda) Aísle las probabilidades anteriores en una tabla de búsqueda. ¿Qué nombres usarás en tu tabla?\nSolución. Sus nombres deben coincidir con la entrada que desea buscar. En este caso, la entrada serán las cadenas de caracteres que aparecen en Var1, Var2 y Var3. Entonces su tabla de búsqueda debería verse así:\nprob &lt;- c(\"DD\" = 0.03, \"7\" = 0.03, \"BBB\" = 0.06, \n  \"BB\" = 0.1, \"B\" = 0.25, \"C\" = 0.01, \"0\" = 0.52)\nAhora busquemos nuestras probabilidades.\nEjercicio 12.3 (Buscar las Probabilidades) Busque las probabilidades de obtener los valores en Var1. Luego agréguelos a combos como una columna llamada prob1. Luego haga lo mismo para Var2 (prob2) y Var3 (prob3).\nSolución. Recuerde que usa la notación de selección de R para buscar valores en una tabla de búsqueda. Los valores que resulten estarán relacionados con el índice que utilice:\ncombos$prob1 &lt;- prob[combos$Var1]\ncombos$prob2 &lt;- prob[combos$Var2]\ncombos$prob3 &lt;- prob[combos$Var3]\n\nhead(combos, 3)\n## Var1 Var2 Var3 prob1 prob2 prob3\n##   DD   DD   DD  0.03  0.03  0.03\n##    7   DD   DD  0.03  0.03  0.03\n##  BBB   DD   DD  0.06  0.03  0.03\nAhora, ¿cómo debemos calcular la probabilidad total de cada combinación? Nuestros tres símbolos de tragamonedas se eligen de forma independiente, lo que significa que la misma regla que gobernó nuestras probabilidades de dados gobierna nuestras probabilidades de símbolos:\n\\[\nP(A \\& B \\& C \\& ...) = P(A) \\cdot P(B) \\cdot P(C) \\cdot ...\n\\]\nEjercicio 12.4 (Calcular las Probabilidades de Cada Combinación) Calcule las probabilidades generales para cada combinación. Guárdelos como una columna llamada prob en combos, luego verifique su trabajo.\nPuedes comprobar que las matemáticas funcionaron sumando las probabilidades. Las probabilidades deben sumar uno, porque una de las combinaciones debe aparecer cuando juegas en la máquina tragamonedas. En otras palabras, aparecerá una combinación, con probabilidad de uno.\nPuede calcular las probabilidades de cada combinación posible de una sola vez con alguna ejecución de elementos:\ncombos$prob &lt;- combos$prob1 * combos$prob2 * combos$prob3\n\nhead(combos, 3)\n## Var1 Var2 Var3 prob1 prob2 prob3     prob\n##   DD   DD   DD  0.03  0.03  0.03 0.000027\n##    7   DD   DD  0.03  0.03  0.03 0.000027\n##  BBB   DD   DD  0.06  0.03  0.03 0.000054\nLa suma de las probabilidades es uno, lo que sugiere que nuestra matemática es correcta:\nsum(combos$prob)\n## 1\nSolo necesita hacer una cosa más antes de poder calcular el valor esperado: debe determinar el premio para cada combinación en combos. Puedes calcular el premio con puntuacion. Por ejemplo, podemos calcular el premio de la primera fila de combos así:\nsimbolos &lt;- c(combos[1, 1], combos[1, 2], combos[1, 3])\n## \"DD\" \"DD\" \"DD\"\n\npuntuacion(simbolos)\n## 800\nSin embargo, hay 343 filas, lo que hace que el trabajo sea tedioso si planea calcular las puntuaciones manualmente. Será más rápido automatizar esta tarea y hacer que R lo haga por usted, lo que puede hacer con un bucle for.",
    "crumbs": [
      "Proyecto 3: Máquina Tragamonedas",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Bucles</span>"
    ]
  },
  {
    "objectID": "loops.html#bucles-for",
    "href": "loops.html#bucles-for",
    "title": "9  Bucles",
    "section": "9.3 Bucles for",
    "text": "9.3 Bucles for\nUn bucle for repite un trozo de código muchas veces, una vez para cada elemento en un conjunto de entrada. Los bucles for proporcionan una manera de decirle a R: “Haz esto para cada valor de aquello”. En sintaxis R, esto se ve así:\nfor (valor in aquello) {\n  esto\n}\nEl objeto aquello debe ser un conjunto de objetos (a menudo un vector de números o cadenas de caracteres). El bucle for ejecutará el código que aparece entre llaves una vez para cada miembro de aquello. Por ejemplo, el bucle for siguiente ejecuta print(\"una ejecución\") una vez para cada elemento en un vector de cadenas de caracteres:\nfor (valor in c(\"Mi\", \"primer\", \"bucle\", \"foe\")) {\n  print(\"una ejecución\")\n}\n## \"una ejecución\"\n## \"una ejecución\"\n## \"una ejecución\"\n## \"una ejecución\"\nEl símbolo valor en un bucle for actúa como un argumento en una función. El bucle for creará un objeto llamado valor y le asignará un nuevo valor en cada ejecución del bucle. El código en su bucle puede acceder a este valor llamando al objeto valor.\n¿Qué valores asignará el bucle for a valor? Utilizará los elementos del conjunto en el que ejecuta el ciclo. for comienza con el primer elemento y luego asigna un elemento diferente a valor en cada ejecución del ciclo for, hasta que todos los elementos han sido asignados a valor. Por ejemplo, el bucle for de abajo ejecutará print(valor) cuatro veces e imprimirá un elemento de c(\"Mi\", \"segundo\", \"bucle\", \"for\") cada vez:\nfor (valor in c(\"Mi\", \"segundo\", \"bucle\", \"for\")) {\n  print(valor)\n}\n## \"Mi\"\n## \"segundo\"\n## \"bucle\"\n## \"for\"\nEn la primera ejecución, el ciclo for sustituyó \"My\" por valor en print(valor). En la segunda ejecución, sustituyó \"segundo\", y así sucesivamente hasta que for ejecutó print(valor) una vez con cada elemento del conjunto:\nSi mira valor después de que se ejecuta el bucle, verá que todavía contiene el valor del último elemento del conjunto:\nvalor\n## \"for\"\nHe estado usando el símbolo valor en mis bucles for, pero no tiene nada de especial. Puede usar cualquier símbolo que desee en su bucle para hacer lo mismo siempre que el símbolo aparezca antes de in en los paréntesis que siguen a for. Por ejemplo, podría reescribir el bucle anterior con cualquiera de los siguientes:\nfor (palabra in c(\"Mi\", \"segundo\", \"bucle\", \"for\")) {\n  print(palabra)\n}\nfor (texto in c(\"Mi\", \"segundo\", \"bucle\", \"for\")) {\n  print(texto)\n}\nfor (i in c(\"Mi\", \"segundo\", \"bucle\", \"for\")) {\n  print(i)\n}\n\n\n\n\n\n\nElige tus símbolos con cuidado\nR ejecutará su ciclo en cualquier entorno desde el que lo llame. Estas son malas noticias si su bucle usa nombres de objetos que ya existen en el entorno. Su bucle sobrescribirá los objetos existentes con los objetos que crea. Esto también se aplica al símbolo de valor.\n\n\n\n\n\n\n\n\n\nLos bucles for se ejecutan en conjuntos\nEn muchos lenguajes de programación, los bucles for están diseñados para funcionar con números enteros, no con conjuntos. Le da al bucle un valor inicial y un valor final, así como un incremento para avanzar el valor entre bucles. El bucle for se ejecuta hasta que el valor del bucle supera el valor final.\nPuede recrear este efecto en R haciendo que un bucle for se ejecute en un conjunto de enteros, pero no pierda de vista el hecho de que los bucles for de R se ejecutan en miembros de un conjunto, no en secuencias de enteros.\n\n\n\nLos bucles for son muy útiles en la programación porque te ayudan a conectar un fragmento de código con cada elemento de un conjunto. Por ejemplo, podríamos usar un ciclo for para ejecutar puntuacion una vez por cada fila en combos. Sin embargo, los bucles for de R tienen un defecto que querrá conocer antes de empezar a usarlos: los bucles for no devuelven salida.\nLos bucles for son como Las Vegas: lo que sucede en un bucle for permanece en un bucle for. Si desea utilizar los productos de un bucle for, debe escribir el bucle for para que guarde su propia salida a medida que avanza.\nNuestros ejemplos anteriores parecían devolver la salida, pero esto era engañoso. Los ejemplos funcionaron porque llamamos print, que siempre imprime sus argumentos en la consola (incluso si se llama desde una función, un bucle for o cualquier otra cosa). Nuestros bucles for no devolverán nada si eliminas la llamada print:\nfor (valor in c(\"Mi\", \"tercer\", \"bucle\", \"for\")) {\n  valor\n}\n##\nPara guardar la salida de un bucle for, debe escribir el bucle para que guarde su propia salida mientras se ejecuta. Puede hacer esto creando un vector vacío o una lista antes de ejecutar el bucle for. Luego use el bucle for para llenar el vector o la lista. Cuando finalice el bucle for, podrá acceder al vector o lista, que ahora tendrá todos sus resultados.\nVeamos esto en acción. El siguiente código crea un vector vacío de longitud 4:\ncaracteres &lt;- vector(length = 4)\nEl siguiente ciclo lo llenará con cadenas de texto:\npalabras &lt;- c(\"Mi\", \"cuarto\", \"bucle\", \"for\")\n\nfor (i in 1:4) {\n  caracteres[i] &lt;- palabras[i]\n}\n\ncaracteres\n## \"Mi\"    \"cuarto\" \"bucle\"   \"for\"\nEste enfoque generalmente requerirá que cambie los conjuntos en los que ejecuta su bucle for. En lugar de ejecutar en un conjunto de objetos, ejecute en un conjunto de enteros que puede usar para indexar tanto su objeto como su vector de almacenamiento. Este enfoque es muy común en R. Encontrará en la práctica que usa bucles for no tanto para ejecutar código, sino para llenar vectores y listas con los resultados del código.\nUsemos un bucle for para calcular el premio de cada fila en combos. Para comenzar, cree una nueva columna en combos para almacenar los resultados del bucle for:\ncombos$premio &lt;- NA\n\nhead(combos, 3)\n##  Var1 Var2 Var3 prob1 prob2 prob3     prob premio\n##    DD   DD   DD  0.03  0.03  0.03 0.000027     NA\n##     7   DD   DD  0.03  0.03  0.03 0.000027     NA\n##   BBB   DD   DD  0.06  0.03  0.03 0.000054     NA\nEl código crea una nueva columna llamada premio y la llena con NA. R usa sus reglas de reciclaje para completar cada valor de la columna con NA.\nEjercicio 12.5 (Construye un Bucle) Construya un bucle for que ejecutará puntuacion en las 343 filas de combos. El ciclo debe ejecutar puntuacion en las primeras tres entradas de la _i_ésima fila de combos y debe almacenar los resultados en la _i_ésima entrada de combos$premio.\nSolución. Puedes puntuar las filas en combos con:\nfor (i in 1:nrow(combos)) {\n  simbolos &lt;- c(combos[i, 1], combos[i, 2], combos[i, 3])\n  combos$premio[i] &lt;- puntuacion(simbolos)\n}\nDespués de ejecutar el ciclo for, combos$premio contendrá el premio correcto para cada fila. Este ejercicio también prueba la función puntuacion; puntuacion parece funcionar correctamente para todas las combinaciones posibles de tragamonedas:\nhead(combos, 3)\n## Var1 Var2 Var3 prob1 prob2 prob3     prob premio\n##   DD   DD   DD  0.03  0.03  0.03 0.000027    800\n##    7   DD   DD  0.03  0.03  0.03 0.000027      0\n##  BBB   DD   DD  0.06  0.03  0.03 0.000054      0\nAhora estamos listos para calcular el valor esperado del premio. El valor esperado es la suma de combos$premio ponderada por combos$prob. Esta es también la tasa de pago de la máquina tragamonedas:\nsum(combos$premio * combos$prob)\n## 0.538014\nOh oh. El premio esperado es de aproximadamente 0,54, lo que significa que nuestra máquina tragamonedas solo paga 54 centavos por dólar a largo plazo. ¿Significa esto que el fabricante de las máquinas tragamonedas de Manitoba estaba mintiendo?\nNo, porque ignoramos una característica importante de la máquina tragamonedas cuando escribimos puntuacion: un diamante es un comodín. Puede tratar un DD como cualquier otro símbolo si aumenta su premio, con una excepción. No puede convertir un DD en una C a menos que ya tenga otra C en sus símbolos (sería demasiado fácil si cada DD le otorgara automáticamente $2).\nLo mejor de los DDs es que sus efectos son acumulativos. Por ejemplo, considere la combinación B, DD, B. El DD no solo cuenta como B, que ganaría un premio de $10; el DD también duplica el premio a $20.\nAgregar este comportamiento a nuestro código es un poco más difícil que lo que hemos hecho hasta ahora, pero involucra todos los mismos principios. Puede decidir que su máquina tragamonedas no use comodines y conservar el código que tenemos. En ese caso, su máquina tragamonedas tendrá una tasa de pago de alrededor del 54 por ciento. O bien, podría reescribir su código para usar comodines. Si lo hace, encontrará que su máquina tragamonedas tiene una tasa de pago del 93 por ciento, un uno por ciento más alta que la afirmación del fabricante. Puedes calcular esta tasa con el mismo método que usamos en esta sección.\nEjercicio 12.6 (Desafío) Hay muchas formas de modificar puntuacion que contarían DD como comodines. Si desea probar su habilidad como programador de R, intente escribir su propia versión de puntuacion que maneje correctamente los diamantes.\nSi desea un desafío más modesto, estudie el siguiente código de puntuacion. Da cuenta de los diamantes salvajes de una manera que me parece elegante y sucinta. Vea si puede entender cada paso en el código y cómo logra su resultado.\nSolución. Aquí hay una versión de puntuacion que maneja diamantes salvajes:\npuntuacion &lt;- function(simbolos) {\n  \n  diamantez &lt;- sum(simbolos == \"DD\")\n  cerezas &lt;- sum(simbolos == \"C\")\n  \n  # identificar caso\n  # dado que los diamante son salvajes, solo\n  # importan los no diamantes para tres de un \n  # tipo y para todos barras\n  tragamonedas &lt;- simbolos[simbolos != \"DD\"]\n  iguales &lt;- length(unique(tragamonedas)) == 1\n  barras &lt;- tragamonedas %in% c(\"B\", \"BB\", \"BBB\")\n\n  # asignar premio\n  if (diamantes == 3) {\n    premio &lt;- 100\n  } else if (iguales) {\n    pagos &lt;- c(\"7\" = 80, \"BBB\" = 40, \"BB\" = 25,\n      \"B\" = 10, \"C\" = 10, \"0\" = 0)\n    premio &lt;- unname(pagos[tragamonedas[1]])\n  } else if (all(barras)) {\n    premio &lt;- 5\n  } else if (cerezas &gt; 0) {\n    # diamantes cuentan como cerezas\n    # siempre y cuando haya una cereza real\n    premio &lt;- c(0, 2, 5)[cerezas + diamantes + 1]\n  } else {\n    premio &lt;- 0\n  }\n  \n  # duplicar por cada diamante\n  premio * 2^diamantes\n}\nEjercicio 12.7 (Calcular el Valor Esperado) Calcule el valor esperado de la máquina tragamonedas cuando usa la nueva función puntuacion. Puede usar el data frame combos existente, pero necesitará crear un bucle for para recalcular combos$premio.\nPara actualizar el valor esperado, simplemente actualice combos$premio:\nfor (i in 1:nrow(combos)) {\n  simbolos &lt;- c(combos[i, 1], combos[i, 2], combos[i, 3])\n  combos$premio[i] &lt;- puntuacion(simbolos)\n}\nLuego vuelva a calcular el valor esperado:\nsum(combos$premio * combos$prob)\n## 0.934356\nEste resultado justifica la afirmación del fabricante. En todo caso, las máquinas tragamonedas parecen más generosas de lo que dijo el fabricante.",
    "crumbs": [
      "Proyecto 3: Máquina Tragamonedas",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Bucles</span>"
    ]
  },
  {
    "objectID": "loops.html#bucles-while",
    "href": "loops.html#bucles-while",
    "title": "9  Bucles",
    "section": "9.4 Bucles while",
    "text": "9.4 Bucles while\nR tiene dos compañeros del bucle for: el bucle while y el bucle repeat. Un bucle while vuelve a ejecutar un fragmento mientras una determinada condición permanece TRUE. Para crear un bucle while, siga while por una condición y un fragmento de código, como este:\nwhile (condición) {\n  código\n}\nwhile volverá a ejecutar condición, que debería ser una prueba lógica, al comienzo de cada ciclo. Si condición se evalúa como TRUE, while ejecutará el código entre sus llaves. Si condición se evalúa como FALSE, while finalizará el ciclo.\n¿Por qué la condición podría cambiar de TRUE a FALSE? Presumiblemente porque el código dentro de su ciclo ha cambiado si la condición sigue siendo TRUE. Si el código no tiene relación con la condición, se ejecutará un ciclo while hasta que lo detenga. Así que ten cuidado. Puede detener un bucle while pulsando Escape o haciendo clic en el icono de señal de alto en la parte superior del panel de la consola de RStudio. El icono aparecerá una vez que el ciclo comience a ejecutarse.\nAl igual que los bucles for, los bucles while no devuelven un resultado, por lo que debe pensar en lo que quiere que devuelva el bucle y guardarlo en un objeto durante el bucle.\nPuede usar bucles while para hacer cosas que requieran un número variable de iteraciones, como calcular cuánto tiempo se tarda en ir a la quiebra jugando tragamonedas (como se indica a continuación). Sin embargo, en la práctica, los bucles while son mucho menos comunes que los bucles for en R:\njugadas_hasta_quiebra &lt;- function(empezar_con) {\n  efectivo &lt;- empezar_con\n  n &lt;- 0\n  while (efectivo &gt; 0) {\n    efectivo &lt;- efectivo - 1 + play()\n    n &lt;- n + 1\n  }\n  n\n}\n\njugadas_hasta_quiebra(100)\n## 260",
    "crumbs": [
      "Proyecto 3: Máquina Tragamonedas",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Bucles</span>"
    ]
  },
  {
    "objectID": "loops.html#bucles-repeat",
    "href": "loops.html#bucles-repeat",
    "title": "9  Bucles",
    "section": "9.5 Bucles repeat",
    "text": "9.5 Bucles repeat\nLos bucles repeat son incluso más básicos que los bucles while. Repetirán un fragmento de código hasta que les digas que se detengan (pulsando Escape) o hasta que encuentren el comando break, que detendrá el ciclo.\nPuedes usar un bucle repeat para recrear jugadas_hasta_quiebra, mi función que simula cuánto tiempo lleva perder dinero mientras juegas tragamonedas:\njugadas_hasta_quiebra &lt;- function(empezar_con) {\n  efectivo &lt;- empezar_con\n  n &lt;- 0\n  repeat {\n    efectivo &lt;- efectivo - 1 + play()\n    n &lt;- n + 1\n    if (efectivo &lt;= 0) {\n      break\n    }\n  }\n  n\n}\n\njugadas_hasta_quiebra(100)\n## 237",
    "crumbs": [
      "Proyecto 3: Máquina Tragamonedas",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Bucles</span>"
    ]
  },
  {
    "objectID": "loops.html#resumen",
    "href": "loops.html#resumen",
    "title": "9  Bucles",
    "section": "9.6 Resumen",
    "text": "9.6 Resumen\nPuede repetir tareas en R con bucles for, while y repeat. Para usar for, dale un fragmento de código para ejecutar y un conjunto de objetos para recorrer. for ejecutará el fragmento de código una vez para cada objeto. Si desea guardar la salida de su bucle, puede asignarlo a un objeto que existe fuera del bucle.\nLa repetición juega un papel importante en la ciencia de datos. Es la base para la simulación, así como para las estimaciones de varianza y probabilidad. Los bucles no son la única forma de crear repeticiones en R (considere replicate por ejemplo), pero son una de las formas más populares.\nDesafortunadamente, los bucles en R a veces pueden ser más lentos que los bucles en otros idiomas. Como resultado, los bucles de R tienen mala reputación. Esta reputación no es del todo merecida, pero resalta un tema importante. La velocidad es esencial para el análisis de datos. Cuando su código se ejecuta rápido, puede trabajar con datos más grandes y hacer más antes de que se le acabe el tiempo o la potencia computacional. Velocidad te enseñará cómo escribir bucles for rápidos y código rápido en general con R. Allí, aprenderás a escribir código vectorizado, un estilo de código ultrarrápido que aprovecha todas las fortalezas de R.",
    "crumbs": [
      "Proyecto 3: Máquina Tragamonedas",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Bucles</span>"
    ]
  },
  {
    "objectID": "speed.html",
    "href": "speed.html",
    "title": "10  Velocidad",
    "section": "",
    "text": "10.1 Código Vectorizado\nComo científico de datos, necesita velocidad. Puede trabajar con datos más grandes y realizar tareas más ambiciosas cuando su código se ejecuta rápidamente. Este capítulo le mostrará una forma específica de escribir código rápido en R. Luego usará el método para simular 10 millones de juegos de su máquina tragamonedas.\nPuede escribir una pieza de código de muchas maneras diferentes, pero el código R más rápido generalmente aprovechará tres cosas: pruebas lógicas, creación de subconjuntos y ejecución de elementos. Estas son las cosas que R hace mejor. El código que usa estas cosas suele tener una cierta cualidad: está vectorizado; el código puede tomar un vector de valores como entrada y manipular cada valor en el vector al mismo tiempo.\nPara ver cómo se ve el código vectorizado, compare estos dos ejemplos de una función de valor absoluto. Cada uno toma un vector de números y lo transforma en un vector de valores absolutos (por ejemplo, números positivos). El primer ejemplo no está vectorizado; abs_bucle usa un bucle for para manipular cada elemento del vector uno a la vez:\nEl segundo ejemplo, abs_set, es una versión vectorizada de abs_bucle. Utiliza subconjuntos lógicos para manipular todos los números negativos en el vector al mismo tiempo:\nabs_set es mucho más rápido que abs_bucle porque se basa en operaciones que R realiza rápidamente: pruebas lógicas, creación de subconjuntos y ejecución de elementos.\nPuedes usar la función system.time para ver qué tan rápido es abs_set. system.time toma una expresión R, la ejecuta y luego muestra cuánto tiempo transcurrió mientras se ejecutaba la expresión.\nPara comparar abs_bucle y abs_set, primero haga un vector largo de números positivos y negativos. largo contendrá 10 millones de valores:\nLuego puede usar system.time para medir cuánto tiempo le toma a cada función evaluar largo:\nLas primeras dos columnas de la salida de system.time informan cuántos segundos pasó su computadora ejecutando la llamada en el lado del usuario y en el lado del sistema de su proceso, una dicotomía que variará de un sistema operativo a otro.\nLa última columna muestra cuántos segundos transcurrieron mientras R ejecutaba la expresión. Los resultados muestran que abs_set calculó el valor absoluto 30 veces más rápido que abs_bucle cuando se aplicó a un vector de 10 millones de números. Puede esperar aceleraciones similares siempre que escriba código vectorizado.\nEjercicio 13.1 (¿Qué tan rápido es abs?) Muchas funciones de R preexistentes ya están vectorizadas y se han optimizado para funcionar rápidamente. Puede hacer que su código sea más rápido confiando en estas funciones siempre que sea posible. Por ejemplo, R viene con una función de valor absoluto incorporada, abs.\nComprueba cuánto más rápido abs calcula el valor absoluto de long que abs_bucle y abs_set.\nSolución. Puedes medir la velocidad de abs con system.time. A abs le toma 0,05 segundos, a la velocidad del rayo, calcular el valor absoluto de 10 millones de números. Esto es 0,592 / 0,054 = 10,96 veces más rápido que abs_set y casi 300 veces más rápido que abs_bucle:",
    "crumbs": [
      "Proyecto 3: Máquina Tragamonedas",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Velocidad</span>"
    ]
  },
  {
    "objectID": "speed.html#código-vectorizado",
    "href": "speed.html#código-vectorizado",
    "title": "10  Velocidad",
    "section": "",
    "text": "abs_bucle &lt;- function(vec){\n  for (i in 1:length(vec)) {\n    if (vec[i] &lt; 0) {\n      vec[i] &lt;- -vec[i]\n    }\n  }\n  vec\n}\n\nabs_sets &lt;- function(vec){\n  negs &lt;- vec &lt; 0\n  vec[negs] &lt;- vec[negs] * -1\n  vec\n}\n\n\n\nlargo &lt;- rep(c(-1, 1), 5000000)\n\n\n\n\n\n\nrep repite un valor, o vector de valores, muchas veces. Para usar rep, dale un vector de valores y luego el número de veces para repetir el vector. R devolverá los resultados como un nuevo vector más largo.\n\n\n\n\nsystem.time(abs_bucle(largo))\n##    user  system elapsed \n##  15.982   0.032  16.018\n\nsystem.time(abs_sets(largo))\n##    user  system elapsed \n##   0.529   0.063   0.592\n\n\n\n\n\n\nNo confunda system.time con Sys.time, que devuelve la hora actual.\n\n\n\n\n\n\n\n\nsystem.time(abs(largo))\n##   user  system elapsed \n##  0.037   0.018   0.054",
    "crumbs": [
      "Proyecto 3: Máquina Tragamonedas",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Velocidad</span>"
    ]
  },
  {
    "objectID": "speed.html#cómo-escribir-código-vectorizado",
    "href": "speed.html#cómo-escribir-código-vectorizado",
    "title": "10  Velocidad",
    "section": "\n10.2 Cómo Escribir Código Vectorizado",
    "text": "10.2 Cómo Escribir Código Vectorizado\nEl código vectorizado es fácil de escribir en R porque la mayoría de las funciones de R ya están vectorizadas. El código basado en estas funciones se puede vectorizar fácilmente y, por lo tanto, es rápido. Para crear código vectorizado:\n\nUse funciones vectorizadas para completar los pasos secuenciales en su programa.\nUse subconjuntos lógicos para manejar casos paralelos. Trate de manipular todos los elementos en un caso a la vez.\n\nabs_bucle y abs_set ilustran estas reglas. Las funciones manejan dos casos y realizan un paso secuencial, Figure Figura 10.1. Si un número es positivo, las funciones lo dejan solo. Si un número es negativo, las funciones lo multiplican por uno negativo.\n\n\n\n\n\n\n\nFigura 10.1: abs_loop usa un bucle for para clasificar los datos en uno de dos casos: números negativos y números no negativos.\n\n\n\n\nPuede identificar todos los elementos de un vector que caen en un caso con una prueba lógica. R ejecutará la prueba en forma de elementos y devolverá un TRUE para cada elemento que pertenezca al caso. Por ejemplo, vec &lt; 0 identifica cada valor de vec que pertenece al caso negativo. Puede usar la misma prueba lógica para extraer el conjunto de valores negativos con subconjunto lógico:\nvec &lt;- c(1, -2, 3, -4, 5, -6, 7, -8, 9, -10)\nvec &lt; 0\n## FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE\n\nvec[vec &lt; 0]\n## -2  -4  -6  -8 -10\nEl plan de la Figura Figura 10.1 ahora requiere un paso secuencial: debe multiplicar cada uno de los valores negativos por uno negativo. Todos los operadores aritméticos de R están vectorizados, por lo que puede usar * para completar este paso de forma vectorizada. * multiplicará cada número en vec[vec &lt; 0] por uno negativo al mismo tiempo:\nvec[vec &lt; 0] * -1\n## 2  4  6  8 10\nFinalmente, puede usar el operador de asignación de R, que también está vectorizado, para guardar el nuevo conjunto sobre el antiguo en el objeto vec original. Dado que &lt;- está vectorizado, los elementos del nuevo conjunto se emparejarán con los elementos del antiguo conjunto, en orden, y luego se realizará la asignación por elementos. Como resultado, cada valor negativo será reemplazado por su pareja positiva, como en la figura Figura 10.2.\n\n\n\n\n\n\n\nFigura 10.2: Use subconjuntos lógicos para modificar grupos de valores en su lugar. Los operadores aritméticos y de asignación de R están vectorizados, lo que le permite manipular y actualizar varios valores a la vez.\n\n\n\n\nEjercicio 13.2 (Vectorizar una función) La siguiente función convierte un vector de símbolos de tragamonedas en un vector de nuevos símbolos de tragamonedas. ¿Puedes vectorizarlo? ¿Cuánto más rápido funciona la versión vectorizada?\ncambiar_simbolos &lt;- function(vec){\n  for (i in 1:length(vec)){\n    if (vec[i] == \"DD\") {\n      vec[i] &lt;- \"comodín\"\n    } else if (vec[i] == \"C\") {\n      vec[i] &lt;- \"as\"\n    } else if (vec[i] == \"7\") {\n      vec[i] &lt;- \"rey\"\n    }else if (vec[i] == \"B\") {\n      vec[i] &lt;- \"reina\"\n    } else if (vec[i] == \"BB\") {\n      vec[i] &lt;- \"jota\"\n    } else if (vec[i] == \"BBB\") {\n      vec[i] &lt;- \"diez\"\n    } else {\n      vec[i] &lt;- \"nueve\"\n    } \n  }\n  vec\n}\n\nvec &lt;- c(\"DD\", \"C\", \"7\", \"B\", \"BB\", \"BBB\", \"0\")\n\ncambiar_simbolos(vec)\n##  \"comodín\" \"as\"   \"rey\"  \"reina\" \"jota\"  \"diez\"   \"nueve\"\n\nmuchas &lt;- rep(vec, 1000000)\n\nsystem.time(cambiar_simbolos(muchas))\n##    user  system elapsed \n##  30.057   0.031  30.079\nSolución. cambiar_simbolos usa un bucle for para clasificar los valores en siete casos diferentes, como se muestra en la Figura Figura 10.3.\nPara vectorizar cambiar_simbolos, cree una prueba lógica que pueda identificar cada caso:\nvec[vec == \"DD\"]\n## \"DD\"\n\nvec[vec == \"C\"]\n## \"C\"\n\nvec[vec == \"7\"]\n## \"7\"\n\nvec[vec == \"B\"]\n## \"B\"\n\nvec[vec == \"BB\"]\n## \"BB\"\n\nvec[vec == \"BBB\"]\n## \"BBB\"\n\nvec[vec == \"0\"]\n## \"0\"\n\n\n\n\n\n\n\nFigura 10.3: cambiar_simbolos hace algo diferente para cada uno de los siete casos.\n\n\n\n\nLuego escribe código que pueda cambiar los símbolos para cada caso:\nvec[vec == \"DD\"] &lt;- \"comodín\"\nvec[vec == \"C\"] &lt;- \"as\"\nvec[vec == \"7\"] &lt;- \"rey\"\nvec[vec == \"B\"] &lt;- \"reina\"\nvec[vec == \"BB\"] &lt;- \"jota\"\nvec[vec == \"BBB\"] &lt;- \"diez\"\nvec[vec == \"0\"] &lt;- \"nueve\"\nCuando combinas esto en una función, tienes una versión vectorizada de cambiar_simbolos que se ejecuta unas 14 veces más rápido:\ncambiar_vec &lt;- function (vec) {\n  vec[vec == \"DD\"] &lt;- \"comodín\"\n  vec[vec == \"C\"] &lt;- \"as\"\n  vec[vec == \"7\"] &lt;- \"rey\"\n  vec[vec == \"B\"] &lt;- \"reina\"\n  vec[vec == \"BB\"] &lt;- \"jota\"\n  vec[vec == \"BBB\"] &lt;- \"diez\"\n  vec[vec == \"0\"] &lt;- \"nueve\"\n  \n  vec\n}\n\nsystem.time(cambiar_vec(muchas))\n##   user  system elapsed \n##  1.994   0.059   2.051 \nO, mejor aún, use una tabla de búsqueda. Las tablas de búsqueda son un método vectorizado porque se basan en las operaciones de selección vectorizadas de R:\ncambiar_vec2 &lt;- function(vec){\n  tb &lt;- c(\"DD\" = \"comodín\", \"C\" = \"as\", \"7\" = \"rey\", \"B\" = \"reina\",\n    \"BB\" = \"jota\", \"BBB\" = \"diez\", \"0\" = \"nueve\")\n  unname(tb[vec])\n}\n\nsystem.time(cambiar_vec2(muchas))\n##   user  system elapsed \n##  0.687   0.059   0.746 \nAquí, una tabla de búsqueda es 40 veces más rápida que la función original.\nabs_bucle y cambiar_simbolos ilustran una característica del código vectorizado: los programadores a menudo escriben código no vectorizado más lento basándose en bucles for innecesarios, como el de change_simbolos. Creo que esto es el resultado de un malentendido general sobre R. Los bucles for no se comportan de la misma manera en R que en otros lenguajes, lo que significa que debe escribir código en R de manera diferente a como lo haría en otros lenguajes.\nCuando escribe en lenguajes como C y Fortran, debe compilar su código antes de que su computadora pueda ejecutarlo. Este paso de compilación optimiza cómo los bucles for en el código usan la memoria de su computadora, lo que hace que los bucles for sean muy rápidos. Como resultado, muchos programadores usan bucles for con frecuencia cuando escriben en C y Fortran.\nSin embargo, cuando escribe en R, no compila su código. Omite este paso, lo que hace que la programación en R sea una experiencia más fácil de usar. Desafortunadamente, esto también significa que no le da a sus bucles el aumento de velocidad que recibirían en C o Fortran. Como resultado, sus bucles se ejecutarán más lentamente que las otras operaciones que hemos estudiado: pruebas lógicas, creación de subconjuntos y ejecución por elementos. Si puede escribir su código con las operaciones más rápidas en lugar de un bucle for, debe hacerlo. Independientemente del idioma en el que escriba, debe intentar utilizar las funciones del idioma que se ejecute más rápido.\n\n\n\n\n\n\nif y for\nUna buena forma de detectar bucles for que podrían vectorizarse es buscar combinaciones de if y for. if solo se puede aplicar a un valor a la vez, lo que significa que a menudo se usa junto con un bucle for. El ciclo for ayuda a aplicar if a un vector completo de valores. Esta combinación generalmente se puede reemplazar con un subconjunto lógico, que hará lo mismo pero se ejecutará mucho más rápido.\n\n\n\nEsto no significa que nunca debas usar bucles for en R. Todavía hay muchos lugares en R donde los bucles for tienen sentido. Los bucles for realizan una tarea básica que no siempre se puede recrear con código vectorizado. Los bucles for también son fáciles de entender y se ejecutan razonablemente rápido en R, siempre que tome algunas precauciones.",
    "crumbs": [
      "Proyecto 3: Máquina Tragamonedas",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Velocidad</span>"
    ]
  },
  {
    "objectID": "speed.html#cómo-escribir-bucles-for-rápidos-en-r",
    "href": "speed.html#cómo-escribir-bucles-for-rápidos-en-r",
    "title": "10  Velocidad",
    "section": "\n10.3 Cómo Escribir Bucles for Rápidos en R",
    "text": "10.3 Cómo Escribir Bucles for Rápidos en R\nPuede aumentar drásticamente la velocidad de sus bucles for haciendo dos cosas para optimizar cada bucle. Primero, haz todo lo que puedas fuera del bucle for. Cada línea de código que coloques dentro del bucle for se ejecutará muchas, muchas veces. Si una línea de código solo necesita ejecutarse una vez, colóquela fuera del ciclo para evitar la repetición.\nEn segundo lugar, asegúrese de que cualquier objeto de almacenamiento que utilice con el ciclo sea lo suficientemente grande como para contener todos los resultados del ciclo. Por ejemplo, ambos bucles a continuación necesitarán almacenar un millón de valores. El primer ciclo almacena sus valores en un objeto llamado salida que comienza con una longitud de un millón:\nsystem.time({\n  salida &lt;- rep(NA, 1000000) \n  for (i in 1:1000000) {\n    salida[i] &lt;- i + 1\n  }\n})\n##   user  system elapsed \n##  1.709   0.015   1.724 \nEl segundo ciclo almacena sus valores en un objeto llamado salida que comienza con una longitud de uno. R expandirá el objeto a una longitud de un millón mientras ejecuta el bucle. El código de este ciclo es muy similar al código del primer ciclo, pero el ciclo tarda 37 minutos más en ejecutarse que el primer ciclo:\nsystem.time({\n  salida &lt;- NA \n  for (i in 1:1000000) {\n    salida[i] &lt;- i + 1\n  }\n})\n##     user   system  elapsed \n## 1689.537  560.951 2249.927\nLos dos bucles hacen lo mismo, entonces, ¿qué explica la diferencia? En el segundo bucle, R tiene que aumentar la longitud de salida en uno para cada ejecución del bucle. Para hacer esto, R necesita encontrar un nuevo lugar en la memoria de su computadora que pueda contener el objeto más grande. Luego, R debe copiar el vector salida y borrar la versión anterior de salida antes de pasar a la siguiente ejecución del bucle. Al final del ciclo, R ha reescrito salida en la memoria de su computadora un millón de veces.\nEn el primer caso, el tamaño de salida nunca cambia; R puede definir un objeto salida en la memoria y usarlo para cada ejecución del bucle for.\n\n\n\n\n\n\nLos autores de R usan lenguajes de bajo nivel como C y Fortran para escribir funciones básicas de R, muchas de las cuales usan bucles for. Estas funciones se compilan y optimizan antes de que se conviertan en parte de R, lo que las hace bastante rápidas.\nCada vez que vea .Primitive, .Internal o .Call escrito en la definición de una función, puede estar seguro de que la función está llamando al código de otro idioma. Obtendrá todas las ventajas de velocidad de ese idioma al usar la función.",
    "crumbs": [
      "Proyecto 3: Máquina Tragamonedas",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Velocidad</span>"
    ]
  },
  {
    "objectID": "speed.html#código-vectorizado-en-la-práctica",
    "href": "speed.html#código-vectorizado-en-la-práctica",
    "title": "10  Velocidad",
    "section": "\n10.4 Código Vectorizado en la Práctica",
    "text": "10.4 Código Vectorizado en la Práctica\nPara ver cómo el código vectorizado puede ayudarlo como científico de datos, considere nuestro proyecto de máquina tragamonedas. En Bucles, calculó la tasa de pago exacta para su máquina tragamonedas, pero podría haber estimado esta tasa de pago con una simulación. Si jugaste a la máquina tragamonedas muchas, muchas veces, el premio promedio de todas las jugadas sería una buena estimación de la verdadera tasa de pago.\nEste método de estimación se basa en la ley de los grandes números y es similar a muchas simulaciones estadísticas. Para ejecutar esta simulación, podría usar un bucle for:\nganadas &lt;- vector(length = 1000000)\nfor (i in 1:1000000) {\n  ganadas[i] &lt;- play()\n}\n\nmean(ganadas)\n## 0.9366984\nLa tasa de pago estimada después de 10 millones de ejecuciones es 0,937, que está muy cerca de la tasa de pago real de 0,934. Tenga en cuenta que estoy usando la función puntuacion modificada que trata a los diamantes como comodines.\nSi ejecuta esta simulación, notará que tarda un tiempo en ejecutarse. De hecho, la simulación tarda 342.308 segundos en ejecutarse, lo que equivale a unos 5,7 minutos. Esto no es particularmente impresionante, y puede hacerlo mejor usando código vectorizado:\nsystem.time(for (i in 1:1000000) {\n  ganadas[i] &lt;- play()\n})\n##    user  system elapsed \n## 342.041   0.355 342.308 \nLa función puntuacion actual no está vectorizada. Toma una sola combinación de tragamonedas y usa un árbol if para asignarle un premio. Esta combinación de un árbol if con un bucle for sugiere que podrías escribir una pieza de código vectorizado que tome muchas combinaciones de ranuras y luego use subconjuntos lógicos para operar en todas ellas a la vez.\nPor ejemplo, podría reescribir obt_simbolos para generar n combinaciones de ranuras y devolverlas como una matriz n x 3, como la siguiente. Cada fila de la matriz contendrá una combinación de espacios para ser puntuada:\nobt_muchos_simbolos &lt;- function(n) {\n  rueda &lt;- c(\"DD\", \"7\", \"BBB\", \"BB\", \"B\", \"C\", \"0\")\n  vec &lt;- sample(rueda, size = 3 * n, replace = TRUE,\n    prob = c(0.03, 0.03, 0.06, 0.1, 0.25, 0.01, 0.52))\n  matrix(vec, ncol = 3)\n}\n\nobt_muchos_simbolos(5)\n##      [,1]  [,2] [,3] \n## [1,] \"B\"   \"0\"  \"B\"  \n## [2,] \"0\"   \"BB\" \"7\"  \n## [3,] \"0\"   \"0\"  \"BBB\"\n## [4,] \"0\"   \"0\"  \"B\"  \n## [5,] \"BBB\" \"0\"  \"0\" \nTambién podría reescribir play para tomar un parámetro, n, y devolver n premios, en un data frame:\nplay_muchas &lt;- function(n) {\n  simb_mat &lt;- obt_muchos_simbolos(n = n)\n  data.frame(w1 = simb_mat[,1], w2 = simb_mat[,2],\n             w3 = simb_mat[,3], prize = puntuacion_muchas(simb_mat))\n}\nEsta nueva función facilitaría la simulación de un millón, o incluso 10 millones de jugadas de la máquina tragamonedas, que será nuestro objetivo. Cuando hayamos terminado, podrá estimar la tasa de pago con:\n# jugadas &lt;- play_muchas(10000000))\n# mean(jugadas$premio)\nAhora solo necesitas escribir puntuacion_muchas, una versión vectorizada (¿matrixada?) de puntuacion que toma una matriz n x 3 y devuelve n premios. Será difícil escribir esta función porque puntuacion ya es bastante complicado. No espero que se sienta seguro haciendo esto por su cuenta hasta que tenga más práctica y experiencia de la que hemos podido desarrollar aquí.\nSi desea probar sus habilidades y escribir una versión de puntuacio_muchas, le recomiendo que use la función rowSums dentro de su código. Calcula la suma de cada fila de números (o lógicos) en una matriz.\nSi desea probarse a sí mismo de una manera más modesta, le recomiendo que estudie el siguiente modelo de función puntuacion_muchas hasta que comprenda cómo funciona cada parte y cómo las partes trabajan juntas para crear una función vectorizada. Para hacer esto, será útil crear un ejemplo concreto, como este:\nsimbolos &lt;- matrix(\n  c(\"DD\", \"DD\", \"DD\", \n    \"C\", \"DD\", \"0\", \n    \"B\", \"B\", \"B\", \n    \"B\", \"BB\", \"BBB\", \n    \"C\", \"C\", \"0\", \n    \"7\", \"DD\", \"DD\"), nrow = 6, byrow = TRUE)\n\nsimbolos\n##      [,1] [,2] [,3] \n## [1,] \"DD\" \"DD\" \"DD\" \n## [2,] \"C\"  \"DD\" \"0\"  \n## [3,] \"B\"  \"B\"  \"B\"  \n## [4,] \"B\"  \"BB\" \"BBB\"\n## [5,] \"C\"  \"C\"  \"0\"  \n## [6,] \"7\"  \"DD\" \"DD\" \nLuego puede ejecutar cada línea de puntuacion_muchas contra el ejemplo y examinar los resultados a medida que avanza.\nEjercicio 13.3 (Pon a Prueba tu Comprensión) Estudie la función del modelo puntuaciio_muchas hasta que esté satisfecho de que entiende cómo funciona y podría escribir una función similar usted mismo.\nEjercicio 13.4 (Desafío Avanzado) En lugar de examinar la respuesta modelo, escriba su propia versión vectorizada de puntuacion. Suponga que los datos se almacenan en un n × 3 matriz donde cada fila de la matriz contiene una combinación de ranuras para puntuar.\nPuede usar la versión de puntuacion que trata a los diamantes como comodines o la versión de puntuacion que no lo hace. Sin embargo, la respuesta de ejemplo usará la versión que trata a los diamantes como comodines.\nSolución. puntuacion_muchas es una versión vectorizada de puntuacion. Puede usarlo para ejecutar la simulación al comienzo de esta sección en poco más de 20 segundos. Esto es 17 veces más rápido que usar un bucle for:\n# los símbolos deben ser una matriz con una columna para cada ventana de la máquina tragamonedas\npuntuacion_muchas &lt;- function(simbolos) {\n\n  # Paso 1: Asigne el premio base basado en cerezas y diamantes ---------\n  ## Cuente el número de cerezas y diamantes en cada combinación.\n  cerezas &lt;- rowSums(simbolos == \"C\")\n  diamantes &lt;- rowSums(simbolos == \"DD\") \n  \n  ## Los diamantes salvajes cuentan como cerezas\n  premio &lt;- c(0, 2, 5)[cerezas + diamantes + 1]\n  \n  ## ...pero no si hay cero cerezas reales \n  ### (cerezas es forzado a FALSE donde cerezas == 0)\n  premio[!cerezas] &lt;- 0\n  \n  # Paso 2: Cambie el premio por combinaciones que contengan tríos \n  iguales &lt;- simbolos[, 1] == simbolos[, 2] & \n    simbolos[, 2] == simbolos[, 3]\n  pagos &lt;- c(\"DD\" = 100, \"7\" = 80, \"BBB\" = 40, \n    \"BB\" = 25, \"B\" = 10, \"C\" = 10, \"0\" = 0)\n  premio[iguales] &lt;- pagos[simbolos[iguales, 1]]\n  \n  # Paso 3: Cambia el premio por combinaciones que contengan todas barras ------\n  barras &lt;- simbolos == \"B\" | simbolos ==  \"BB\" | simbolos == \"BBB\"\n  todas_barras &lt;- barras[, 1] & barras[, 2] & barras[, 3] & !iguales\n  premio[todas_barras] &lt;- 5\n  \n  # Paso 4: Manejar comodines ---------------------------------------------\n  \n  ## combos con dos diamantes\n  dos_salvajes &lt;- diamantes == 2\n\n  ### Identificar el simbolo no salvaje\n  uno &lt;- dos_salvajes & simbolos[, 1] != simbolos[, 2] & \n    simbolos[, 2] == simbolos[, 3]\n  dos &lt;- dos_salvajes & simbolos[, 1] != simbolos[, 2] & \n    simbolos[, 1] == simbolos[, 3]\n  tres &lt;- dos_salvajes & simbolos[, 1] == simbolos[, 2] & \n    simbolos[, 2] != simbolos[, 3]\n  \n  ### Tratar como tres de una clase\n  premio[uno] &lt;- pagos[simbolos[uno, 1]]\n  premio[dos] &lt;- pagos[simbolos[dos, 2]]\n  premio[tres] &lt;- pagos[simbolos[tres, 3]]\n  \n  ## combos con un salvaje\n  un_salvaje &lt;- diamantes == 1\n  \n  ### Tratar como todas las barras (si corresponde)\n  barras_salvajes &lt;- un_salvaje & (rowSums(barras) == 2)\n  premio[barras_salvajes] &lt;- 5\n  \n  ### Tratar como tres de una clase (si corresponde)\n  uno &lt;- un_salvaje & simbolos[, 1] == simbolos[, 2]\n  dos &lt;- un_salvaje & simbolos[, 2] == simbolos[, 3]\n  tres &lt;- un_salvaje & simbolos[, 3] == simbolos[, 1]\n  premio[uno] &lt;- pagos[simbolos[uno, 1]]\n  premio[dos] &lt;- pagos[simbolos[dos, 2]]\n  premio[tres] &lt;- pagos[simbolos[tres, 3]]\n \n  # Paso 5: Premio doble por cada diamante en combo ------------------\n  unname(premio * 2^diamantes)\n  \n}\n\nsystem.time(play_muchas(10000000))\n##   user  system elapsed \n## 20.942   1.433  22.367\n\n10.4.1 Bucles vs Código Vectorizado\nEn muchos idiomas, los bucles for se ejecutan muy rápido. Como resultado, los programadores aprenden a usar bucles for siempre que sea posible cuando codifican. A menudo, estos programadores continúan confiando en los bucles for cuando comienzan a programar en R, normalmente sin tomar los pasos necesarios para optimizar los bucles for de R. Estos programadores pueden desilusionarse con R cuando su código no funciona tan rápido como les gustaría. Si cree que esto le puede estar pasando a usted, examine con qué frecuencia está usando bucles for y para qué los está usando. Si te encuentras usando bucles for para cada tarea, es muy probable que estés “hablando R con acento C”. La cura es aprender a escribir y usar código vectorizado.\nEsto no significa que los bucles for no tengan cabida en R. Los bucles for son una característica muy útil; pueden hacer muchas cosas que el código vectorizado no puede hacer. Tampoco debe convertirse en esclavo del código vectorizado. A veces llevaría más tiempo reescribir el código en formato vectorizado que dejar que se ejecute un bucle for. Por ejemplo, ¿sería más rápido dejar que la simulación de tragamonedas se ejecute durante 5,7 minutos o volver a escribir puntuacion?",
    "crumbs": [
      "Proyecto 3: Máquina Tragamonedas",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Velocidad</span>"
    ]
  },
  {
    "objectID": "speed.html#resumen",
    "href": "speed.html#resumen",
    "title": "10  Velocidad",
    "section": "\n10.5 Resumen",
    "text": "10.5 Resumen\nEl código rápido es un componente importante de la ciencia de datos porque puede hacer más con el código rápido que con el código lento. Puede trabajar con conjuntos de datos más grandes antes de que intervengan las restricciones computacionales y puede hacer más cálculos antes de que intervengan las restricciones de tiempo. El código más rápido en R se basará en las cosas que R hace mejor: pruebas lógicas, creación de subconjuntos y ejecución por elementos. He llamado a este tipo de código código vectorizado porque el código escrito con estas operaciones tomará un vector de valores como entrada y operará en cada elemento del vector al mismo tiempo. La mayoría del código escrito en R ya está vectorizado.\nSi usa estas operaciones, pero su código no aparece vectorizado, analice los pasos secuenciales y los casos paralelos en su programa. Asegúrese de haber utilizado funciones vectorizadas para manejar los pasos y subconjuntos lógicos para manejar los casos. Tenga en cuenta, sin embargo, que algunas tareas no se pueden vectorizar.",
    "crumbs": [
      "Proyecto 3: Máquina Tragamonedas",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Velocidad</span>"
    ]
  },
  {
    "objectID": "speed.html#resumen-del-proyecto-3",
    "href": "speed.html#resumen-del-proyecto-3",
    "title": "10  Velocidad",
    "section": "\n10.6 Resumen del Proyecto 3",
    "text": "10.6 Resumen del Proyecto 3\nAhora ha escrito su primer programa en R, y es un programa del que debería estar orgulloso. play no es un simple ejercicio de hola mundo, sino un programa real que realiza una tarea real de una manera complicada.\nEscribir nuevos programas en R siempre será un desafío porque la programación depende mucho de su propia creatividad, capacidad de resolución de problemas y experiencia escribiendo tipos de programas similares. Sin embargo, puede usar las sugerencias de este capítulo para hacer que incluso el programa más complicado sea manejable: divida las tareas en pasos y casos simples, trabaje con ejemplos concretos y describa posibles soluciones en español.\nEste proyecto completa la educación que comenzaste en Lo Más Básico. Ahora puede usar R para manejar datos, lo que ha aumentado su capacidad para analizar datos. Usted puede:\n\nCargue y almacene datos en su computadora, no en papel o en su mente\nRecuerda y cambia con precisión valores individuales sin depender de tu memoria\nIndique a su computadora que realice tareas tediosas o complejas en su nombre\n\nEstas habilidades resuelven un problema logístico importante al que se enfrenta todo científico de datos: ¿cómo puede almacenar y manipular datos sin cometer errores? Sin embargo, este no es el único problema al que se enfrentará como científico de datos. El siguiente problema aparecerá cuando intente comprender la información contenida en sus datos. Es casi imposible detectar ideas o descubrir patrones en datos sin procesar. Aparecerá un tercer problema cuando intente usar su conjunto de datos para razonar sobre la realidad, que incluye cosas que no están contenidas en su conjunto de datos. ¿Qué implican exactamente sus datos sobre cosas fuera del conjunto de datos? ¿Qué tan seguro puedes estar?\nMe refiero a estos problemas como problemas logísticos, tácticos y estratégicos de la ciencia de datos, como se muestra en la Figura Figura 10.4. Los enfrentará cada vez que intente aprender de los datos:\n\n\nUn problema logístico: - ¿Cómo puedes almacenar y manipular datos sin cometer errores?\n\nUn problema táctico - ¿Cómo puedes descubrir la información contenida en tus datos?\n\nUn problema estratégico - ¿Cómo puedes usar los datos para sacar conclusiones sobre el mundo en general?\n\n\n\n\n\n\n\n\nFigura 10.4: Los tres conjuntos de habilidades básicas de la ciencia de datos: programación informática, comprensión de datos y razonamiento científico.\n\n\n\n\nUn científico de datos completo deberá poder resolver cada uno de estos problemas en muchas situaciones diferentes. Al aprender a programar en R, domina el problema logístico, que es un requisito previo para resolver los problemas tácticos y estratégicos.\nSi desea aprender a razonar con datos, o cómo transformar, visualizar y explorar sus conjuntos de datos con herramientas R, le recomiendo el libro R for Data Science, el volumen complementario de este libro. R for Data Science enseña un flujo de trabajo simple para transformar, visualizar y modelar datos en R, así como también cómo informar los resultados con el paquete R Markdown.",
    "crumbs": [
      "Proyecto 3: Máquina Tragamonedas",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Velocidad</span>"
    ]
  },
  {
    "objectID": "a1-starting.html",
    "href": "a1-starting.html",
    "title": "Apéndice A — Instalación de R y RStudio",
    "section": "",
    "text": "A.1 Cómo descargar e instalar R\nPara comenzar con R, debe adquirir su propia copia. Este apéndice le mostrará cómo descargar R así como RStudio, una aplicación de software que facilita el uso de R. Pasará de descargar R a abrir su primera sesión de R.\nTanto R como RStudio son gratuitos y fáciles de descargar.\nR es mantenido por un equipo internacional de desarrolladores que hacen que el lenguaje esté disponible a través de la página web de The Comprehensive R Archive Network. La parte superior de la página web proporciona tres enlaces para descargar R. Siga el enlace que describe su sistema operativo: Windows, Mac o Linux.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Instalación de R y RStudio</span>"
    ]
  },
  {
    "objectID": "a1-starting.html#cómo-descargar-e-instalar-r",
    "href": "a1-starting.html#cómo-descargar-e-instalar-r",
    "title": "Apéndice A — Instalación de R y RStudio",
    "section": "",
    "text": "A.1.1 Windows\nPara instalar R en Windows, haga clic en el enlace “Download R for Windows”. Luego haga clic en el enlace “base”. A continuación, haga clic en el primer enlace en la parte superior de la nueva página. Este enlace debería decir algo como “Descargar R 3.0.3 para Windows”, excepto que la 3.0.3 será reemplazada por la versión más reciente de R. El enlace descarga un programa de instalación, que instala la versión más actualizada de R para Windows. Ejecute este programa y siga los pasos del asistente de instalación que aparece. El asistente instalará R en sus carpetas de archivos de programa y colocará un acceso directo en su menú Inicio. Tenga en cuenta que deberá tener todos los privilegios de administración apropiados para instalar software nuevo en su máquina.\n\nA.1.2 Mac\nPara instalar R en una Mac, haga clic en el enlace “Download R for Mac”. A continuación, haga clic en el enlace del paquete R-3.0.3 (o en el enlace del paquete para la versión más reciente de R). Se descargará un instalador para guiarlo a través del proceso de instalación, que es muy fácil. El instalador le permite personalizar su instalación, pero los valores predeterminados serán adecuados para la mayoría de los usuarios. Nunca he encontrado una razón para cambiarlos. Si su computadora requiere una contraseña antes de instalar nuevos programas, la necesitará aquí.\n\n\n\n\n\n\nBinarios versus Fuente\nR se puede instalar a partir de archivos binarios precompilados o compilarse desde el origen en cualquier sistema operativo. Para máquinas Windows y Mac, instalar R desde binarios es extremadamente fácil. El binario viene precargado en su propio instalador. Aunque puede compilar R desde el origen en estas plataformas, el proceso es mucho más complicado y no brindará muchos beneficios a la mayoría de los usuarios. Para los sistemas Linux, ocurre lo contrario. Se pueden encontrar binarios precompilados para algunos sistemas, pero es mucho más común compilar R a partir de archivos fuente cuando se instala en Linux. Las páginas de descarga en el sitio web de CRAN brindan información sobre la creación de R desde el origen para las plataformas Windows, Mac y Linux.\n\n\n\n\nA.1.3 Linux\nR viene preinstalado en muchos sistemas Linux, pero querrá la versión más reciente de R si la suya no está actualizada. El sitio web de CRAN proporciona archivos para compilar R desde la fuente en los sistemas Debian, Redhat, SUSE y Ubuntu en el enlace “Descargar R para Linux”. Haga clic en el enlace y luego siga el rastro del directorio hasta la versión de Linux en la que desea instalar. El procedimiento de instalación exacto variará según el sistema Linux que utilice. CRAN guía el proceso agrupando cada conjunto de archivos fuente con documentación o archivos README que explican cómo instalar en su sistema.\n\n\n\n\n\n\n32-bit Versus 64-bit\nR viene en versiones de 32 y 64 bits. ¿Cuál deberías usar? En la mayoría de los casos, no importará. Ambas versiones usan números enteros de 32 bits, lo que significa que calculan números con la misma precisión numérica. La diferencia ocurre en la forma en que cada versión administra la memoria. R de 64 bits usa punteros de memoria de 64 bits y R de 32 bits usa punteros de memoria de 32 bits. Esto significa que R de 64 bits tiene un espacio de memoria más grande para usar (y buscar).\nComo regla general, las compilaciones de R de 32 bits son más rápidas que las compilaciones de 64 bits, aunque no siempre. Por otro lado, las compilaciones de 64 bits pueden manejar archivos y conjuntos de datos más grandes con menos problemas de administración de memoria. En cualquiera de las versiones, el tamaño de vector máximo permitido alcanza un máximo de alrededor de 2 mil millones de elementos. Si su sistema operativo no es compatible con programas de 64 bits, o su memoria RAM es inferior a 4 GB, la versión R de 32 bits es para usted. Los instaladores de Windows y Mac instalarán automáticamente ambas versiones si su sistema es compatible con R de 64 bits.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Instalación de R y RStudio</span>"
    ]
  },
  {
    "objectID": "a1-starting.html#usando-r",
    "href": "a1-starting.html#usando-r",
    "title": "Apéndice A — Instalación de R y RStudio",
    "section": "\nA.2 Usando R",
    "text": "A.2 Usando R\nR no es un programa que pueda abrir y comenzar a usar, como Microsoft Word o Internet Explorer. En cambio, R es un lenguaje de programación, como C, C++ o UNIX. Usas R escribiendo comandos en el lenguaje R y pidiéndole a tu computadora que los interprete. En los viejos tiempos, la gente ejecutaba código R en una ventana de terminal UNIX, como si fueran piratas informáticos en una película de los años ochenta. Ahora casi todo el mundo usa R con una aplicación llamada RStudio, y te recomiendo que tú también lo hagas.\n\n\n\n\n\n\nR y UNIX\nTodavía puede ejecutar R en una ventana de UNIX o BASH escribiendo el comando:\nR\nque abre un intérprete de R. Luego puede hacer su trabajo y cerrar el intérprete ejecutando q() cuando haya terminado.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Instalación de R y RStudio</span>"
    ]
  },
  {
    "objectID": "a1-starting.html#rstudio",
    "href": "a1-starting.html#rstudio",
    "title": "Apéndice A — Instalación de R y RStudio",
    "section": "\nA.3 RStudio",
    "text": "A.3 RStudio\nRStudio es una applicación como Microsoft Word—excepto que en lugar de ayudarlo a escribir texto convencional, RStudio lo ayuda a escribir en R. Uso RStudio en todo el libro porque hace que usar R sea mucho más fácil. Además, la interfaz de RStudio tiene el mismo aspecto para Windows, Mac OS y Linux. Eso me ayudará a relacionar el libro con su experiencia personal.\nPuede descargar RStudio de fomra gratuita. Simplemente haga clic en el botón “Download RStudio” y siga las instrucciones. Una vez que haya instalado RStudio, puede abrirlo como cualquier otro programa en su computadora—generalmente haciendo clic en un ícono en su escritorio.\n\n\n\n\n\n\nLas interfaces gráficas de usuario de R\nLos usuarios de Windows y Mac generalmente no programan desde una ventana de terminal, por lo que las descargas de Windows y Mac para R vienen con un programa simple que abre una ventana similar a una terminal para que pueda ejecutar el código R. Esto es lo que se abre cuando hace clic en el icono de R en su computadora con Windows o Mac. Estos programas hacen un poco más que la ventana de terminal básica, pero no mucho. Es posible que escuche que las personas se refieren a ellos como las interfarces gráficas de usuarios de R para Windows o Mac.\n\n\n\nCuando abre RStudio, aparece una ventana con tres paneles, como en la Figura Figura A.1. El panel más grande es una ventana de consola. Aquí es donde ejecutará su código R y verá los resultados. La ventana de la consola es exactamente lo que vería si ejecutara R desde una consola UNIX o las IGU de Windows o Mac. Todo lo demás que ve es exclusivo de RStudio. Ocultos en los otros paneles hay un editor de texto, una ventana de gráficos, un depurador, un administrador de archivos y mucho más. Aprenderá acerca de estos paneles a medida que se vuelvan útiles a lo largo de este libro.\n\n\n\n\n\n\n\nFigura A.1: El Entorno de Desarrollo Integrado de RStudio para R.\n\n\n\n\n\n\n\n\n\n\n¿Todavía necesito descargar R?\nIncluso si usa RStudio, aún necesitará descargar R a su computadora. RStudio lo ayuda a usar la versión de R que vive en su computadora, pero no viene con una versión de R propia.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Instalación de R y RStudio</span>"
    ]
  },
  {
    "objectID": "a1-starting.html#abriendo-r",
    "href": "a1-starting.html#abriendo-r",
    "title": "Apéndice A — Instalación de R y RStudio",
    "section": "\nA.4 Abriendo R",
    "text": "A.4 Abriendo R\nAhora que tiene R y RStudio en su computadora, puede comenzar a usar R abriendo el programa RStudio. Abra RStudio como lo haría con cualquier programa, haciendo clic en su icono o escribiendo “RStudio” en el indicador de ejecución de Windows.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Instalación de R y RStudio</span>"
    ]
  },
  {
    "objectID": "a2-packages.html",
    "href": "a2-packages.html",
    "title": "Apéndice B — Paquetes de R",
    "section": "",
    "text": "B.1 Instalando Paquetes\nMuchas de las funciones más útiles de R no vienen precargadas cuando inicia R, sino que residen en paquetes que se pueden instalar encima de R. Los paquetes de R son similares a las bibliotecas en C, C++ y Javascript, los paquetes en Python y las gemas en Ruby. Un paquete de R agrupa funciones útiles, archivos de ayuda y conjuntos de datos. Puede usar estas funciones dentro de su propio código de R una vez que cargue el paquete en el que se encuentran. Por lo general, el contenido de un paquete de R está relacionado con un solo tipo de tarea, que el paquete ayuda a resolver. Los paquetes R le permitirán aprovechar las características más útiles de R: su gran comunidad de creadores de paquetes (muchos de los cuales son científicos de datos activos) y sus rutinas preescritas para manejar muchas tareas comunes (y exóticas) de ciencia de datos.\nPara usar un paquete de R, primero debe instalarlo en su computadora y luego cargarlo en su sesión de R actual. La forma más fácil de instalar un paquete de R es con la función de R install.packages. Abra R y escriba lo siguiente en la línea de comando:\nEsto buscará el paquete especificado en la colección de paquetes alojados en el sitio CRAN. Cuando R encuentre el paquete, lo descargará en una carpeta de bibliotecas en su computadora. R puede acceder al paquete aquí en futuras sesiones de R sin reinstalarlo. Cualquiera puede escribir un paquete R y distribuirlo como quiera; sin embargo, casi todos los paquetes de R se publican a través del sitio web de CRAN. CRAN prueba cada paquete R antes de publicarlo. Esto no elimina todos los errores dentro de un paquete, pero significa que puede confiar en que un paquete en CRAN se ejecutará en la versión actual de R en su sistema operativo.\nPuede instalar varios paquetes a la vez vinculando sus nombres con la función de concatenación de R, c. Por ejemplo, para instalar los paquetes ggplot2, reshape2 y dplyr, ejecute:\nSi es la primera vez que instala un paquete, R le pedirá que elija un espejo en línea para instalarlo. Los espejos se enumeran por ubicación. Sus descargas deberían ser más rápidas si selecciona un espejo que esté cerca de usted. Si desea descargar un nuevo paquete, pruebe primero el espejo de Austria. Este es el repositorio principal de CRAN y, a veces, los nuevos paquetes pueden tardar un par de días en llegar a todos los demás espejos.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Paquetes de R</span>"
    ]
  },
  {
    "objectID": "a2-packages.html#instalando-paquetes",
    "href": "a2-packages.html#instalando-paquetes",
    "title": "Apéndice B — Paquetes de R",
    "section": "",
    "text": "install.packages(\"&lt;nombre del paquete&gt;\")\n\n\ninstall.packages(c(\"ggplot2\", \"reshape2\", \"dplyr\"))",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Paquetes de R</span>"
    ]
  },
  {
    "objectID": "a2-packages.html#cargando-paquetes",
    "href": "a2-packages.html#cargando-paquetes",
    "title": "Apéndice B — Paquetes de R",
    "section": "B.2 Cargando Paquetes",
    "text": "B.2 Cargando Paquetes\nLa instalación de un paquete no pone inmediatamente sus funciones al alcance de su mano. Simplemente los coloca en su computadora. Para usar un paquete de R, luego debe cargarlo en su sesión de R con el comando:\nlibrary(&lt;nombre del paquete&gt;)\nObserve que las comillas han desaparecido. Puede usarlos si lo desea, pero las comillas son opcionales para el comando library. (Esto no es cierto para el comando install.packages).\nlibrary pondrá a su disposición todas las funciones, conjuntos de datos y archivos de ayuda del paquete hasta que cierre su sesión de R actual. La próxima vez que inicie una sesión de R, deberá volver a cargar el paquete con library si desea utilizarlo, pero no tendrá que volver a instalarlo. Solo tiene que instalar cada paquete una vez. Después de eso, una copia del paquete vivirá en su biblioteca de R. Para ver qué paquetes tiene actualmente en su biblioteca de R, ejecute:\nlibrary()\nlibrary() también muestra la ruta a su biblioteca de R actual, que es la carpeta que contiene sus paquetes de R. Puede notar muchos paquetes que no recuerda haber instalado. Esto se debe a que R descarga automáticamente un conjunto de paquetes útiles cuando instala R por primera vez.\n\n\n\n\n\n\nInstalar paquetes desde (casi) cualquier sitio\nEl paquete devtools de R facilita la instalación de paquetes desde ubicaciones distintas al sitio web de CRAN. devtools proporciona funciones como install_github, install_gitorious, install_bitbucket e install_url. Estos funcionan de manera similar a install.packages, pero buscan nuevas ubicaciones para paquetes de R. install_github es especialmente útil porque muchos desarrolladores de R proporcionan versiones de desarrollo de sus paquetes en GitHub. La versión de desarrollo de un paquete contendrá un adelanto de nuevas funciones y parches, pero puede que no sea tan estable o libre de errores como la versión CRAN.\n\n\n\n¿Por qué R hace que te molestes en instalar y cargar paquetes? Puede imaginar una versión de R en la que todos los paquetes vengan precargados, pero este sería un programa muy grande y lento. A fecha del 6 de mayo de 2014, el sitio web de CRAN albergaba 5511 paquetes. Es más simple instalar y cargar solo los paquetes que desea usar cuando desea usarlos. Esto mantiene su copia de R rápida porque tiene menos funciones y páginas de ayuda para buscar en cualquier momento. Esto también tiene otros beneficios, por ejemplo, es posible actualizar su copia de un paquete de R sin actualizar toda su copia de R.\n\n\n\n\n\n\n¿Cuál es la mejor manera de aprender sobre los paquetes de R?\nEs difícil usar un paquete de R si no sabe que existe. Puede ir al sitio web de CRAN y hacer clic en el enlace Paquetes para ver una lista de paquetes disponibles, pero tendrá que leer miles de ellos. Además, muchos paquetes de R hacen lo mismo.\n¿Cómo sabe qué paquete los hace mejor? Los paquetes de R lista de correo es un lugar para comenzar. Envía anuncios de nuevos paquetes y mantiene un archivo de anuncios antiguos.Los blogs que agregan publicaciones sobre R también pueden proporcionar pistas valiosas, recomiendo R-bloggers. Posit mantiene una lista de algunos de los paquetes R más útiles en la sección de Getting Started de https://support.posit.co/. Finalmente, CRAN agrupa algunos de los paquetes más útiles y más respetados por área temática. Este es un excelente lugar para conocer los paquetes diseñados para su área de trabajo.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Paquetes de R</span>"
    ]
  },
  {
    "objectID": "a3-updating.html",
    "href": "a3-updating.html",
    "title": "Apéndice C — Actualizando R y sus Paquetes",
    "section": "",
    "text": "C.1 Paquetes de R\nEl equipo de desarrollo de R Core perfecciona continuamente el lenguaje R detectando errores, mejorando el rendimiento y actualizando R para que funcione con nuevas tecnologías. Como resultado, se lanzan nuevas versiones de R varias veces al año. La forma más fácil de mantenerse actualizado con R es consultar periódicamente el sitio web de CRAN. El sitio web se actualiza para cada nueva versión y hace que la versión esté disponible para su descarga. Tendrás que instalar la nueva versión. El proceso es el mismo que cuando instaló R por primera vez.\nNo se preocupe si no está interesado en mantenerse actualizado sobre las actividades de R Core. R cambia solo ligeramente entre versiones, y es probable que no note las diferencias. Sin embargo, actualizar a la versión actual de R es un buen lugar para comenzar si alguna vez encuentra un error que no puede explicar.\nPosit también mejora constantemente su producto, RStudio. Puede adquirir las actualizaciones más recientes simplemente descargándolas de Posit.\nLos autores de paquetes ocasionalmente lanzan nuevas versiones de sus paquetes para agregar funciones, corregir errores o mejorar el rendimiento. El comando update.packages verifica si tiene la versión más actual de un paquete e instala la versión más actual si no la tiene. La sintaxis de update.packages sigue la de install.packages. Si ya tiene ggplot2, reshape2 y dplyr en su computadora, sería una buena idea buscar actualizaciones antes de usarlas:\nDebe iniciar una nueva sesión de R después de actualizar los paquetes. Si tiene un paquete cargado cuando lo actualiza, deberá cerrar su sesión de R y abrir una nueva para comenzar a usar la versión actualizada del paquete.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Actualizando R y sus Paquetes</span>"
    ]
  },
  {
    "objectID": "a3-updating.html#paquetes-de-r",
    "href": "a3-updating.html#paquetes-de-r",
    "title": "Apéndice C — Actualizando R y sus Paquetes",
    "section": "",
    "text": "update.packages(c(\"ggplot2\", \"reshape2\", \"dplyr\"))",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Actualizando R y sus Paquetes</span>"
    ]
  },
  {
    "objectID": "a4-data.html",
    "href": "a4-data.html",
    "title": "Apéndice D — Cargar y Guardar Datos en R",
    "section": "",
    "text": "D.1 Conjuntos de Datos en R Base\nEste apéndice le mostrará cómo cargar y guardar datos en R desde archivos de texto sin formato, archivos de R y hojas de cálculo de Excel. También le mostrará los paquetes R que puede usar para cargar datos de bases de datos y otros programas comunes, como SAS y MATLAB.\nR viene con muchos conjuntos de datos precargados en el paquete datasets, que viene con la base de R. Estos conjuntos de datos no son muy interesantes, pero le brindan la oportunidad de probar el código o hacer un punto sin tener que cargar un conjunto de datos desde el exterior de R. Puede ver una lista de los conjuntos de datos de R, así como una breve descripción de cada uno, ejecutando:\nPara utilizar un conjunto de datos, simplemente escriba su nombre. Cada conjunto de datos ya está preguardado como un objeto R. Por ejemplo:\nSin embargo, los conjuntos de datos de R no reemplazan sus propios datos, que puede cargar en R desde una amplia variedad de formatos de archivo. Pero antes de cargar cualquier archivo de datos en R, deberá determinar dónde está su directorio de trabajo.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Cargar y Guardar Datos en R</span>"
    ]
  },
  {
    "objectID": "a4-data.html#conjuntos-de-datos-en-r-base",
    "href": "a4-data.html#conjuntos-de-datos-en-r-base",
    "title": "Apéndice D — Cargar y Guardar Datos en R",
    "section": "",
    "text": "help(package = \"datasets\")\n\niris\n##   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n## 1          5.1         3.5          1.4         0.2  setosa\n## 2          4.9         3.0          1.4         0.2  setosa\n## 3          4.7         3.2          1.3         0.2  setosa\n## 4          4.6         3.1          1.5         0.2  setosa\n## 5          5.0         3.6          1.4         0.2  setosa\n## 6          5.4         3.9          1.7         0.4  setosa",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Cargar y Guardar Datos en R</span>"
    ]
  },
  {
    "objectID": "a4-data.html#directorio-de-trabajo",
    "href": "a4-data.html#directorio-de-trabajo",
    "title": "Apéndice D — Cargar y Guardar Datos en R",
    "section": "D.2 Directorio de Trabajo",
    "text": "D.2 Directorio de Trabajo\nCada vez que abre R, se vincula a sí mismo a un directorio en su computadora, que R llama el directorio de trabajo. Aquí es donde R buscará los archivos cuando intente cargarlos, y es donde R guardará los archivos cuando los guarde. La ubicación de su directorio de trabajo variará en diferentes computadoras. Para determinar qué directorio está usando R como su directorio de trabajo, ejecute:\ngetwd()\n## \"/Users/garrettgrolemund\"\nPuede colocar archivos de datos directamente en la carpeta que es su directorio de trabajo, o puede mover su directorio de trabajo a donde están sus archivos de datos. Puede mover su directorio de trabajo a cualquier carpeta de su computadora con la función setwd. Simplemente proporcione a setwd la ruta del archivo a su nuevo directorio de trabajo. Prefiero configurar mi directorio de trabajo en una carpeta dedicada a cualquier proyecto en el que esté trabajando actualmente. De esa manera puedo mantener todos mis datos, secuencias de comandos, gráficos e informes en el mismo lugar. Por ejemplo:\nsetwd(\"~/Users/garrettgrolemund/Documents/Book_Project\")\nSi la ruta del archivo no comienza con su directorio raíz, R asumirá que comienza en su directorio de trabajo actual.\nTambién puede cambiar su directorio de trabajo haciendo clic en Session &gt; Set Working Directory &gt; Choose Directory en la barra de menu de RStudio. Las GUI de Windows y Mac tienen opciones similares. Si inicia R desde una línea de comandos de UNIX (como en las máquinas Linux), el directorio de trabajo será el directorio en el que se encontraba cuando llamó a R.\nPuede ver qué archivos hay en su directorio de trabajo con list.files(). Si ve el archivo que le gustaría abrir en su directorio de trabajo, entonces está listo para continuar. La forma en que abra los archivos en su directorio de trabajo dependerá del tipo de archivo que desee abrir.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Cargar y Guardar Datos en R</span>"
    ]
  },
  {
    "objectID": "a4-data.html#archivos-de-texto-sin-formato",
    "href": "a4-data.html#archivos-de-texto-sin-formato",
    "title": "Apéndice D — Cargar y Guardar Datos en R",
    "section": "D.3 Archivos de Texto Sin Formato",
    "text": "D.3 Archivos de Texto Sin Formato\nLos archivos de texto sin formato son una de las formas más comunes de guardar datos. Son muy simples y pueden ser leídos por muchos programas de computadora diferentes, incluso los editores de texto más básicos. Por esta razón, los datos públicos suelen presentarse como archivos de texto sin formato. Por ejemplo, la Oficina del Censo, la Administración del Seguro Social y la Oficina de Estadísticas Laborales ponen a disposición sus datos como archivos de texto sin formato.\nAsí es como el conjunto de datos de la escalera real de Objetos de R aparecería como un archivo de texto sin formato (he agregado una columna de valor):\n\"carta\", \"palo\", \"valor\"\n\"as\", \"picas\", 14\n\"rey\", \"picas\", 13\n\"reina\", \"picas\", 12\n\"jota\", \"picas\", 11\n\"diez\", \"picas\", 10\nUn archivo de texto sin formato almacena una tabla de datos en un documento de texto. Cada fila de la tabla se guarda en su propia línea y se usa una convención simple para separar las celdas dentro de una fila. A menudo, las celdas están separadas por una coma, pero también pueden estar separadas por una tabulación, un delimitador de barra vertical (es decir, | ) o cualquier otro carácter. Cada archivo solo utiliza un método de separación de celdas, lo que minimiza la confusión. Dentro de cada celda, los datos aparecen como esperarías verlos, como palabras y números.\nTodos los archivos de texto sin formato se pueden guardar con la extensión .txt (para texto), pero a veces un archivo recibirá una extensión especial que anuncia cómo separa las entradas de las celdas de datos. Dado que las entradas en el conjunto de datos mencionado anteriormente están separadas por una coma, este archivo sería un archivo de valores separados por comas y normalmente se guardaría con la extensión .csv.\n\nD.3.1 read.table\nPara cargar un archivo de texto sin formato, use read.table. El primer argumento de read.table debe ser el nombre de su archivo (si está en su directorio de trabajo), o la ruta del archivo a su archivo (si no está en su directorio de trabajo). Si la ruta del archivo no comienza con su directorio raíz, R lo agregará al final de la ruta del archivo que conduce a su directorio de trabajo. También puede darle a read.table otros argumentos. Los dos más importantes son sep y header.\nSi el conjunto de datos de la escalera real se guardó como un archivo llamado poquer.csv en su directorio de trabajo, podría cargarlo con:\npoquer &lt;- read.table(\"poquer.csv\", sep = \",\", header = TRUE)\n\nD.3.1.1 sep\nUse sep para decirle a read.table qué carácter usa su archivo para separar las entradas de datos. Para averiguarlo, es posible que deba abrir su archivo en un editor de texto y mirarlo. Si no especifica un argumento sep, read.table intentará separar las celdas siempre que haya espacios en blanco, como una pestaña o un espacio. R no podrá decirle si read.table hace esto correctamente o no, así que confíe en él bajo su propio riesgo.\n\n\nD.3.1.2 header\nUse header para decirle a read.table si la primera línea del archivo contiene nombres de variables en lugar de valores. Si la primera línea del archivo es un conjunto de nombres de variables, debe establecer header = TRUE.\n\n\nD.3.1.3 na.strings\nA menudo, los conjuntos de datos utilizan símbolos especiales para representar la información que falta. Si sabe que sus datos utilizan un determinado símbolo para representar las entradas que faltan, puede decirle a read.table (y a las funciones anteriores) cuál es el símbolo con el argumento na.strings. read.table convertirá todas las instancias del símbolo de información faltante en NA, que es el símbolo de información faltante de R (consulte Información faltante).\nPor ejemplo, su conjunto de datos de póquer contenía valores faltantes almacenados como ., como este:\n## \"carta\",\"palo\",\"valor\"\n## \"as\",\"picas\",\" 14\"\n## \"rey\",\"picas\",\" 13\"\n## \"reina\",\".\",\".\"\n## \"jota\",\".\",\".\"\n## \"diez\",\".\",\".\"\nPuede leer el conjunto de datos en R y convertir los valores faltantes en NA a medida que avanza con el comando:\npoquer &lt;- read.table(\"poquer.csv\", sep = \",\", header = TRUE, na.string = \".\")\nR guardaría una versión de poquer que se ve así:\n##  carta     palo  valor\n##     as    picas     14\n##    rey    picas     13\n##  reina     &lt;NA&gt;     NA\n##   jota     &lt;NA&gt;     NA\n##   diez     &lt;NA&gt;     NA\n\n\nD.3.1.4 skip and nrow\nA veces, un archivo de texto sin formato vendrá con un texto introductorio que no forma parte del conjunto de datos. O bien, puede decidir que solo desea leer una parte de un conjunto de datos. Puede hacer estas cosas con los argumentos skip y nrow. Use skip para decirle a R que salte un número específico de líneas antes de que comience a leer valores del archivo. Use nrow para decirle a R que deje de leer valores después de haber leído un cierto número de líneas.\nPor ejemplo, imagine que el archivo de escalera real completo se ve así:\nEstos datos fueron recopilados por el Instituto Nacional de Póquer.\nAccidentalmente repetimos la última fila de datos.\n\n\"cata\", \"palo\", \"valor\"\n\"as\", \"picas\", 14\n\"rey\", \"picas\", 13\n\"reina\", \"picas\", 12\n\"jota\", \"picas\", 11\n\"diez\", \"picas\", 10\n\"diez\", \"picas\", 10\nPuede leer solo las seis líneas que desee (cinco filas más un encabezado) con:\nread.table(\"poquer.csv\", sep = \",\", header = TRUE, skip = 3, nrow = 5)\n##    carta    palo  valor\n## 1     as   picas     14\n## 2    rey   picas     13\n## 3  reina   picas     12\n## 4   jota   picas     11\n## 5   diez   picas     10\nTenga en cuenta que la fila del encabezado no cuenta para el total de filas permitidas por nrow.\n\n\nD.3.1.5 stringsAsFactors\nR lee números tal como cabría esperar, pero cuando R encuentra cadenas de caracteres (por ejemplo, letras y palabras), comienza a actuar de manera extraña. R quiere convertir cada cadena de caracteres en un factor. Este es el comportamiento predeterminado de R, pero creo que es un error. A veces los factores son útiles. En otras ocasiones, son claramente el tipo de datos incorrecto para el trabajo. Además, los factores provocan un comportamiento extraño, especialmente cuando desea mostrar datos. Este comportamiento puede ser sorprendente si no se dio cuenta de que R convirtió sus datos en factores. En general, tendrá una experiencia R más fluida si no permite que R genere factores hasta que los solicite. Afortunadamente, es fácil hacer esto.\nEstablecer el argumento stringsAsFactors en FALSE asegurará que R guarde cualquier cadena de caracteres en su conjunto de datos como cadenas de caracteres, no como factores. Para usar stringsAsFactors, escribirías:\nread.table(\"poquer.csv\", sep = \",\", header = TRUE, stringsAsFactors = FALSE)\nSi va a cargar más de un archivo de datos, puede cambiar el comportamiento de factorización predeterminado a nivel global con:\noptions(stringsAsFactors = FALSE)\nEsto garantizará que todas las cadenas se lean como cadenas, no como factores, hasta que finalice su sesión de R o vuelva a cambiar el valor predeterminado global ejecutando:\noptions(stringsAsFactors = TRUE)\n\n\n\nD.3.2 La Familia read\nR también viene con algunos atajos preempaquetados para read.table, que se muestran en la Tabla Tabla D.1.\n\n\n\nTabla D.1: Funciones read de R. Puede sobrescribir cualquiera de los argumentos predeterminados según sea necesario.\n\n\n\n\n\n\n\n\n\n\nFunción\nPor Defecto\nUso\n\n\n\n\nread.table\nsep = ” “, header = FALSE\nFunción de lectura de uso general\n\n\nread.csv\nsep = “,”, header = TRUE\nArchivos de variables separadas por comas (CSV)\n\n\nread.delim\nsep = “, header = TRUE\nArchivos delimitados por tabuladores\n\n\nread.csv2\nsep = “;”, header = TRUE, dec = “,”\nArchivos CSV con formato decimal europeo\n\n\nread.delim2\nsep = “, header = TRUE, dec =”,”\nArchivos delimitados por tabuladores con formato decimal europeo\n\n\n\n\n\n\nEl primer atajo, read.csv, se comporta como read.table pero establece automáticamente sep = \",\" y header = TRUE, lo que puede ahorrarte algo de escritura:\npoquer &lt;- read.csv(\"poquer.csv\")\nread.delim establece automáticamente sep en el carácter de tabulación, lo cual es muy útil para leer archivos delimitados por tabulaciones. Estos son archivos donde cada celda está separada por una pestaña. read.delim también establece header = TRUE por defecto.\nread.delim2 y read.csv2 existen para los usuarios europeos de R. Estas funciones le dicen a R que los datos usan una coma en lugar de un punto para indicar lugares decimales. (Si se pregunta cómo funciona esto con los archivos CSV, los archivos CSV2 generalmente separan las celdas con un punto y coma, no con una coma).\n\n\n\n\n\n\nImport Dataset\nTambién puede cargar archivos de texto sin formato con el botón Importar conjunto de datos de RStudio, como se describe en Cargando Datos. Importar conjunto de datos proporciona una versión GUI de read.table.\n\n\n\n\n\nD.3.3 read.fwf\nUn tipo de archivo de texto sin formato desafía el patrón al utilizar su diseño para separar las celdas de datos. Cada fila se coloca en su propia línea (al igual que con otros archivos de texto sin formato), y luego cada columna comienza en un número específico de caracteres desde el lado izquierdo del documento. Para lograr esto, se agrega un número arbitrario de espacios de caracteres al final de cada entrada para ubicar correctamente la siguiente entrada. Estos documentos se conocen como archivos de ancho fijo y normalmente terminan con la extensión .fwf.\nEsta es una forma en que el conjunto de datos de la escalera real podría verse como un archivo de ancho fijo. En cada fila, la entrada del palo comienza exactamente 10 caracteres desde el inicio de la línea. No importa cuántos caracteres aparecieron en la primera celda de cada fila:\n\ncarta     palo       valor\nas        picas      14\nrey       picas      13  \nreina     picas      12  \njota      picas      11  \ndiez      picas      10\nLos archivos de ancho fijo se ven bien a los ojos humanos (pero no mejor que un archivo delimitado por tabulaciones); sin embargo, puede ser difícil trabajar con ellos. Quizás debido a esto, R viene con una función para leer archivos de ancho fijo, pero no para guardarlos. Desafortunadamente, a las agencias del gobierno de EE. UU. parece gustarles los archivos de ancho fijo, y es probable que encuentre uno o más durante su carrera.\nPuede leer archivos de ancho fijo en R con la función read.fwf. La función toma los mismos argumentos que read.table pero requiere un argumento adicional, widths, que debería ser un vector de números. Cada entrada i del vector widths debe indicar el ancho (en caracteres) de la columna i del conjunto de datos.\nSi los datos de escalera real de ancho fijo antes mencionados se guardaron como poquer.fwf en su directorio de trabajo, podría leerlos con:\npoquer &lt;- read.fwf(\"poquer.fwf\", widths = c(10, 7, 6), header = TRUE)\n\n\nD.3.4 Links HTML\nMuchos archivos de datos están disponibles en Internet en su propia dirección web. Si está conectado a Internet, puede abrir estos archivos directamente en R con read.table, read.csv, etc. Puede pasar una dirección web al argumento del nombre del archivo para cualquiera de las funciones de lectura de datos de R. . Como resultado, podría leer el conjunto de datos de póquer desde una dirección web como http://…/poquer.csv con:\npoquer &lt;- read.csv(\"http://.../poquer.csv\")\nObviamente, esa no es una dirección real, pero aquí hay algo que funcionaría, ¡si puede escribirlo!\nmazo &lt;- read.csv(\"https://gist.github.com/davidrsch/e59a71c228f5632634ebba08c7c7beaa/raw/mazo.csv\")\nSolo asegúrese de que la dirección web se vincule directamente al archivo y no a una página web que se vincule al archivo. Por lo general, cuando visita la dirección web de un archivo de datos, el archivo comenzará a descargarse o los datos sin procesar aparecerán en la ventana de su navegador.\nTenga en cuenta que los sitios web que comienzan con https:// son sitios web seguros, lo que significa que es posible que R no pueda acceder a los datos proporcionados en estos enlaces.\n\n\nD.3.5 Guardar Archivos de Texto Sin Formato\nUna vez que sus datos estén en R, puede guardarlos en cualquier formato de archivo compatible con R. Si desea guardarlo como un archivo de texto sin formato, puede utilizar la familia de funciones +write+. Las tres funciones básicas de write aparecen en Table Tabla D.2. Use write.csv para guardar sus datos como un archivo .csv y write.table para guardar sus datos como un documento delimitado por tabulaciones o un documento con separadores más exóticos.\n\n\n\nTabla D.2: R guarda conjuntos de datos en archivos de texto sin formato con la familia de funciones write.\n\n\n\n\n\n\n\n\n\nFormato de archivo\nFunción y sintaxis\n\n\n\n\n.csv\nwrite.csv(r_object, file = filepath, row.names = FALSE)\n\n\n.csv (con notación decimal europea)\nwrite.csv2(r_object, file = filepath, row.names = FALSE)\n\n\nDelimitado por tabulaciones\nwrite.table(r_object, file = filepath, sep = \"\\t\", row.names=FALSE)\n\n\n\n\n\n\nEl primer argumento de cada función es el objeto de R que contiene su conjunto de datos. El argumento file es el nombre del archivo (incluida la extensión) que desea dar a los datos guardados. De forma predeterminada, cada función guardará sus datos en su directorio de trabajo. Sin embargo, puede proporcionar una ruta de archivo al argumento del archivo. R lo complacerá guardando el archivo al final de la ruta del archivo. Si la ruta del archivo no comienza con su directorio raíz, R lo agregará al final de la ruta del archivo que conduce a su directorio de trabajo.\nPor ejemplo, puede guardar el data frame (hipotético) póquer en un subdirectorio llamado data dentro de su directorio de trabajo con el comando:\nwrite.csv(poquer, \"data/poquer.csv\", row.names = FALSE)\nTenga en cuenta que write.csv y write.table no pueden crear nuevos directorios en su computadora. Cada carpeta en la ruta del archivo debe existir antes de intentar guardar un archivo con ella.\nEl argumento row.names evita que R guarde los nombres de las filas del data frame como una columna en el archivo de texto sin formato. Es posible que haya notado que R nombra automáticamente cada fila en un data frame con un número. Por ejemplo, cada fila en nuestro data frame de póquer aparece con un número al lado:\npoquer\n##    carta  palo valor\n## 1     as picas    14\n## 2    rey picas    13\n## 3  reina picas    12\n## 4   jota picas    11\n## 5   diez picas    10\nEstos números de fila son útiles, pero pueden acumularse rápidamente si comienza a guardarlos. R agregará un nuevo conjunto de números de forma predeterminada cada vez que vuelva a leer el archivo. Evite esto configurando siempre row.names = FALSE cuando use una función de la familia write.\n\n\nD.3.6 Comprimiendo Archivos\nPara comprimir un archivo de texto sin formato, rodee el nombre del archivo o la ruta del archivo con la función bzfile, gzfile o xzfile. Por ejemplo:\nwrite.csv(poquer, file = bzfile(\"data/poquer.csv.bz2\"), row.names = FALSE)\nCada una de estas funciones comprimirá la salida con un tipo diferente de formato de compresión, que se muestra en la Tabla Tabla D.3.\n\n\n\nTabla D.3: R viene con tres funciones auxiliares para comprimir archivos\n\n\n\n\n\nFunción\nTipo de compresión\n\n\n\n\nbzfile\nbzip2\n\n\ngzfile\ngnu zip (gzip)\n\n\nxzfile\ncompresión xz\n\n\n\n\n\n\nEs una buena idea ajustar la extensión de su archivo para reflejar la compresión. Las funciones `read`` de R abrirán archivos de texto sin formato comprimidos en cualquiera de estos formatos. Por ejemplo, podría leer un archivo comprimido llamado poquer.csv.bz2 con:\nread.csv(\"poquer.csv.bz2\")\no:\nread.csv(\"data/poquer.csv.bz2\")\ndependiendo de dónde se encuentre el archivo.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Cargar y Guardar Datos en R</span>"
    ]
  },
  {
    "objectID": "a4-data.html#archivos-de-r",
    "href": "a4-data.html#archivos-de-r",
    "title": "Apéndice D — Cargar y Guardar Datos en R",
    "section": "D.4 Archivos de R",
    "text": "D.4 Archivos de R\nR proporciona dos formatos de archivo propios para almacenar datos, .RDS y .RData. Los archivos RDS pueden almacenar un único objeto R y los archivos RData pueden almacenar varios objetos R.\nPuede abrir un archivo RDS con readRDS. Por ejemplo, si los datos de la escalera real se guardaron como poquer.RDS, podría abrirlos con:\npoquer &lt;- readRDS(\"poquer.RDS\")\nAbrir archivos RData es aún más fácil. Simplemente ejecute la función load con el archivo:\nload(\"archivo.RData\")\nNo hay necesidad de asignar la salida a un objeto. Los objetos de R en su archivo RData se cargarán en su sesión de R con sus nombres originales. Los archivos RData pueden contener varios objetos de R, por lo que cargar uno puede leer varios objetos. load no le dice cuántos objetos está leyendo, ni cuáles son sus nombres, por lo que vale la pena saber un poco sobre el archivo RData antes de cargarlo.\nEn el peor de los casos, puede vigilar el panel de environment en RStudio mientras carga un archivo RData. Muestra todos los objetos que ha creado o cargado durante su sesión de R. Otro truco útil es poner paréntesis alrededor de tu comando de carga como (load(\"poquer.RData\")). Esto hará que R imprima los nombres de cada objeto que carga desde el archivo.\nTanto readRDS como load toman una ruta de archivo como su primer argumento, al igual que las otras funciones de lectura y escritura de R. Si su archivo está en su directorio de trabajo, la ruta del archivo será el nombre del archivo.\n\nD.4.1 Guardar archivos de R\nPuede guardar un objeto de R como un data frame como un archivo RData o un archivo RDS. Los archivos RData pueden almacenar varios objetos de R a la vez, pero los archivos RDS son la mejor opción porque fomentan el código reproducible.\nPara guardar datos como un objeto RData, utilice la función save. Para guardar datos como un objeto RDS, use la función saveRDS. En cada caso, el primer argumento debe ser el nombre del objeto de R que desea guardar. Luego debe incluir un argumento de archivo que tenga el nombre del archivo o la ruta del archivo en el que desea guardar el conjunto de datos.\nPor ejemplo, si tiene tres objetos R, a, b y c, puede guardarlos todos en el mismo archivo RData y luego volver a cargarlos en otra sesión de R:\na &lt;- 1\nb &lt;- 2\nc &lt;- 3\nsave(a, b, c, file = \"objetos.RData\")\nload(\"objetos.RData\")\nSin embargo, si olvida los nombres de sus objetos o le da su archivo a otra persona para que lo use, será difícil determinar qué había en el archivo, incluso después de que usted (o ellos) lo carguen. La interfaz de usuario para archivos RDS es mucho más clara. Puede guardar solo un objeto por archivo, y quien lo cargue puede decidir cómo quiere llamar a sus nuevos datos. Como beneficio adicional, no tiene que preocuparse de que load sobrescriba cualquier objeto de R que tenga el mismo nombre que los objetos que está cargando:\nsaveRDS(a, file = \"objeto.RDS\") \na &lt;- readRDS(\"objeto.RDS\")\nGuardar sus datos como un archivo R ofrece algunas ventajas sobre guardar sus datos como un archivo de texto sin formato. R comprime automáticamente el archivo y también guardará los metadatos relacionados con R asociados con su objeto. Esto puede ser útil si sus datos contienen factores, fechas y horas o atributos de clase. No tendrá que volver a analizar esta información en R como lo haría si convirtiera todo en un archivo de texto.\nPor otro lado, muchos otros programas no pueden leer los archivos de R, lo que los hace ineficientes para compartir. También pueden crear un problema para el almacenamiento a largo plazo si no cree que tendrá una copia de R cuando vuelva a abrir los archivos.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Cargar y Guardar Datos en R</span>"
    ]
  },
  {
    "objectID": "a4-data.html#hojas-de-cálculo-de-excel",
    "href": "a4-data.html#hojas-de-cálculo-de-excel",
    "title": "Apéndice D — Cargar y Guardar Datos en R",
    "section": "D.5 Hojas de Cálculo de Excel",
    "text": "D.5 Hojas de Cálculo de Excel\nMicrosoft Excel es un popular programa de hoja de cálculo que se ha convertido casi en el estándar de la industria en el mundo de los negocios. Es muy probable que necesite trabajar con una hoja de cálculo de Excel en R al menos una vez en su carrera. Puede leer hojas de cálculo en R y también guardar datos de R como una hoja de cálculo de varias maneras.\n\nD.5.1 Exportar desde Excel\nEl mejor método para mover datos de Excel a R es exportar la hoja de cálculo de Excel como un archivo .csv o .txt. R no solo podrá leer el archivo de texto, también lo hará cualquier otro software de análisis de datos. Los archivos de texto son la lengua franca del almacenamiento de datos.\nExportar los datos también resuelve otra dificultad. Excel usa formatos y metadatos patentados que no se transferirán fácilmente a R. Por ejemplo, un solo archivo de Excel puede incluir varias hojas de cálculo, cada una con sus propias columnas y macros. Cuando Excel exporta el archivo como .csv o .txt, se asegura de que este formato se transfiera a un archivo de texto sin formato de la forma más adecuada. Es posible que R no pueda administrar la conversión de manera tan eficiente.\nPara exportar datos desde Excel, abra la hoja de cálculo de Excel y luego vaya a Guardar como. Luego elija CSV en el cuadro Guardar como tipo que aparece y guarde los archivos. Luego puede leer el archivo en R con la función read.csv.\n\n\nD.5.2 Copiar y pegar\nTambién puede copiar partes de una hoja de cálculo de Excel y pegarlas en R. Para hacer esto, abra la hoja de cálculo y seleccione las celdas que desea leer en R. Luego seleccione Editar &gt; Copiar en la barra de menú, o use un atajo de teclado, para copia las celdas a tu portapapeles.\nEn la mayoría de los sistemas operativos, puede leer los datos almacenados en su portapapeles en R con:\nread.table(\"clipboard\")\nEn Mac necesitarás usar:\nread.table(pipe(\"pbpaste\"))\nSi las celdas contienen valores con espacios en ellos, esto interrumpirá read.table. Puede probar otra función `read`` (o simplemente exportar formalmente los datos de Excel) antes de leerlos en R.\n\n\nD.5.3 XLConnect\nSe han escrito muchos paquetes para ayudarlo a leer archivos de Excel directamente en R. Desafortunadamente, muchos de estos paquetes no funcionan en todos los sistemas operativos. Otros se han vuelto obsoletos debido al formato de archivo .xlsx. Un paquete que funciona en todos los sistemas de archivos (y recibe buenas críticas) es el paquete XLConnect. Para usarlo, deberá instalar y cargar el paquete:\ninstall.packages(\"XLConnect\")\nlibrary(XLConnect)\nXLConnect se basa en Java para ser independiente de la plataforma. Entonces, cuando abra XLConnect por primera vez, RStudio puede solicitarle que descargue un Java Runtime Environment si aún no tiene uno.\n\n\nD.5.4 Lectura de Hojas de Cálculo\nPuede usar XLConnect para leer en una hoja de cálculo de Excel con un proceso de uno o dos pasos. Comenzaré con el proceso de dos pasos. Primero, cargue un libro de trabajo de Excel con loadWorkbook. loadWorkbook puede cargar archivos .xls y .xlsx. Toma un argumento: la ruta del archivo a su libro de Excel (este será el nombre del libro de trabajo si está guardado en su directorio de trabajo):\nlt &lt;- loadWorkbook(\"archivo.xlsx\")\nA continuación, lea una hoja de cálculo del libro de trabajo con readWorksheet, que toma varios argumentos. El primer argumento debe ser un objeto de libro de trabajo creado con loadWorkbook. El siguiente argumento, sheet, debe ser el nombre de la hoja de cálculo en el libro de trabajo que le gustaría leer en R. Este será el nombre que aparece en la pestaña inferior de la hoja de cálculo. También puede darle a sheet un número, que especifica la hoja en la que desea leer (uno para la primera hoja, dos para la segunda, y así sucesivamente).\nreadWorksheet luego toma cuatro argumentos que especifican un cuadro delimitador de celdas para leer: startRow, startCol, endRow y endCol. Use startRow y startCol para describir la celda en la esquina superior izquierda del cuadro delimitador de celdas que desea leer. Use endRow y endCol para especificar la celda en la esquina inferior derecha de el cuadro delimitador. Cada uno de estos argumentos toma un número. Si no proporciona argumentos delimitadores, readWorksheet leerá en la región rectangular de celdas en la hoja de cálculo que parece contener datos. readWorksheet supondrá que esta región contiene una fila de encabezado, pero puede decir lo contrario con header = FALSE.\nEntonces, para leer en la primera hoja de trabajo de lt, podría usar:\nhoja1 &lt;- readWorksheet(lt, sheet = 1, startRow = 0, startCol = 0, \n  endRow = 100, endCol = 3)\nR guardará la salida como un data frame. Todos los argumentos en readWorkbook excepto el primero están vectorizados, por lo que puede usarlo para leer varias hojas del mismo libro de trabajo a la vez (o varias regiones de celdas de una sola hoja de trabajo). En este caso, readWorksheet devolverá una lista de data frames.\nPuede combinar estos dos pasos con readWorksheetFromFile. Toma el argumento del archivo de loadWorkbook y lo combina con los argumentos de readWorksheet. Puede usarlo para leer una o más hojas directamente desde un archivo de Excel:\nhoja1 &lt;- readWorksheetFromFile(\"archivo.xlsx\", sheet = 1, startRow = 0, \n  startCol = 0, endRow = 100, endCol = 3)\n\n\nD.5.5 Escribir Hojas de Cálculo\nEscribir en una hoja de cálculo de Excel es un proceso de cuatro pasos. Primero, debe configurar un objeto de libro de trabajo con loadWorkbook. Esto funciona igual que antes, excepto que si no está utilizando un archivo de Excel existente, debe agregar el argumento create = TRUE. XLConnect creará un libro de trabajo en blanco. Cuando lo guarde, XLConnect lo escribirá en la ubicación del archivo que especificó aquí con loadWorkbook:\nlt &lt;- loadWorkbook(\"archivo.xlsx\", create = TRUE)\nA continuación, debe crear una hoja de trabajo dentro de su objeto de libro de trabajo con createSheet. Dile a createSheet en qué libro colocar la hoja y cuál usar para la hoja.\ncreateSheet(lt, \"Hoja 1\")\nLuego puede guardar su data frame o matriz en la hoja con writeWorksheet. El primer argumento de writeWorksheet, object, es el libro de trabajo para escribir los datos. El segundo argumento, data, son los datos a escribir. El tercer argumento, sheet, es el nombre de la hoja en la que escribirlo. Los siguientes dos argumentos, startRow y startCol, le indican a R en qué parte de la hoja de cálculo colocar la celda superior izquierda de los nuevos datos. Cada uno de estos argumentos tiene un valor predeterminado de 1. Finalmente, puede usar header para decirle a R si los nombres de sus columnas deben escribirse con los datos:\nwriteWorksheet(lt, data = poquer, sheet = \"Hoja 1\")\nUna vez que haya terminado de agregar hojas y datos a su libro de trabajo, puede guardarlo ejecutando saveWorkbook en el objeto del libro de trabajo. R guardará el libro de trabajo con el nombre de archivo o la ruta que proporcionó en loadWorkbook. Si esto conduce a un archivo de Excel existente, R lo sobrescribirá. Si conduce a un nuevo archivo, R lo creará.\nTambién puede colapsar estos pasos en una sola llamada con writeWorksheetToFile, así:\nwriteWorksheetToFile(\"archivo.xlsx\", data = poquer, sheet = \"Hoja 1\", \n  startRow = 1, startCol = 1)\nEl paquete XLConnect también le permite hacer cosas más avanzadas con las hojas de cálculo de Excel, como escribir en una región con nombre en una hoja de cálculo, trabajar con fórmulas y asignar estilos a las celdas. Puede leer acerca de estas funciones en la viñeta de XLConnect, a la que se puede acceder cargando XLConnect y luego ejecutando:\nvignette(\"XLConnect\")",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Cargar y Guardar Datos en R</span>"
    ]
  },
  {
    "objectID": "a4-data.html#cargar-archivos-desde-otros-programas",
    "href": "a4-data.html#cargar-archivos-desde-otros-programas",
    "title": "Apéndice D — Cargar y Guardar Datos en R",
    "section": "D.6 Cargar Archivos desde Otros Programas",
    "text": "D.6 Cargar Archivos desde Otros Programas\nDebe seguir el mismo consejo que le di para los archivos de Excel siempre que desee trabajar con formatos de archivo nativos de otros programas: abra el archivo en el programa original y exporte los datos como un archivo de texto sin formato, generalmente un CSV. Esto garantizará la transcripción más fiel de los datos en el archivo y, por lo general, le brindará la mayor cantidad de opciones para personalizar la forma en que se transcriben los datos.\nA veces, sin embargo, puede adquirir un archivo pero no el programa del que procede. Como resultado, no podrá abrir el archivo en su programa nativo y exportarlo como un archivo de texto. En este caso, puede usar una de las funciones en Tabla Tabla D.4 para abrir el archivo. La mayoría de estas funciones vienen en el paquete foreign de R. Cada uno intenta leer en un formato de archivo diferente con la menor cantidad de contratiempos posible.\n\n\n\nTabla D.4: Varias funciones intentarán leer los tipos de archivo de otros programas de análisis de datos\n\n\n\n\n\nFormato de archivo\nFunción\nPaquete\n\n\n\n\nERSI ArcGIS\nread.shapefile\nshapefiles\n\n\nMatlab\nreadMat\nR.matlab\n\n\nminitab\nread.mtp\nforeign\n\n\nSAS (conjunto de datos permanente)\nread.ssd\nforeign\n\n\nSAS (formato XPORT)\nread.xport\nforeign\n\n\nSPSS\nread.spss\nforeign\n\n\nStata\nread.dta\nforeign\n\n\nSystat\nread.systat\nforeign\n\n\n\n\n\n\n\nD.6.1 Conexión a bases de datos\nTambién puede usar R para conectarse a una base de datos y leer datos.\nUtilice el paquete RODBC para conectarse a bases de datos a través de una conexión ODBC.\nUtilice el paquete DBI para conectarse a bases de datos a través de controladores individuales. El paquete DBI proporciona una sintaxis común para trabajar con diferentes bases de datos. Tendrá que descargar un paquete específico de base de datos para usarlo junto con DBI. Estos paquetes proporcionan la API para los controladores nativos de diferentes programas de bases de datos. Para MySQL use RMySQL, para SQLite use RSQLite, para Oracle use ROracle, para PostgreSQL use RPostgreSQL y para las bases de datos que usan controladores basados en la API Java Database Connectivity (JDBC) use RJDBC. Una vez que haya cargado el paquete de controladores adecuado, puede utilizar los comandos proporcionados por DBI para acceder a su base de datos.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Cargar y Guardar Datos en R</span>"
    ]
  },
  {
    "objectID": "a4-data.html#actualización",
    "href": "a4-data.html#actualización",
    "title": "Apéndice D — Cargar y Guardar Datos en R",
    "section": "D.7 Actualización",
    "text": "D.7 Actualización\nEn versiones modernas de RStudio es simple cargar archivos de Excel, SPSS, SAS y Stata usando el asistente de importación de RStudio. Para poder accerder a estas opciones se debe instalar el paquete readxl para los archivos de Excel y el paquete haven para el resto. Para realizar la operación es tan simple como dar click en el botón Import Dataset &gt; “Opción desead”(“From Excel”, “From SPSS”, “From SAS” o “From Stata”). Esto abrirá el asistente de importación de RStudio que permite visualizar el archivo a importar.\nCon el uso de los paquetes xlsx y haven se facilita también la forma de escribir y exportar archivos con dichas extenciones como se ve en la Tabla Tabla D.5.\n\n\n\nTabla D.5: Varias funciones para escribir y guardar archivos en distintos formatos\n\n\n\n\n\nFormato de archivo\nFunción\nPaquete\n\n\n\n\nExcel\nxlsx\nshapefiles\n\n\nSPSS\nwrite_sav\nhaven\n\n\nSAS (conjunto de datos permanente)\nwrite_sas\nhaven\n\n\nSAS (formato XPORT)\nwrite_xpt\nhaven\n\n\nStata\nwrite_dta\nhaven",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Cargar y Guardar Datos en R</span>"
    ]
  },
  {
    "objectID": "a5-debug.html",
    "href": "a5-debug.html",
    "title": "Apéndice E — Depuración de Código de R",
    "section": "",
    "text": "E.1 traceback\nR viene con un conjunto simple de herramientas de depuración que amplifica RStudio. Puede usar estas herramientas para comprender mejor el código que produce un error o devuelve un resultado inesperado. Por lo general, este será su propio código, pero también puede examinar las funciones en R o uno de sus paquetes.\nLa depuración de código puede requerir tanta creatividad y perspicacia como la escritura de código. No hay garantía de que encuentre un error o pueda solucionarlo cuando lo haga. Sin embargo, puede ayudarse usando las herramientas de depuración de R. Estas incluyen las funciones traceback, browser, debug, debugonce, trace y recover.\nEl uso de estas herramientas suele ser un proceso de dos pasos. Primero, localiza dónde ocurrió un error. Luego intenta determinar por qué ocurrió. Puede hacer el primer paso con la función traceback de R.\nLa herramienta traceback señala la ubicación de un error. Muchas funciones de R llaman a otras funciones de R, que llaman a otras funciones, y así sucesivamente. Cuando ocurre un error, es posible que no esté claro cuál de estas funciones salió mal. Consideremos un ejemplo. Las siguientes funciones se llaman entre sí, y la última función crea un error (verá por qué en un segundo):\nCuando ejecuta primera, llamará a segunda, que llamará a tercera, que llamará a cuarta, que llamará a quinta, que llamará a error, una función que no existe. Así es como se verá en la línea de comando:\nEl informe de error nos dice que el error ocurrió cuando R intentó ejecutar quinta. También nos dice la naturaleza del error (no existe una función llamada error). Aquí, es obvio por qué R llama a quinta, pero podría no ser tan obvio por qué R llama a una función cuando ocurre un error en la naturaleza.\nPuede ver la ruta de las funciones que R llamó antes de que se produjera un error escribiendo traceback() en la línea de comando. traceback devolverá una pila de llamadas, una lista de las funciones que R llamó en el orden en que las llamó. La función inferior será el comando que ingresó en la línea de comando. La función superior será la función que causó el error:\ntraceback siempre se referirá al último error que encontró. Si desea ver un error menos reciente, deberá volver a crearlo antes de ejecutar traceback.\n¿Cómo puede ayudarte esto? Primero, traceback devuelve una lista de sospechosos. Una de estas funciones causó el error, y cada función es más sospechosa que las que están debajo. Lo más probable es que nuestro error provenga de quinta (lo hizo), pero también es posible que una función anterior haya hecho algo extraño, como llamar a quinta cuando no debería haberlo hecho.\nEn segundo lugar, traceback puede mostrarle si R se salió del camino que esperaba que tomara. Si esto sucedió, mire la última función antes de que las cosas salieran mal.\nEn tercer lugar, traceback puede revelar el alarmante alcance de los infinitos errores de recurrencia. Por ejemplo, si cambia quinta para que llame a segunda, las funciones harán un bucle: segunda llamará a tercera, que llamará a cuarta, que llamará a quinta, que llamará a segunda y comienza el bucle de nuevo. Es más fácil hacer este tipo de cosas en la práctica de lo que piensas:\nCuando llamas a primera(), R comenzará a ejecutar las funciones. Después de un tiempo, notará que se está repitiendo y devolverá un error. traceback mostrará exactamente lo que estaba haciendo R:\nObserve que hay 5.000 líneas de salida en este traceback. Si está utilizando RStudio, no podrá ver el seguimiento de un error de recursión infinita (utilicé la GUI de Mac para obtener este resultado). RStudio reprime el rastreo de errores de recurrencia infinitos para evitar que las grandes pilas de llamadas saquen el historial de su consola del búfer de memoria de R. Con RStudio, deberá reconocer el error de recurrencia infinita por su mensaje de error. Sin embargo, aún puede ver el imponente traceback al ejecutar las cosas en un shell de UNIX o en las GUI de Windows o Mac.\nRStudio hace que sea muy fácil usar traceback. Ni siquiera necesita escribir el nombre de la función. Siempre que ocurra un error, RStudio lo mostrará en un cuadro gris con dos opciones. El primero es Show Traceback, que se muestra en la Figura Figura E.1.\nFigura E.1: Opción de Show Traceback de RStudio.\nSi hace clic en Show Traceback, RStudio expandirá el cuadro gris y mostrará la pila de llamadas traceback, como en la figura Figura E.2. La opción Show Traceback persistirá junto a un mensaje de error en su consola, incluso mientras escribe nuevos comandos. Esto significa que puede volver atrás y buscar en las pilas de llamadas todos los errores, no solo el error más reciente.\nImagina que has usado traceback para identificar una función que crees que podría causar un error. Ahora, ¿qué debes hacer? Debe intentar averiguar qué hizo la función para causar un error mientras se ejecutaba (si es que hizo algo). Puede examinar cómo se ejecuta la función con browser.\nFigura E.2: Pantalla de traceback de RStudio.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>Depuración de Código de R</span>"
    ]
  },
  {
    "objectID": "a5-debug.html#traceback",
    "href": "a5-debug.html#traceback",
    "title": "Apéndice E — Depuración de Código de R",
    "section": "",
    "text": "primera &lt;- function() segunda()\nsegunda &lt;- function() tercera()\ntercera &lt;- function() cuarta()\ncuarta &lt;- function() quinta()\nquinta &lt;- function() error()\n\nprimera()\n##  Error in quinta() : could not find function \"error\" \n\n\ntraceback()\n## 5: quinta() at #1\n## 4: cuarta() at #1\n## 3: tercera() at #1\n## 2: segunda() at #1\n## 1: primera()\n\n\n\n\nquinta &lt;- function() segunda()\n\nprimera()\n## Error: evaluation nested too deeply: infinite recursion/options(expressions=)?\n\ntraceback()\n## 5000: cuarta() at #1\n## 4999: tercera() at #1\n## 4998: segunda() at #1\n## 4997: quinta() at #1\n## 4996: cuarta() at #1\n## 4995: tercera() at #1\n## 4994: segunda() at #1\n## 4993: quinta() at #1\n## ...",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>Depuración de Código de R</span>"
    ]
  },
  {
    "objectID": "a5-debug.html#browser",
    "href": "a5-debug.html#browser",
    "title": "Apéndice E — Depuración de Código de R",
    "section": "\nE.2 browser",
    "text": "E.2 browser\nPuede pedirle a R que haga una pausa en medio de la ejecución de una función y le devuelva el control con browser. Esto le permitirá ingresar nuevos comandos en la línea de comandos. El entorno activo para estos comandos no será el entorno global (como es habitual); será el entorno de tiempo de ejecución de la función que ha pausado. Como resultado, puede ver los objetos que usa la función, buscar sus valores con las mismas reglas de alcance que usaría la función y ejecutar el código en las mismas condiciones en las que lo haría la función. Esta disposición proporciona la mejor oportunidad para detectar la fuente de errores en una función.\nPara usar browser, agregue la llamada browser() al cuerpo de una función y luego vuelva a guardar la función. Por ejemplo, si quisiera hacer una pausa en medio de la función puntuacion de Programas, podría agregar browser() al cuerpo de puntuacion y luego volver a ejecutar el siguiente código, que define puntuacion:\npuntuacion &lt;- function(simbolos) {\n  # identificar caso\n  iguales &lt;- simbolos[1] == simbolos[2] && simbolos[2] == simbolos[3]\n  barras &lt;- simbolos %in% c(\"B\", \"BB\", \"BBB\")\n  \n  # obtener premio\n  if (iguales) {\n    pagos &lt;- c(\"DD\" = 100, \"7\" = 80, \"BBB\" = 40, \"BB\" = 25, \n      \"B\" = 10, \"C\" = 10, \"0\" = 0)\n    premio &lt;- unname(pagos[simbolos[1]])\n  } else if (all(barras)) {\n    premio &lt;- 5\n  } else {\n    cerezas &lt;- sum(simbolos == \"C\")\n    premio &lt;- c(0, 2, 5)[cerezas + 1]\n  }\n  \n  browser()\n\n  # ajustar para diamantes\n  diamantes &lt;- sum(simbolos == \"DD\")\n  premio * 2 ^ diamantes\n}\nAhora, siempre que R ejecute puntuacion, llegará a la llamada browser(). Puede ver esto con la función play de Programas y S3. Si no tiene play a mano, puede acceder ejecutando este código:\nobt_simbolos &lt;- function() {\n  rueda &lt;- c(\"DD\", \"7\", \"BBB\", \"BB\", \"B\", \"C\", \"0\")\n  sample(rueda, size = 3, replace = TRUE, \n    prob = c(0.03, 0.03, 0.06, 0.1, 0.25, 0.01, 0.52))\n}\n\nplay &lt;- function() {\n  simbolos &lt;- obt_simbolos()\n  structure(puntuacion(simbolos), simbolos = simbolos, class = \"tragamonedas\")\n}\nCuando ejecutas play, play llamará a obt_simbolos y luego a puntuacion. A medida que R trabaja a través de puntuacion, encontrará la llamada a browser y la ejecutará. Cuando R ejecuta esta llamada, sucederán varias cosas, como en la Figura Figura E.3. Primero, R dejará de ejecutar puntuacion. En segundo lugar, el símbolo del sistema cambiará a browser[1]&gt; y R me devolverá el control; Ahora puedo escribir nuevos comandos en el nuevo símbolo del sistema. En tercer lugar, aparecerán tres botones sobre el panel de la consola: Next, Continue y Stop. En cuarto lugar, RStudio mostrará el código fuente de puntuacion en el panel de secuencias de comandos y resaltará la línea que contiene browser(). Quinto, la pestaña de entornos cambiará. En lugar de revelar los objetos que se guardan en el entorno global, revelará los objetos que se guardan en el entorno de tiempo de ejecución de puntuacion (consulte Entornos para obtener una explicación del sistema de entorno de R). En sexto lugar, RStudio abrirá un nuevo panel de seguimiento, que muestra la pila de llamadas que tomó RStudio para llegar al browser. Se resaltará la función más reciente, puntuacion.\nAhora estoy en un nuevo modo de R, llamado modo navegador. El modo de navegador está diseñado para ayudarlo a descubrir errores, y la nueva pantalla en RStudio está diseñada para ayudarlo a navegar en este modo.\nCualquier comando que ejecute en modo navegador se evaluará en el contexto del entorno de tiempo de ejecución de la función que llamó browser. Esta será la función que se resaltará en el nuevo panel Rastreo. Aquí, esa función es puntuacion. Entonces, mientras estamos en modo navegador, el entorno activo será el entorno de tiempo de ejecución de puntuacion. Esto le permite hacer dos cosas.\n\n\n\n\n\n\n\nFigura E.3: RStudio actualiza su pantalla cada vez que ingresa al modo de navegador para ayudarlo a navegar por el modo.\n\n\n\n\nPrimero, puedes inspeccionar los objetos que usa puntuacion. El panel Entornos actualizado le muestra qué objetos puntuacion ha guardado en su entorno local. Puede inspeccionar cualquiera de ellos escribiendo su nombre en el indicador del navegador. Esto le brinda una manera de ver los valores de las variables de tiempo de ejecución a las que normalmente no podría acceder. Si un valor parece claramente incorrecto, es posible que esté cerca de encontrar un error:\nBrowse[1]&gt; simbolos\n## [1] \"B\" \"B\" \"0\"\n\nBrowse[1]&gt; iguales\n## [1] FALSE\nEn segundo lugar, puede ejecutar el código y ver los mismos resultados que vería puntuacion. Por ejemplo, puede ejecutar las líneas restantes de la función puntuacion y ver si hacen algo inusual. Puede ejecutar estas líneas escribiéndolas en la línea de comandos, o puede usar los tres botones de navegación que ahora aparecen encima de la línea de comandos, como en la Figura Figura E.4.\nEl primer botón, Next, ejecutará la siguiente línea de código en puntuacion. La línea resaltada en el panel de secuencias de comandos avanzará una línea para mostrarle su nueva ubicación en la función puntuacion. Si la siguiente línea comienza con un fragmento de código, como un bucle for o un árbol if, R ejecutará el fragmento completo y lo resaltará en la ventana del script.\nEl segundo botón, Continue, ejecutará todas las líneas restantes de puntuacion y luego saldrá del modo de navegador.\nEl tercer botón, Stop, saldrá del modo navegador sin ejecutar más líneas de puntuacion.\n\n\n\n\n\n\n\nFigura E.4: Puede navegar en modo navegador con los tres botones en la parte superior del panel de la consola.\n\n\n\n\nPuede hacer lo mismo escribiendo los comandos n, c y Q en el indicador del navegador. Esto crea una molestia: ¿qué sucede si desea buscar un objeto llamado n, c o Q? Escribir el nombre del objeto no funcionará, R avanzará, continuará o saldrá del modo de navegador. En su lugar, tendrá que buscar estos objetos con los comandos get(\"n\"), get(\"c\") y get(\"Q\"). cont es un sinónimo de c en modo navegador y where imprime la pila de llamadas, por lo que también tendrá que buscar estos objetos con get.\nEl modo de navegador puede ayudarlo a ver las cosas desde la perspectiva de sus funciones, pero no puede mostrarle dónde está el error. Sin embargo, el modo de navegador puede ayudarlo a probar hipótesis e investigar el comportamiento de la función. Esto suele ser todo lo que necesita para detectar y corregir un error. El modo de navegador es la herramienta de depuración básica de R. Cada una de las siguientes funciones solo proporciona una forma alternativa de ingresar al modo de navegador.\nUna vez que solucione el error, debe volver a guardar su función por tercera vez, esta vez sin la llamada browser(). Siempre que la llamada del navegador esté allí, R se detendrá cada vez que usted, u otra función, llame a puntuacion.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>Depuración de Código de R</span>"
    ]
  },
  {
    "objectID": "a5-debug.html#puntos-de-ruptura",
    "href": "a5-debug.html#puntos-de-ruptura",
    "title": "Apéndice E — Depuración de Código de R",
    "section": "\nE.3 Puntos de Ruptura",
    "text": "E.3 Puntos de Ruptura\nLos puntos de ruptura de RStudio proporcionan una forma gráfica de agregar una declaración de browser a una función. Para usarlos, abra el script donde ha definido una función. Luego haga clic a la izquierda del número de línea de la línea de código en el cuerpo de la función donde le gustaría agregar la declaración de browser. Aparecerá un punto rojo hueco para mostrarle dónde se producirá el punto de ruptura. Luego ejecute el script haciendo clic en el botón Source en la parte superior del panel de Scripts. El punto hueco se convertirá en un punto rojo sólido para mostrar que la función tiene un punto de ruptura (vea la Figura Figura E.5).\nR tratará el punto de interrupción como una declaración de browser, entrando en modo navegador cuando lo encuentre. Puede eliminar un punto de ruptura haciendo clic en el punto rojo. El punto desaparecerá y el punto de ruptura se eliminará.\n\n\n\n\n\n\n\nFigura E.5: Los puntos de ruptura proporcionan el equivalente gráfico de una declaración de browser.\n\n\n\n\nLos puntos de ruptura y el browser brindan una excelente manera de depurar las funciones que ha definido. Pero, ¿qué sucede si desea depurar una función que ya existe en R? Puedes hacerlo con la función debug.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>Depuración de Código de R</span>"
    ]
  },
  {
    "objectID": "a5-debug.html#debug",
    "href": "a5-debug.html#debug",
    "title": "Apéndice E — Depuración de Código de R",
    "section": "\nE.4 debug",
    "text": "E.4 debug\nPuede “agregar” una llamada del navegador al comienzo de una función preexistente con debug. Para hacer esto, ejecute debug en la función. Por ejemplo, puede ejecutar debug en sample con:\ndebug(sample)\nDespués, R actuará como si hubiera una instrucción browser() en la primera línea de la función. Cada vez que R ejecute la función, ingresará inmediatamente al modo de navegador, lo que le permitirá recorrer la función una línea a la vez. R continuará comportándose de esta manera hasta que “elimine” la declaración del navegador con undebug:\nundebug(sample)\nPuede verificar si una función está en modo de “depuración” con isdebugged. Esto devolverá TRUE si ejecutó debug en la función pero aún no ha ejecutado undebug:\nisdebugged(sample)\n## FALSE\nSi todo esto es demasiado complicado, puede hacer lo que yo hago y usar debugonce en lugar de debug. R ingresará al modo de navegador la próxima vez que ejecute la función, pero automáticamente eliminará la depuración de la función después. Si necesita volver a navegar por la función, puede ejecutar debugonce en ella por segunda vez.\nPuede recrear debugonce en RStudio siempre que ocurra un error. Aparecerá “Reejecutar con depuración” en el cuadro de error gris debajo de Show Traceback (Figura Figura E.1). Si hace clic en esta opción, RStudio volverá a ejecutar el comando como si primero hubiera ejecutado debugonce en él. R entrará inmediatamente en el modo de navegador, lo que le permitirá recorrer el código. El comportamiento del navegador solo ocurrirá en esta ejecución del código. No necesita preocuparse por llamar a undebug cuando haya terminado.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>Depuración de Código de R</span>"
    ]
  },
  {
    "objectID": "a5-debug.html#trace",
    "href": "a5-debug.html#trace",
    "title": "Apéndice E — Depuración de Código de R",
    "section": "\nE.5 trace",
    "text": "E.5 trace\nPuede agregar la declaración del navegador más adelante en la función, y no al principio, con trace. trace toma el nombre de una función como una cadena de caracteres y luego una expresión R para insertarla en la función. También puede proporcionar un argumento at que le diga a trace en qué línea de la función colocar la expresión. Entonces, para insertar una llamada del navegador en la cuarta línea de sample, ejecutaría:\ntrace(\"sample\", browser, at = 4)\nPuede usar trace para insertar otras funciones de R (no solo browser) en una función, pero es posible que deba pensar en una razón inteligente para hacerlo. También puede ejecutar trace en una función sin insertar ningún código nuevo. R imprimirá trace:&lt;the function&gt; en la línea de comando cada vez que R ejecute la función. Esta es una excelente manera de probar una afirmación que hice en S3, que R llama a print cada vez que muestra algo en la línea de comando:\ntrace(print)\n\nprimera\n## trace: print(function () segunda())\n## function() segunda()\n\nhead(mazo)\n## trace: print\n##    cara  palo valor\n## 1   rey picas    13\n## 2 reina picas    12\n## 3  jota picas    11\n## 4  diez picas    10\n## 5 nueve picas     9\n## 6  ocho picas     8\nPuede revertir una función a la normalidad después de llamar a trace con untrace:\nuntrace(sample)\nuntrace(print)",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>Depuración de Código de R</span>"
    ]
  },
  {
    "objectID": "a5-debug.html#recover",
    "href": "a5-debug.html#recover",
    "title": "Apéndice E — Depuración de Código de R",
    "section": "\nE.6 recover",
    "text": "E.6 recover\nLa función recover proporciona una opción final para la depuración. Combina la pila de llamadas de traceback con el modo de navegador de browser. Puedes usar recover como browser, insertándolo directamente en el cuerpo de una función. Demostremos recover con la función quinta:\nquinta &lt;- function() recover()\nCuando R ejecuta recover, hará una pausa y mostrará la pila de llamadas, pero eso no es todo. R te da la opción de abrir un modo navegador en cualquiera de las funciones que aparecen en la pila de llamadas. De manera molesta, la pila de llamadas se mostrará al revés en comparación con traceback. La función más reciente estará en la parte inferior y la función original estará en la parte superior:\nprimera()\n## \n## Enter a frame number, or 0 to exit   \n## \n## 1: primera()\n## 2: #1: segunda()\n## 3: #1: tercera()\n## 4: #1: cuarta()\n## 5: #1: quinta()\nPara entrar en un modo de navegador, escriba el número junto a la función en cuyo entorno de tiempo de ejecución le gustaría navegar. Si no desea navegar por ninguna de las funciones, escriba 0:\n3\n## Selection: 3\n## Called from: cuarta()\n## Browse[1]&gt; \nA continuación, puede proceder con normalidad. recover le brinda la oportunidad de inspeccionar variables arriba y abajo de su pila de llamadas y es una herramienta poderosa para descubrir errores. Sin embargo, agregar recover al cuerpo de una función R puede ser engorroso. La mayoría de los usuarios de R lo usan como una opción global para manejar errores.\nSi ejecuta el siguiente código, R llamará automáticamente a recover() cada vez que ocurra un error:\noptions(error = recover)\nEste comportamiento durará hasta que cierre su sesión de R, o invierta el comportamiento llamando:\noptions(error = NULL)",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>Depuración de Código de R</span>"
    ]
  }
]